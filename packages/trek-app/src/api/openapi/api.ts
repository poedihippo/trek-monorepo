/* tslint:disable */
/* eslint-disable */
/**
 * Melandas Staging
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiV1ActivitiesEstimations
 */
export interface ApiV1ActivitiesEstimations {
    /**
     * Product brand id
     * @type {number}
     * @memberof ApiV1ActivitiesEstimations
     */
    product_brand_id?: number;
    /**
     * Estimated value of product brand
     * @type {number}
     * @memberof ApiV1ActivitiesEstimations
     */
    estimated_value?: number;
}
/**
 * 
 * @export
 * @interface ApiV1CartDemandsItems
 */
export interface ApiV1CartDemandsItems {
    /**
     * Name of product unit
     * @type {string}
     * @memberof ApiV1CartDemandsItems
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiV1CartDemandsItems
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiV1CartDemandsItems
     */
    quantity?: number;
}
/**
 * 
 * @export
 * @interface ApiV1CartsItems
 */
export interface ApiV1CartsItems {
    /**
     * The product unit id to add to cart
     * @type {number}
     * @memberof ApiV1CartsItems
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiV1CartsItems
     */
    quantity?: number;
}
/**
 * 
 * @export
 * @interface ImageRequestBody
 */
export interface ImageRequestBody {
    /**
     * 
     * @type {any}
     * @memberof ImageRequestBody
     */
    image?: any;
}
/**
 * 
 * @export
 * @interface ImageRequestBody1
 */
export interface ImageRequestBody1 {
    /**
     * 
     * @type {any}
     * @memberof ImageRequestBody1
     */
    image?: any;
}
/**
 * 
 * @export
 * @interface ImageRequestBody2
 */
export interface ImageRequestBody2 {
    /**
     * 
     * @type {any}
     * @memberof ImageRequestBody2
     */
    image?: any;
}
/**
 * 
 * @export
 * @interface ImageRequestBody3
 */
export interface ImageRequestBody3 {
    /**
     * 
     * @type {any}
     * @memberof ImageRequestBody3
     */
    image?: any;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    address_line_1?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    address_line_2?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    address_line_3?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    postcode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    province?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    type?: `${InlineObject1TypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    date_of_birth?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    title?: `${InlineObject1TitleEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    email?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject1TypeEnum {
    Address = 'ADDRESS',
    Delivery = 'DELIVERY',
    Billing = 'BILLING'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineObject1TitleEnum {
    Mr = 'MR',
    Ms = 'MS',
    Mrs = 'MRS'
}

/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    type?: `${InlineObject10TypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject10
     */
    customer_id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject10
     */
    is_unhandled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineObject10
     */
    lead_category_id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    interest?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject10TypeEnum {
    Prospect = 'PROSPECT',
    Drop = 'DROP',
    Leads = 'LEADS'
}

/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    type?: `${InlineObject11TypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject11
     */
    customer_id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject11
     */
    interest?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject11TypeEnum {
    Prospect = 'PROSPECT',
    Drop = 'DROP',
    Leads = 'LEADS'
}

/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    follow_up_datetime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    follow_up_method?: `${InlineObject12FollowUpMethodEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    status?: `${InlineObject12StatusEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    feedback?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject12
     */
    lead_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject12
     */
    estimated_value?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    reminder_datetime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject12
     */
    reminder_note?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof InlineObject12
     */
    brand_ids?: Array<number>;
    /**
     * 
     * @type {Array<ApiV1ActivitiesEstimations>}
     * @memberof InlineObject12
     */
    estimations?: Array<ApiV1ActivitiesEstimations>;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject12FollowUpMethodEnum {
    Phone = 'PHONE',
    Whatsapp = 'WHATSAPP',
    Meeting = 'MEETING',
    Others = 'OTHERS',
    WalkInCustomer = 'WALK_IN_CUSTOMER',
    NewOrder = 'NEW_ORDER'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineObject12StatusEnum {
    Hot = 'HOT',
    Warm = 'WARM',
    Cold = 'COLD',
    Drop = 'DROP'
}

/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    follow_up_datetime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    follow_up_method?: `${InlineObject13FollowUpMethodEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    status?: `${InlineObject13StatusEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    feedback?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject13
     */
    lead_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject13
     */
    estimated_value?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    reminder_datetime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    reminder_note?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof InlineObject13
     */
    brand_ids?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject13FollowUpMethodEnum {
    Phone = 'PHONE',
    Whatsapp = 'WHATSAPP',
    Meeting = 'MEETING',
    Others = 'OTHERS',
    WalkInCustomer = 'WALK_IN_CUSTOMER',
    NewOrder = 'NEW_ORDER'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineObject13StatusEnum {
    Hot = 'HOT',
    Warm = 'WARM',
    Cold = 'COLD',
    Drop = 'DROP'
}

/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    content?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject14
     */
    activity_comment_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject14
     */
    activity_id?: number;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject15
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject16
     */
    customer_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject16
     */
    lead_id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    product_brand?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    product_unit?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject16
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject16
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    subject?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof InlineObject17
     */
    users?: Array<number>;
}
/**
 * 
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    subject?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof InlineObject18
     */
    users?: Array<number>;
}
/**
 * 
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject19
     */
    topic_id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    date_of_birth?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    title?: `${InlineObject2TitleEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    phone?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject2TitleEnum {
    Mr = 'MR',
    Ms = 'MS',
    Mrs = 'MRS'
}

/**
 * 
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
    /**
     * 
     * @type {Array<ApiV1CartsItems>}
     * @memberof InlineObject21
     */
    items?: Array<ApiV1CartsItems>;
}
/**
 * 
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
    /**
     * 
     * @type {Array<ApiV1CartDemandsItems>}
     * @memberof InlineObject22
     */
    items?: Array<ApiV1CartDemandsItems>;
}
/**
 * 
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
    /**
     * 
     * @type {Array<ApiV1CartsItems>}
     * @memberof InlineObject23
     */
    items?: Array<ApiV1CartsItems>;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    discount_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    interior_design_id?: number;
    /**
     * Provide expected price of the order for consistency checking.
     * @type {number}
     * @memberof InlineObject23
     */
    expected_price?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    shipping_address_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    billing_address_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    tax_invoice_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    lead_id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    note?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    shipping_fee?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    packing_fee?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    discount_type?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject23
     */
    additional_discount?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    expected_shipping_datetime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject23
     */
    quotation_valid_until_datetime?: string;
}
/**
 * 
 * @export
 * @interface InlineObject24
 */
export interface InlineObject24 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject24
     */
    discount_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject24
     */
    discount_type?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject24
     */
    additional_discount?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject24
     */
    discount_take_over_by?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject24
     */
    approval_note?: number;
}
/**
 * 
 * @export
 * @interface InlineObject25
 */
export interface InlineObject25 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject25
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject25
     */
    reject?: string;
}
/**
 * 
 * @export
 * @interface InlineObject26
 */
export interface InlineObject26 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject26
     */
    discount_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject26
     */
    discount_type?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject26
     */
    additional_discount?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject26
     */
    discount_take_over_by?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject26
     */
    approval_note?: number;
}
/**
 * 
 * @export
 * @interface InlineObject27
 */
export interface InlineObject27 {
    /**
     * Provide expected price of the order for consistency checking.
     * @type {number}
     * @memberof InlineObject27
     */
    expected_price?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InlineObject27
     */
    note?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject27
     */
    additional_discount?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject27
     */
    expected_shipping_datetime?: string;
}
/**
 * 
 * @export
 * @interface InlineObject28
 */
export interface InlineObject28 {
    /**
     * 
     * @type {Array<ApiV1CartsItems>}
     * @memberof InlineObject28
     */
    items?: Array<ApiV1CartsItems>;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    discount_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    interior_design_id?: number;
    /**
     * Provide expected price of the order for consistency checking.
     * @type {number}
     * @memberof InlineObject28
     */
    expected_price?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    shipping_address_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    billing_address_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    tax_invoice_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    lead_id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject28
     */
    note?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    shipping_fee?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    packing_fee?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    discount_type?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject28
     */
    additional_discount?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject28
     */
    expected_shipping_datetime?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject28
     */
    quotation_valid_until_datetime?: string;
}
/**
 * 
 * @export
 * @interface InlineObject29
 */
export interface InlineObject29 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject29
     */
    discount_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject29
     */
    discount_type?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject29
     */
    additional_discount?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject29
     */
    discount_take_over_by?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject29
     */
    approval_note?: number;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    date_of_birth?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    title?: `${InlineObject3TitleEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    phone?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject3
     */
    default_address_id?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject3TitleEnum {
    Mr = 'MR',
    Ms = 'MS',
    Mrs = 'MRS'
}

/**
 * 
 * @export
 * @interface InlineObject30
 */
export interface InlineObject30 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject30
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject30
     */
    reference?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject30
     */
    payment_type_id?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject30
     */
    order_id?: number;
}
/**
 * 
 * @export
 * @interface InlineObject31
 */
export interface InlineObject31 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject31
     */
    reference?: string;
}
/**
 * 
 * @export
 * @interface InlineObject32
 */
export interface InlineObject32 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject32
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject32
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface InlineObject33
 */
export interface InlineObject33 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject33
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject33
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject33
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject33
     */
    phone?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject33
     */
    channel_id?: number;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    address_line_1?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    address_line_2?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    address_line_3?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    postcode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    province?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    type?: `${InlineObject4TypeEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineObject4
     */
    customer_id?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject4TypeEnum {
    Address = 'ADDRESS',
    Delivery = 'DELIVERY',
    Billing = 'BILLING'
}

/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    address_line_1?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    address_line_2?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    address_line_3?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    postcode?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    province?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    type?: `${InlineObject5TypeEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineObject5
     */
    customer_id?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject5TypeEnum {
    Address = 'ADDRESS',
    Delivery = 'DELIVERY',
    Billing = 'BILLING'
}

/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    body?: string;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    note?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject7
     */
    product_brand_id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    voucher?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject7
     */
    voucher_image?: string;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    note?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject8
     */
    product_brand_id?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject8
     */
    voucher?: string;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject9
     */
    user_id?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {InlineResponse200Data}
     * @memberof InlineResponse200
     */
    data?: InlineResponse200Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<InlineResponse2001Data>}
     * @memberof InlineResponse2001
     */
    data?: Array<InlineResponse2001Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse2001
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2001
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse2001
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {Array<InlineResponse2009Data>}
     * @memberof InlineResponse20010
     */
    data?: Array<InlineResponse2009Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20010
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20010
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20010
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {Array<InlineResponse20011Data>}
     * @memberof InlineResponse20011
     */
    data?: Array<InlineResponse20011Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20011
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20011
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20011
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Data
 */
export interface InlineResponse20011Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Data
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {InlineResponse20012Data}
     * @memberof InlineResponse20012
     */
    data: InlineResponse20012Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20012Data
 */
export interface InlineResponse20012Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012Data
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012Data
     */
    bum_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012Data
     */
    sales_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012Data
     */
    religion_id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    company: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    owner: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    npwp: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    bank_account_name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Data
     */
    bank_account_holder: string;
    /**
     * 
     * @type {InlineResponse20012DataReligion}
     * @memberof InlineResponse20012Data
     */
    religion?: InlineResponse20012DataReligion;
}
/**
 * 
 * @export
 * @interface InlineResponse20012DataReligion
 */
export interface InlineResponse20012DataReligion {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012DataReligion
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012DataReligion
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {Array<InlineResponse20013Data>}
     * @memberof InlineResponse20013
     */
    data?: Array<InlineResponse20013Data>;
}
/**
 * 
 * @export
 * @interface InlineResponse20013Data
 */
export interface InlineResponse20013Data {
    /**
     * identifier of the form value
     * @type {string}
     * @memberof InlineResponse20013Data
     */
    key?: string;
    /**
     * Label for the form display
     * @type {string}
     * @memberof InlineResponse20013Data
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013Data
     */
    formType?: `${InlineResponse20013DataFormTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013Data
     */
    dataFormat?: `${InlineResponse20013DataDataFormatEnum}`;
    /**
     * 
     * @type {Array<InlineResponse20013Options>}
     * @memberof InlineResponse20013Data
     */
    options?: Array<InlineResponse20013Options>;
    /**
     * Laravel style validation rule
     * @type {string}
     * @memberof InlineResponse20013Data
     */
    validationRule?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20013DataFormTypeEnum {
    Text = 'text',
    Password = 'password',
    Textarea = 'textarea',
    Radio = 'radio',
    Checkbox = 'checkbox',
    Select = 'select'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20013DataDataFormatEnum {
    Default = 'default',
    Numeric = 'numeric',
    Boolean = 'boolean',
    Date = 'date',
    Csv = 'csv',
    Enum = 'enum'
}

/**
 * 
 * @export
 * @interface InlineResponse20013Options
 */
export interface InlineResponse20013Options {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013Options
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013Options
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {Array<InlineResponse20014Data>}
     * @memberof InlineResponse20014
     */
    data?: Array<InlineResponse20014Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20014
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20014
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20014
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20014Customer
 */
export interface InlineResponse20014Customer {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014Customer
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Customer
     */
    title: `${InlineResponse20014CustomerTitleEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Customer
     */
    first_name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Customer
     */
    last_name: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Customer
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Customer
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Customer
     */
    date_of_birth: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014Customer
     */
    default_address_id: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20014Customer
     */
    has_activity: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20014CustomerTitleEnum {
    Mr = 'MR',
    Ms = 'MS',
    Mrs = 'MRS'
}

/**
 * 
 * @export
 * @interface InlineResponse20014Data
 */
export interface InlineResponse20014Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Data
     */
    type: `${InlineResponse20014DataTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Data
     */
    status: `${InlineResponse20014DataStatusEnum}`;
    /**
     * User provided/auto generated description for the lead.
     * @type {string}
     * @memberof InlineResponse20014Data
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Data
     */
    interest: string;
    /**
     * 
     * @type {InlineResponse20014Customer}
     * @memberof InlineResponse20014Data
     */
    customer?: InlineResponse20014Customer;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20014Data
     */
    user?: InlineResponse20014User;
    /**
     * 
     * @type {InlineResponse20014LeadCategory}
     * @memberof InlineResponse20014Data
     */
    lead_category?: InlineResponse20014LeadCategory;
    /**
     * 
     * @type {InlineResponse20014LeadSubCategory}
     * @memberof InlineResponse20014Data
     */
    lead_sub_category?: InlineResponse20014LeadSubCategory;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20014Data
     */
    is_unhandled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20014Data
     */
    has_activity: boolean;
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse20014Data
     */
    channel?: InlineResponse2009Data;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Data
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20014DataTypeEnum {
    Prospect = 'PROSPECT',
    Drop = 'DROP',
    Leads = 'LEADS'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20014DataStatusEnum {
    Green = 'GREEN',
    Yellow = 'YELLOW',
    Red = 'RED',
    Expired = 'EXPIRED',
    Sales = 'SALES',
    OtherSales = 'OTHER_SALES'
}

/**
 * 
 * @export
 * @interface InlineResponse20014LeadCategory
 */
export interface InlineResponse20014LeadCategory {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014LeadCategory
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014LeadCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014LeadCategory
     */
    description: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20014LeadSubCategory
 */
export interface InlineResponse20014LeadSubCategory {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014LeadSubCategory
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014LeadSubCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014LeadSubCategory
     */
    description: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20014User
 */
export interface InlineResponse20014User {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014User
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014User
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014User
     */
    initial: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014User
     */
    as: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014User
     */
    reportable_type: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014User
     */
    email: string;
    /**
     * User type determine the feature should be made avaiable to them. The available enum options are hard coded.
     * @type {string}
     * @memberof InlineResponse20014User
     */
    type: `${InlineResponse20014UserTypeEnum}`;
    /**
     * The company that this user belongs to
     * @type {number}
     * @memberof InlineResponse20014User
     */
    company_id: number | null;
    /**
     * The default channel currently selected for this user
     * @type {number}
     * @memberof InlineResponse20014User
     */
    channel_id: number | null;
    /**
     * The user id of this user\'s supervisor
     * @type {number}
     * @memberof InlineResponse20014User
     */
    supervisor_id: number | null;
    /**
     * If this user is a supervisor, this return the supervisor type id
     * @type {number}
     * @memberof InlineResponse20014User
     */
    supervisor_type_id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014User
     */
    discount_approval_limit_percentage: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20014User
     */
    app_show_hpp: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20014User
     */
    app_approve_discount: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20014User
     */
    app_create_lead: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20014UserTypeEnum {
    Default = 'DEFAULT',
    Sales = 'SALES',
    Supervisor = 'SUPERVISOR',
    Director = 'DIRECTOR',
    DigitalMarketing = 'DigitalMarketing',
    SalesSms = 'SALES_SMS',
    SupervisorSms = 'SUPERVISOR_SMS'
}

/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {Array<InlineResponse20015Data>}
     * @memberof InlineResponse20015
     */
    data?: Array<InlineResponse20015Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20015
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20015
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20015
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20015ActivityBrandValues
 */
export interface InlineResponse20015ActivityBrandValues {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015ActivityBrandValues
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015ActivityBrandValues
     */
    estimated_value: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015ActivityBrandValues
     */
    order_value: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015ActivityBrandValues
     */
    name: string;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20015ActivityBrandValues
     */
    images?: Array<InlineResponse2007Logo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20015Brands
 */
export interface InlineResponse20015Brands {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Brands
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Brands
     */
    estimated_value: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Brands
     */
    order_value: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Brands
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20015Data
 */
export interface InlineResponse20015Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Data
     */
    follow_up_datetime: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Data
     */
    feedback: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Data
     */
    follow_up_method: `${InlineResponse20015DataFollowUpMethodEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Data
     */
    status: `${InlineResponse20015DataStatusEnum}`;
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse20015Data
     */
    channel?: InlineResponse2009Data;
    /**
     * 
     * @type {Array<InlineResponse20015ActivityBrandValues>}
     * @memberof InlineResponse20015Data
     */
    activity_brand_values?: Array<InlineResponse20015ActivityBrandValues>;
    /**
     * 
     * @type {Array<InlineResponse20015Brands>}
     * @memberof InlineResponse20015Data
     */
    brands?: Array<InlineResponse20015Brands>;
    /**
     * 
     * @type {InlineResponse20015Order}
     * @memberof InlineResponse20015Data
     */
    order?: InlineResponse20015Order;
    /**
     * 
     * @type {InlineResponse20015Lead}
     * @memberof InlineResponse20015Data
     */
    lead?: InlineResponse20015Lead;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20015Data
     */
    user?: InlineResponse20014User;
    /**
     * 
     * @type {InlineResponse20014Customer}
     * @memberof InlineResponse20015Data
     */
    customer?: InlineResponse20014Customer;
    /**
     * 
     * @type {InlineResponse20015LatestComment}
     * @memberof InlineResponse20015Data
     */
    latest_comment?: InlineResponse20015LatestComment;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Data
     */
    activity_comment_count: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Data
     */
    estimated_value: number | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Data
     */
    reminder_datetime: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Data
     */
    reminder_note: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Data
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015DataFollowUpMethodEnum {
    Phone = 'PHONE',
    Whatsapp = 'WHATSAPP',
    Meeting = 'MEETING',
    Others = 'OTHERS',
    WalkInCustomer = 'WALK_IN_CUSTOMER',
    NewOrder = 'NEW_ORDER'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015DataStatusEnum {
    Hot = 'HOT',
    Warm = 'WARM',
    Cold = 'COLD',
    Drop = 'DROP'
}

/**
 * 
 * @export
 * @interface InlineResponse20015LatestComment
 */
export interface InlineResponse20015LatestComment {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015LatestComment
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015LatestComment
     */
    content: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015LatestComment
     */
    activity_id: number;
    /**
     * The activity comment id this comment replied to
     * @type {number}
     * @memberof InlineResponse20015LatestComment
     */
    activity_comment_id: number | null;
    /**
     * The activity comment content this comment replied to
     * @type {string}
     * @memberof InlineResponse20015LatestComment
     */
    activity_comment_content: string | null;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20015LatestComment
     */
    user?: InlineResponse20014User;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015LatestComment
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015LatestComment
     */
    created_at: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20015Lead
 */
export interface InlineResponse20015Lead {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Lead
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Lead
     */
    type: `${InlineResponse20015LeadTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Lead
     */
    status: `${InlineResponse20015LeadStatusEnum}`;
    /**
     * User provided/auto generated description for the lead.
     * @type {string}
     * @memberof InlineResponse20015Lead
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Lead
     */
    interest: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20015Lead
     */
    is_unhandled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20015Lead
     */
    has_activity: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Lead
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Lead
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015LeadTypeEnum {
    Prospect = 'PROSPECT',
    Drop = 'DROP',
    Leads = 'LEADS'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015LeadStatusEnum {
    Green = 'GREEN',
    Yellow = 'YELLOW',
    Red = 'RED',
    Expired = 'EXPIRED',
    Sales = 'SALES',
    OtherSales = 'OTHER_SALES'
}

/**
 * 
 * @export
 * @interface InlineResponse20015Order
 */
export interface InlineResponse20015Order {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    original_price: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    total_discount: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    total_price: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    shipping_fee: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    packing_fee: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    additional_discount: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    additional_discount_ratio: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    amount_paid: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    invoice_number: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    status: `${InlineResponse20015OrderStatusEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    payment_status: `${InlineResponse20015OrderPaymentStatusEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    payment_status_for_invoice: `${InlineResponse20015OrderPaymentStatusForInvoiceEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    approval_status: `${InlineResponse20015OrderApprovalStatusEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    discount_error: `${InlineResponse20015OrderDiscountErrorEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    lead_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    user_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    channel_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    company_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    interior_design_id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    discount_id: number | null;
    /**
     * 
     * @type {Array<InlineResponse20015OrderOrderDetails>}
     * @memberof InlineResponse20015Order
     */
    order_details?: Array<InlineResponse20015OrderOrderDetails>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    expected_shipping_datetime: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    quotation_valid_until_datetime: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    note: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    approval_note: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015Order
     */
    discount_approval_limit_percentage: number | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015Order
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015OrderStatusEnum {
    Quotation = 'QUOTATION',
    Shipment = 'SHIPMENT',
    Cancelled = 'CANCELLED',
    Returned = 'RETURNED'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015OrderPaymentStatusEnum {
    None = 'NONE',
    Partial = 'PARTIAL',
    Settlement = 'SETTLEMENT',
    Overpayment = 'OVERPAYMENT',
    Refunded = 'REFUNDED',
    DownPayment = 'DOWN_PAYMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015OrderPaymentStatusForInvoiceEnum {
    None = 'NONE',
    Partial = 'PARTIAL',
    Settlement = 'SETTLEMENT',
    Overpayment = 'OVERPAYMENT',
    Refunded = 'REFUNDED',
    DownPayment = 'DOWN_PAYMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015OrderApprovalStatusEnum {
    NotRequired = 'NOT_REQUIRED',
    WaitingApproval = 'WAITING_APPROVAL',
    Approved = 'APPROVED',
    Rejected = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015OrderDiscountErrorEnum {
    Inactive = 'INACTIVE',
    UseLimitReached = 'USE_LIMIT_REACHED',
    UnderMinimumPrice = 'UNDER_MINIMUM_PRICE',
    NotApplicableToAnyProduct = 'NOT_APPLICABLE_TO_ANY_PRODUCT'
}

/**
 * 
 * @export
 * @interface InlineResponse20015OrderBrand
 */
export interface InlineResponse20015OrderBrand {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderBrand
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20015OrderCategoryCode
 */
export interface InlineResponse20015OrderCategoryCode {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderCategoryCode
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20015OrderColour
 */
export interface InlineResponse20015OrderColour {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderColour
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderColour
     */
    description: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20015OrderCovering
 */
export interface InlineResponse20015OrderCovering {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderCovering
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderCovering
     */
    type: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015OrderCovering
     */
    product_id: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20015OrderOrderDetails
 */
export interface InlineResponse20015OrderOrderDetails {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    quantity: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    unit_price: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    total_discount: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    total_price: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    status: `${InlineResponse20015OrderOrderDetailsStatusEnum}`;
    /**
     * 
     * @type {InlineResponse20015OrderProductUnit}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    product_unit?: InlineResponse20015OrderProductUnit;
    /**
     * 
     * @type {InlineResponse20015OrderColour}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    colour?: InlineResponse20015OrderColour;
    /**
     * 
     * @type {InlineResponse20015OrderCovering}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    covering?: InlineResponse20015OrderCovering;
    /**
     * 
     * @type {InlineResponse20015OrderProduct}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    product?: InlineResponse20015OrderProduct;
    /**
     * 
     * @type {InlineResponse20015OrderBrand}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    brand?: InlineResponse20015OrderBrand;
    /**
     * 
     * @type {InlineResponse20015OrderBrand}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    model?: InlineResponse20015OrderBrand;
    /**
     * 
     * @type {InlineResponse20015OrderVersion}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    version?: InlineResponse20015OrderVersion;
    /**
     * 
     * @type {InlineResponse20015OrderCategoryCode}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    category_code?: InlineResponse20015OrderCategoryCode;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    images?: Array<InlineResponse2007Logo>;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20015OrderOrderDetails
     */
    photo?: Array<InlineResponse2007Logo>;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20015OrderOrderDetailsStatusEnum {
    NotFulfilled = 'NOT_FULFILLED',
    PartiallyFulfilled = 'PARTIALLY_FULFILLED',
    Fulfilled = 'FULFILLED',
    OverFulfilled = 'OVER_FULFILLED'
}

/**
 * 
 * @export
 * @interface InlineResponse20015OrderProduct
 */
export interface InlineResponse20015OrderProduct {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderProduct
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015OrderProduct
     */
    price: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderProduct
     */
    video_url: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderProduct
     */
    description: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20015OrderProductUnit
 */
export interface InlineResponse20015OrderProductUnit {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderProductUnit
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015OrderProductUnit
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015OrderProductUnit
     */
    production_cost: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20015OrderVersion
 */
export interface InlineResponse20015OrderVersion {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderVersion
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderVersion
     */
    height: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderVersion
     */
    width: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015OrderVersion
     */
    length: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {Array<InlineResponse201Data>}
     * @memberof InlineResponse20016
     */
    data?: Array<InlineResponse201Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20016
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20016
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20016
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {Array<InlineResponse20017Data>}
     * @memberof InlineResponse20017
     */
    data?: Array<InlineResponse20017Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20017
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20017
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20017
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20017Data
 */
export interface InlineResponse20017Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20017Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    address_line_1: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    address_line_2: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    address_line_3: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    postcode: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    city: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    country: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    province: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    phone: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    type: `${InlineResponse20017DataTypeEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20017Data
     */
    customer_id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017Data
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20017DataTypeEnum {
    Address = 'ADDRESS',
    Delivery = 'DELIVERY',
    Billing = 'BILLING'
}

/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {Array<InlineResponse20018Data>}
     * @memberof InlineResponse20018
     */
    data?: Array<InlineResponse20018Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20018
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20018
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20018
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20018Data
 */
export interface InlineResponse20018Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018Data
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018Data
     */
    type: `${InlineResponse20018DataTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018Data
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018Data
     */
    body: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018Data
     */
    link: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20018DataTypeEnum {
    ActivityReminder = 'ActivityReminder',
    NewLeadAssigned = 'NewLeadAssigned',
    DiscountApproval = 'DiscountApproval'
}

/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {Array<InlineResponse20019Data>}
     * @memberof InlineResponse20019
     */
    data?: Array<InlineResponse20019Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20019
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20019
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20019
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20019Data
 */
export interface InlineResponse20019Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20019Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019Data
     */
    type: `${InlineResponse20019DataTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019Data
     */
    status: string;
    /**
     * User provided/auto generated description for the lead.
     * @type {string}
     * @memberof InlineResponse20019Data
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019Data
     */
    interest: string;
    /**
     * 
     * @type {InlineResponse20014Customer}
     * @memberof InlineResponse20019Data
     */
    customer?: InlineResponse20014Customer;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20019Data
     */
    user_sms?: InlineResponse20014User;
    /**
     * 
     * @type {InlineResponse2001Data}
     * @memberof InlineResponse20019Data
     */
    sms_channel?: InlineResponse2001Data;
    /**
     * 
     * @type {InlineResponse20015Brands}
     * @memberof InlineResponse20019Data
     */
    product_brand?: InlineResponse20015Brands;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20019Data
     */
    is_unhandled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20019Data
     */
    has_activity: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019Data
     */
    voucher: string;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20019Data
     */
    voucher_image?: Array<InlineResponse2007Logo>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019Data
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20019DataTypeEnum {
    Prospect = 'PROSPECT',
    Drop = 'DROP',
    Leads = 'LEADS'
}

/**
 * 
 * @export
 * @interface InlineResponse2001Data
 */
export interface InlineResponse2001Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Data
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {InlineResponse2001Data}
     * @memberof InlineResponse2002
     */
    data: InlineResponse2001Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * 
     * @type {InlineResponse20019Data}
     * @memberof InlineResponse20020
     */
    data: InlineResponse20019Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * 
     * @type {Array<InlineResponse20021Data>}
     * @memberof InlineResponse20021
     */
    data?: Array<InlineResponse20021Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20021
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20021
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20021
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20021Data
 */
export interface InlineResponse20021Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20021Data
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20021Data
     */
    estimated_value: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20021Data
     */
    order_value: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20021Data
     */
    name: string;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20021Data
     */
    images?: Array<InlineResponse2007Logo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {Array<InlineResponse20014LeadCategory>}
     * @memberof InlineResponse20022
     */
    data?: Array<InlineResponse20014LeadCategory>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20022
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20022
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20022
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * 
     * @type {Array<InlineResponse20014LeadSubCategory>}
     * @memberof InlineResponse20023
     */
    data?: Array<InlineResponse20014LeadSubCategory>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20023
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20023
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20023
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {InlineResponse20024Data}
     * @memberof InlineResponse20024
     */
    data: InlineResponse20024Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20024Data
 */
export interface InlineResponse20024Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20024Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024Data
     */
    type: `${InlineResponse20024DataTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024Data
     */
    status: `${InlineResponse20024DataStatusEnum}`;
    /**
     * User provided/auto generated description for the lead.
     * @type {string}
     * @memberof InlineResponse20024Data
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024Data
     */
    interest: string;
    /**
     * 
     * @type {InlineResponse20014Customer}
     * @memberof InlineResponse20024Data
     */
    customer?: InlineResponse20014Customer;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20024Data
     */
    user?: InlineResponse20014User;
    /**
     * 
     * @type {InlineResponse20014LeadCategory}
     * @memberof InlineResponse20024Data
     */
    lead_category?: InlineResponse20014LeadCategory;
    /**
     * 
     * @type {InlineResponse20014LeadSubCategory}
     * @memberof InlineResponse20024Data
     */
    lead_sub_category?: InlineResponse20014LeadSubCategory;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20024Data
     */
    is_unhandled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20024Data
     */
    has_activity: boolean;
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse20024Data
     */
    channel?: InlineResponse2009Data;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024Data
     */
    created_at: string | null;
    /**
     * 
     * @type {InlineResponse20024DataLatestActivity}
     * @memberof InlineResponse20024Data
     */
    latest_activity?: InlineResponse20024DataLatestActivity | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20024DataTypeEnum {
    Prospect = 'PROSPECT',
    Drop = 'DROP',
    Leads = 'LEADS'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20024DataStatusEnum {
    Green = 'GREEN',
    Yellow = 'YELLOW',
    Red = 'RED',
    Expired = 'EXPIRED',
    Sales = 'SALES',
    OtherSales = 'OTHER_SALES'
}

/**
 * The latest activity sorted by creation time.
 * @export
 * @interface InlineResponse20024DataLatestActivity
 */
export interface InlineResponse20024DataLatestActivity {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20024DataLatestActivity
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataLatestActivity
     */
    follow_up_datetime: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataLatestActivity
     */
    feedback: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataLatestActivity
     */
    follow_up_method: `${InlineResponse20024DataLatestActivityFollowUpMethodEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataLatestActivity
     */
    status: `${InlineResponse20024DataLatestActivityStatusEnum}`;
    /**
     * 
     * @type {Array<InlineResponse20015ActivityBrandValues>}
     * @memberof InlineResponse20024DataLatestActivity
     */
    activity_brand_values?: Array<InlineResponse20015ActivityBrandValues>;
    /**
     * 
     * @type {Array<InlineResponse20015Brands>}
     * @memberof InlineResponse20024DataLatestActivity
     */
    brands?: Array<InlineResponse20015Brands>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20024DataLatestActivity
     */
    activity_comment_count: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20024DataLatestActivity
     */
    estimated_value: number | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataLatestActivity
     */
    reminder_datetime: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataLatestActivity
     */
    reminder_note: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataLatestActivity
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024DataLatestActivity
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20024DataLatestActivityFollowUpMethodEnum {
    Phone = 'PHONE',
    Whatsapp = 'WHATSAPP',
    Meeting = 'MEETING',
    Others = 'OTHERS',
    WalkInCustomer = 'WALK_IN_CUSTOMER',
    NewOrder = 'NEW_ORDER'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20024DataLatestActivityStatusEnum {
    Hot = 'HOT',
    Warm = 'WARM',
    Cold = 'COLD',
    Drop = 'DROP'
}

/**
 * 
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {Array<InlineResponse20015LatestComment>}
     * @memberof InlineResponse20025
     */
    data?: Array<InlineResponse20015LatestComment>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20025
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20025
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20025
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {Array<InlineResponse20026Data>}
     * @memberof InlineResponse20026
     */
    data?: Array<InlineResponse20026Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20026
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20026
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20026
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20026Data
 */
export interface InlineResponse20026Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20026Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026Data
     */
    description: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20026Data
     */
    price_min: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20026Data
     */
    price_max: number | null;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20026Data
     */
    images?: Array<InlineResponse2007Logo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * 
     * @type {InlineResponse20026Data}
     * @memberof InlineResponse20027
     */
    data: InlineResponse20026Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * 
     * @type {Array<InlineResponse20028Data>}
     * @memberof InlineResponse20028
     */
    data?: Array<InlineResponse20028Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20028
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20028
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20028
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20028Data
 */
export interface InlineResponse20028Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20028Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028Data
     */
    height: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028Data
     */
    width: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028Data
     */
    length: string | null;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20028Data
     */
    images?: Array<InlineResponse2007Logo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * 
     * @type {Array<InlineResponse20029Data>}
     * @memberof InlineResponse20029
     */
    data?: Array<InlineResponse20029Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20029
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20029
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20029
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20029Data
 */
export interface InlineResponse20029Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20029Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20029Data
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {InlineResponse2003Data}
     * @memberof InlineResponse2003
     */
    data: InlineResponse2003Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * 
     * @type {Array<InlineResponse20030Data>}
     * @memberof InlineResponse20030
     */
    data?: Array<InlineResponse20030Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20030
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20030
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20030
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20030Categories
 */
export interface InlineResponse20030Categories {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Categories
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Categories
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Categories
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Categories
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Categories
     */
    parent_id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Categories
     */
    level: number | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Categories
     */
    type: `${InlineResponse20030CategoriesTypeEnum}`;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20030CategoriesTypeEnum {
    Collection = 'COLLECTION',
    SubCollection = 'SUB_COLLECTION',
    BrandType = 'BRAND_TYPE',
    Brand = 'BRAND',
    Category = 'CATEGORY'
}

/**
 * 
 * @export
 * @interface InlineResponse20030Data
 */
export interface InlineResponse20030Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Data
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Data
     */
    price: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Data
     */
    video_url: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Data
     */
    description: string;
    /**
     * 
     * @type {Array<InlineResponse20030Categories>}
     * @memberof InlineResponse20030Data
     */
    categories?: Array<InlineResponse20030Categories>;
    /**
     * 
     * @type {Array<InlineResponse20030Tags>}
     * @memberof InlineResponse20030Data
     */
    tags?: Array<InlineResponse20030Tags>;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20030Data
     */
    images?: Array<InlineResponse2007Logo>;
    /**
     * 
     * @type {InlineResponse20015Brands}
     * @memberof InlineResponse20030Data
     */
    brand?: InlineResponse20015Brands;
    /**
     * 
     * @type {InlineResponse20030Model}
     * @memberof InlineResponse20030Data
     */
    model?: InlineResponse20030Model;
    /**
     * 
     * @type {InlineResponse20030Version}
     * @memberof InlineResponse20030Data
     */
    version?: InlineResponse20030Version;
    /**
     * 
     * @type {InlineResponse20029Data}
     * @memberof InlineResponse20030Data
     */
    category_code?: InlineResponse20029Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20030Model
 */
export interface InlineResponse20030Model {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Model
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Model
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Model
     */
    description: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Model
     */
    price_min: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Model
     */
    price_max: number | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20030Tags
 */
export interface InlineResponse20030Tags {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Tags
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Tags
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Tags
     */
    slug: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20030Version
 */
export interface InlineResponse20030Version {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030Version
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Version
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Version
     */
    height: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Version
     */
    width: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030Version
     */
    length: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * 
     * @type {InlineResponse20030Data}
     * @memberof InlineResponse20031
     */
    data: InlineResponse20030Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * 
     * @type {Array<InlineResponse20032Data>}
     * @memberof InlineResponse20032
     */
    data?: Array<InlineResponse20032Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20032
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20032
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20032
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20032Data
 */
export interface InlineResponse20032Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20032Data
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20032Data
     */
    product_id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20032Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20032Data
     */
    description: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * 
     * @type {Array<InlineResponse20033Data>}
     * @memberof InlineResponse20033
     */
    data?: Array<InlineResponse20033Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20033
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20033
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20033
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20033Data
 */
export interface InlineResponse20033Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20033Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033Data
     */
    type: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20033Data
     */
    product_id: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * 
     * @type {Array<InlineResponse20034Data>}
     * @memberof InlineResponse20034
     */
    data?: Array<InlineResponse20034Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20034
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20034
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20034
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20034Data
 */
export interface InlineResponse20034Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20034Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034Data
     */
    description: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034Data
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20034Data
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20034Data
     */
    production_cost: number;
    /**
     * 
     * @type {InlineResponse20032Data}
     * @memberof InlineResponse20034Data
     */
    colour?: InlineResponse20032Data;
    /**
     * 
     * @type {InlineResponse20033Data}
     * @memberof InlineResponse20034Data
     */
    covering?: InlineResponse20033Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * 
     * @type {InlineResponse20034Data}
     * @memberof InlineResponse20035
     */
    data: InlineResponse20034Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * 
     * @type {Array<InlineResponse20036Data>}
     * @memberof InlineResponse20036
     */
    data?: Array<InlineResponse20036Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20036
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20036
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20036
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20036Data
 */
export interface InlineResponse20036Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20036Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20036Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20036Data
     */
    slug: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * 
     * @type {InlineResponse20036Data}
     * @memberof InlineResponse20037
     */
    data: InlineResponse20036Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * 
     * @type {Array<InlineResponse20038Data>}
     * @memberof InlineResponse20038
     */
    data?: Array<InlineResponse20038Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20038
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20038
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20038
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20038Data
 */
export interface InlineResponse20038Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20038Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20038Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20038Data
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20038Data
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20038Data
     */
    parent_id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20038Data
     */
    level: number | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20038Data
     */
    type: `${InlineResponse20038DataTypeEnum}`;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20038Data
     */
    images?: Array<InlineResponse2007Logo>;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20038DataTypeEnum {
    Collection = 'COLLECTION',
    SubCollection = 'SUB_COLLECTION',
    BrandType = 'BRAND_TYPE',
    Brand = 'BRAND',
    Category = 'CATEGORY'
}

/**
 * 
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * 
     * @type {InlineResponse20038Data}
     * @memberof InlineResponse20039
     */
    data: InlineResponse20038Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2003Data
 */
export interface InlineResponse2003Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Data
     */
    initial: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Data
     */
    as: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Data
     */
    reportable_type: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Data
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Data
     */
    email_verified_at: string;
    /**
     * User type determine the feature should be made avaiable to them. The available enum options are hard coded.
     * @type {string}
     * @memberof InlineResponse2003Data
     */
    type: `${InlineResponse2003DataTypeEnum}`;
    /**
     * 
     * @type {InlineResponse2003DataCompany}
     * @memberof InlineResponse2003Data
     */
    company?: InlineResponse2003DataCompany;
    /**
     * The company that this user belongs to
     * @type {number}
     * @memberof InlineResponse2003Data
     */
    company_id: number | null;
    /**
     * The default channel currently selected for this user
     * @type {number}
     * @memberof InlineResponse2003Data
     */
    channel_id: number | null;
    /**
     * The user id of this user\'s supervisor
     * @type {number}
     * @memberof InlineResponse2003Data
     */
    supervisor_id: number | null;
    /**
     * If this user is a supervisor, this return the supervisor type id
     * @type {number}
     * @memberof InlineResponse2003Data
     */
    supervisor_type_id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003Data
     */
    discount_approval_limit_percentage: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003Data
     */
    app_show_hpp: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003Data
     */
    app_approve_discount: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2003Data
     */
    app_create_lead: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2003DataTypeEnum {
    Default = 'DEFAULT',
    Sales = 'SALES',
    Supervisor = 'SUPERVISOR',
    Director = 'DIRECTOR',
    DigitalMarketing = 'DigitalMarketing',
    SalesSms = 'SALES_SMS',
    SupervisorSms = 'SUPERVISOR_SMS'
}

/**
 * 
 * @export
 * @interface InlineResponse2003DataCompany
 */
export interface InlineResponse2003DataCompany {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003DataCompany
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003DataCompany
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<InlineResponse2004Data>}
     * @memberof InlineResponse2004
     */
    data?: Array<InlineResponse2004Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse2004
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2004
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse2004
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * 
     * @type {Array<InlineResponse20040Data>}
     * @memberof InlineResponse20040
     */
    data?: Array<InlineResponse20040Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20040
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20040
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20040
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20040Data
 */
export interface InlineResponse20040Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20040Data
     */
    id: number;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20040Data
     */
    sender?: InlineResponse20014User;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040Data
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040Data
     */
    created_at: string | null;
    /**
     * 
     * @type {InlineResponse20040Topic}
     * @memberof InlineResponse20040Data
     */
    topic?: InlineResponse20040Topic;
}
/**
 * 
 * @export
 * @interface InlineResponse20040Topic
 */
export interface InlineResponse20040Topic {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20040Topic
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040Topic
     */
    subject: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040Topic
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040Topic
     */
    created_at: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * 
     * @type {Array<InlineResponse20041Data>}
     * @memberof InlineResponse20041
     */
    data?: Array<InlineResponse20041Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20041
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20041
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20041
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20041Data
 */
export interface InlineResponse20041Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20041Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041Data
     */
    subject: string;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20041Data
     */
    creator?: InlineResponse20014User;
    /**
     * 
     * @type {InlineResponse20041LatestMessage}
     * @memberof InlineResponse20041Data
     */
    latest_message?: InlineResponse20041LatestMessage | null;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20041Data
     */
    images?: Array<InlineResponse2007Logo>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041Data
     */
    created_at: string | null;
}
/**
 * The latest message sent to this topic.
 * @export
 * @interface InlineResponse20041LatestMessage
 */
export interface InlineResponse20041LatestMessage {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20041LatestMessage
     */
    id: number;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20041LatestMessage
     */
    sender?: InlineResponse20014User;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041LatestMessage
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041LatestMessage
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041LatestMessage
     */
    created_at: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * 
     * @type {InlineResponse20042Data}
     * @memberof InlineResponse20042
     */
    data: InlineResponse20042Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20042Data
 */
export interface InlineResponse20042Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20042Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042Data
     */
    subject: string;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20042Data
     */
    creator?: InlineResponse20014User;
    /**
     * 
     * @type {Array<InlineResponse20014User>}
     * @memberof InlineResponse20042Data
     */
    users?: Array<InlineResponse20014User>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042Data
     */
    created_at: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * 
     * @type {InlineResponse20043Data}
     * @memberof InlineResponse20043
     */
    data: InlineResponse20043Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20043Data
 */
export interface InlineResponse20043Data {
    /**
     * 
     * @type {Array<InlineResponse20043DataItems>}
     * @memberof InlineResponse20043Data
     */
    items?: Array<InlineResponse20043DataItems>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20043Data
     */
    total_price: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20043DataItems
 */
export interface InlineResponse20043DataItems {
    covering: InlineResponse20033Data;
    colour: InlineResponse20032Data;
    sku: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20043DataItems
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20043DataItems
     */
    quantity: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20043DataItems
     */
    name: string;
    /**
     * Price per item quantity
     * @type {number}
     * @memberof InlineResponse20043DataItems
     */
    unit_price: number;
    /**
     * Total discount for this item line
     * @type {number}
     * @memberof InlineResponse20043DataItems
     */
    total_discount: number;
    /**
     * Total price for this item line including discount
     * @type {number}
     * @memberof InlineResponse20043DataItems
     */
    total_price: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * 
     * @type {InlineResponse20044Data}
     * @memberof InlineResponse20044
     */
    data: InlineResponse20044Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20044Data
 */
export interface InlineResponse20044Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20044Data
     */
    id: number | null;
    /**
     * 
     * @type {Array<InlineResponse20044DataItems>}
     * @memberof InlineResponse20044Data
     */
    items?: Array<InlineResponse20044DataItems>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20044Data
     */
    total_price: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20044DataItems
 */
export interface InlineResponse20044DataItems {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20044DataItems
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20044DataItems
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20044DataItems
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20044DataItems
     */
    quantity: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20044DataItems
     */
    image: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * 
     * @type {Array<InlineResponse20045Data>}
     * @memberof InlineResponse20045
     */
    data?: Array<InlineResponse20045Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20045
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20045
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20045
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20045Data
 */
export interface InlineResponse20045Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20045Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045Data
     */
    activation_code: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045Data
     */
    description: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045Data
     */
    type: `${InlineResponse20045DataTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045Data
     */
    scope: `${InlineResponse20045DataScopeEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20045Data
     */
    value: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20045Data
     */
    max_discount_price_per_order: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20045Data
     */
    max_use_per_customer: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20045Data
     */
    min_order_price: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20045DataTypeEnum {
    Nominal = 'NOMINAL',
    Percentage = 'PERCENTAGE'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20045DataScopeEnum {
    Quantity = 'QUANTITY',
    Type = 'TYPE',
    Transaction = 'TRANSACTION',
    Category = 'CATEGORY'
}

/**
 * 
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * 
     * @type {InlineResponse20045Data}
     * @memberof InlineResponse20046
     */
    data: InlineResponse20045Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * 
     * @type {InlineResponse20047Data}
     * @memberof InlineResponse20047
     */
    data: InlineResponse20047Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20047Data
 */
export interface InlineResponse20047Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    original_price: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    total_discount: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
     total_voucher: number;
     /**
      * 
      * @type {number}
      * @memberof InlineResponse20047Data
      */
    total_price: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    shipping_fee: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    packing_fee: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    additional_discount: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    additional_discount_ratio: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    amount_paid: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    invoice_number: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    status: `${InlineResponse20047DataStatusEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    payment_status: `${InlineResponse20047DataPaymentStatusEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    payment_status_for_invoice: `${InlineResponse20047DataPaymentStatusForInvoiceEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    approval_status: `${InlineResponse20047DataApprovalStatusEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    discount_error: `${InlineResponse20047DataDiscountErrorEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    lead_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    user_id: number;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20047Data
     */
    approved_by?: InlineResponse20014User;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    channel_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    company_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    interior_design_id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    discount_id: number | null;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20047Data
     */
    user?: InlineResponse20014User;
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse20047Data
     */
    channel?: InlineResponse2009Data;
    /**
     * 
     * @type {InlineResponse20014Customer}
     * @memberof InlineResponse20047Data
     */
    customer?: InlineResponse20014Customer;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse20047Data
     */
    discount_take_over_by: object;
    /**
     * 
     * @type {Array<InlineResponse20015OrderOrderDetails>}
     * @memberof InlineResponse20047Data
     */
    order_details?: Array<InlineResponse20015OrderOrderDetails>;
    /**
     * 
     * @type {InlineResponse20044Data}
     * @memberof InlineResponse20047Data
     */
    cart_demand?: InlineResponse20044Data;
    /**
     * 
     * @type {InlineResponse20047DataBillingAddress}
     * @memberof InlineResponse20047Data
     */
    billing_address?: InlineResponse20047DataBillingAddress;
    /**
     * 
     * @type {InlineResponse20047DataBillingAddress}
     * @memberof InlineResponse20047Data
     */
    shipping_address?: InlineResponse20047DataBillingAddress;
    /**
     * 
     * @type {InlineResponse20047DataDiscount}
     * @memberof InlineResponse20047Data
     */
    discount?: InlineResponse20047DataDiscount;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    expected_shipping_datetime: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    quotation_valid_until_datetime: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    note: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    approval_note: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047Data
     */
    discount_approval_limit_percentage: number | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047Data
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20047DataStatusEnum {
    Quotation = 'QUOTATION',
    Shipment = 'SHIPMENT',
    Cancelled = 'CANCELLED',
    Returned = 'RETURNED'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20047DataPaymentStatusEnum {
    None = 'NONE',
    Partial = 'PARTIAL',
    Settlement = 'SETTLEMENT',
    Overpayment = 'OVERPAYMENT',
    Refunded = 'REFUNDED',
    DownPayment = 'DOWN_PAYMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20047DataPaymentStatusForInvoiceEnum {
    None = 'NONE',
    Partial = 'PARTIAL',
    Settlement = 'SETTLEMENT',
    Overpayment = 'OVERPAYMENT',
    Refunded = 'REFUNDED',
    DownPayment = 'DOWN_PAYMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20047DataApprovalStatusEnum {
    NotRequired = 'NOT_REQUIRED',
    WaitingApproval = 'WAITING_APPROVAL',
    Approved = 'APPROVED',
    Rejected = 'REJECTED'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20047DataDiscountErrorEnum {
    Inactive = 'INACTIVE',
    UseLimitReached = 'USE_LIMIT_REACHED',
    UnderMinimumPrice = 'UNDER_MINIMUM_PRICE',
    NotApplicableToAnyProduct = 'NOT_APPLICABLE_TO_ANY_PRODUCT'
}

/**
 * 
 * @export
 * @interface InlineResponse20047DataBillingAddress
 */
export interface InlineResponse20047DataBillingAddress {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataBillingAddress
     */
    address_line_1: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataBillingAddress
     */
    address_line_2: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataBillingAddress
     */
    address_line_3: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataBillingAddress
     */
    postcode: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataBillingAddress
     */
    city: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataBillingAddress
     */
    country: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataBillingAddress
     */
    province: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataBillingAddress
     */
    phone: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataBillingAddress
     */
    type: `${InlineResponse20047DataBillingAddressTypeEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047DataBillingAddress
     */
    customer_id: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20047DataBillingAddressTypeEnum {
    Address = 'ADDRESS',
    Delivery = 'DELIVERY',
    Billing = 'BILLING'
}

/**
 * 
 * @export
 * @interface InlineResponse20047DataDiscount
 */
export interface InlineResponse20047DataDiscount {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataDiscount
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataDiscount
     */
    activation_code: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataDiscount
     */
    description: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataDiscount
     */
    type: `${InlineResponse20047DataDiscountTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047DataDiscount
     */
    scope: `${InlineResponse20047DataDiscountScopeEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047DataDiscount
     */
    value: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047DataDiscount
     */
    max_discount_price_per_order: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047DataDiscount
     */
    max_use_per_customer: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047DataDiscount
     */
    min_order_price: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20047DataDiscountTypeEnum {
    Nominal = 'NOMINAL',
    Percentage = 'PERCENTAGE'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20047DataDiscountScopeEnum {
    Quantity = 'QUANTITY',
    Type = 'TYPE',
    Transaction = 'TRANSACTION',
    Category = 'CATEGORY'
}

/**
 * 
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     * 
     * @type {Array<InlineResponse20047Data>}
     * @memberof InlineResponse20048
     */
    data?: Array<InlineResponse20047Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20048
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20048
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20048
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * 
     * @type {InlineResponse20015OrderOrderDetails}
     * @memberof InlineResponse20049
     */
    data: InlineResponse20015OrderOrderDetails;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Data
 */
export interface InlineResponse2004Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Data
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004Data
     */
    level: number | null;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Array<InlineResponse2003Data>}
     * @memberof InlineResponse2005
     */
    data?: Array<InlineResponse2003Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse2005
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2005
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse2005
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * 
     * @type {Array<InlineResponse20050Data>}
     * @memberof InlineResponse20050
     */
    data?: Array<InlineResponse20050Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20050
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20050
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20050
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20050Data
 */
export interface InlineResponse20050Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20050Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20050Data
     */
    name: string;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20050Data
     */
    images?: Array<InlineResponse2007Logo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * 
     * @type {Array<InlineResponse20051Data>}
     * @memberof InlineResponse20051
     */
    data?: Array<InlineResponse20051Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20051
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20051
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20051
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20051Data
 */
export interface InlineResponse20051Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20051Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20051Data
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20051Data
     */
    payment_category_id: number;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20051Data
     */
    images?: Array<InlineResponse2007Logo>;
}
/**
 * 
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * 
     * @type {Array<InlineResponse20052Data>}
     * @memberof InlineResponse20052
     */
    data?: Array<InlineResponse20052Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20052
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20052
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20052
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20052Data
 */
export interface InlineResponse20052Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20052Data
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20052Data
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052Data
     */
    reference: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052Data
     */
    status: `${InlineResponse20052DataStatusEnum}`;
    /**
     * 
     * @type {InlineResponse20052PaymentType}
     * @memberof InlineResponse20052Data
     */
    payment_type?: InlineResponse20052PaymentType;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20052Data
     */
    added_by?: InlineResponse20014User;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20052Data
     */
    order_id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20052Data
     */
    company_id: number;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20052Data
     */
    proof?: Array<InlineResponse2007Logo>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052Data
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20052DataStatusEnum {
    Pending = 'PENDING',
    Approved = 'APPROVED',
    Rejected = 'REJECTED'
}

/**
 * 
 * @export
 * @interface InlineResponse20052PaymentType
 */
export interface InlineResponse20052PaymentType {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20052PaymentType
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052PaymentType
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20052PaymentType
     */
    payment_category_id: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20053
 */
export interface InlineResponse20053 {
    /**
     * 
     * @type {Array<InlineResponse20053Data>}
     * @memberof InlineResponse20053
     */
    data?: Array<InlineResponse20053Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20053
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20053
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20053
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20053Data
 */
export interface InlineResponse20053Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053Data
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053Data
     */
    stock: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053Data
     */
    indent: number;
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse20053Data
     */
    channel?: InlineResponse2009Data;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053Data
     */
    product_unit_id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053Data
     */
    created_at: string | null;
    /**
     * 
     * @type {InlineResponse20053ProductUnit}
     * @memberof InlineResponse20053Data
     */
    product_unit?: InlineResponse20053ProductUnit;
    /**
     * 
     * @type {InlineResponse20015Brands}
     * @memberof InlineResponse20053Data
     */
    product_brand?: InlineResponse20015Brands;
    /**
     * 
     * @type {InlineResponse20032Data}
     * @memberof InlineResponse20053Data
     */
    colour?: InlineResponse20032Data;
    /**
     * 
     * @type {InlineResponse20033Data}
     * @memberof InlineResponse20053Data
     */
    covering?: InlineResponse20033Data;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053Data
     */
    outstanding_order: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053Data
     */
    outstanding_shipment: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053Data
     */
    real_stock: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20053ProductUnit
 */
export interface InlineResponse20053ProductUnit {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053ProductUnit
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053ProductUnit
     */
    description: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053ProductUnit
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053ProductUnit
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053ProductUnit
     */
    production_cost: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20054
 */
export interface InlineResponse20054 {
    /**
     * 
     * @type {Array<InlineResponse20054Data>}
     * @memberof InlineResponse20054
     */
    data?: Array<InlineResponse20054Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20054
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20054
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20054
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20054Data
 */
export interface InlineResponse20054Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20054Data
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20054Data
     */
    stock: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20054Data
     */
    indent: number;
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse20054Data
     */
    channel?: InlineResponse2009Data;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20054Data
     */
    product_unit_id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20054Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20054Data
     */
    created_at: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20055
 */
export interface InlineResponse20055 {
    /**
     * 
     * @type {InlineResponse20054Data}
     * @memberof InlineResponse20055
     */
    data: InlineResponse20054Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20056
 */
export interface InlineResponse20056 {
    /**
     * 
     * @type {Array<InlineResponse20056Data>}
     * @memberof InlineResponse20056
     */
    data?: Array<InlineResponse20056Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20056
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20056
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20056
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20056Data
 */
export interface InlineResponse20056Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20056Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056Data
     */
    start_date: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056Data
     */
    end_date: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056Data
     */
    reportable_label: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056Data
     */
    reportable_type: `${InlineResponse20056DataReportableTypeEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20056Data
     */
    reportable_id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056Data
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20056DataReportableTypeEnum {
    Company = 'COMPANY',
    Channel = 'CHANNEL',
    User = 'USER'
}

/**
 * 
 * @export
 * @interface InlineResponse20057
 */
export interface InlineResponse20057 {
    /**
     * 
     * @type {InlineResponse20056Data}
     * @memberof InlineResponse20057
     */
    data: InlineResponse20056Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20058
 */
export interface InlineResponse20058 {
    /**
     * 
     * @type {Array<InlineResponse20058Data>}
     * @memberof InlineResponse20058
     */
    data?: Array<InlineResponse20058Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20058
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20058
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20058
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20058Breakdown
 */
export interface InlineResponse20058Breakdown {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058Breakdown
     */
    enum_type?: `${InlineResponse20058BreakdownEnumTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058Breakdown
     */
    enum_value?: `${InlineResponse20058BreakdownEnumValueEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058Breakdown
     */
    value?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20058BreakdownEnumTypeEnum {
    ActivityStatus = 'ACTIVITY_STATUS'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20058BreakdownEnumValueEnum {
    Hot = 'HOT',
    Warm = 'WARM',
    Cold = 'COLD',
    Drop = 'DROP'
}

/**
 * 
 * @export
 * @interface InlineResponse20058Data
 */
export interface InlineResponse20058Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058Data
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058Data
     */
    report_id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058Data
     */
    type: `${InlineResponse20058DataTypeEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058Data
     */
    chart_type: `${InlineResponse20058DataChartTypeEnum}`;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058Data
     */
    target: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058Data
     */
    value: number;
    /**
     * 
     * @type {InlineResponse2003DataCompany}
     * @memberof InlineResponse20058Data
     */
    company?: InlineResponse2003DataCompany;
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse20058Data
     */
    channel?: InlineResponse2009Data;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse20058Data
     */
    user?: InlineResponse20014User;
    /**
     * 
     * @type {InlineResponse20056Data}
     * @memberof InlineResponse20058Data
     */
    report?: InlineResponse20056Data;
    /**
     * 
     * @type {Array<InlineResponse20058TargetLines>}
     * @memberof InlineResponse20058Data
     */
    target_lines?: Array<InlineResponse20058TargetLines>;
    /**
     * 
     * @type {Array<InlineResponse20058Breakdown>}
     * @memberof InlineResponse20058Data
     */
    breakdown: Array<InlineResponse20058Breakdown>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058Data
     */
    created_at: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20058DataTypeEnum {
    DealsInvoicePrice = 'DEALS_INVOICE_PRICE',
    DealsPaymentPrice = 'DEALS_PAYMENT_PRICE',
    DealsBrandPrice = 'DEALS_BRAND_PRICE',
    DealsModelPrice = 'DEALS_MODEL_PRICE',
    DealsOrderCount = 'DEALS_ORDER_COUNT',
    DealsBrandCount = 'DEALS_BRAND_COUNT',
    DealsModelCount = 'DEALS_MODEL_COUNT',
    ActivityCount = 'ACTIVITY_COUNT',
    ActivityCountClosed = 'ACTIVITY_COUNT_CLOSED',
    OrderSettlementCount = 'ORDER_SETTLEMENT_COUNT'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineResponse20058DataChartTypeEnum {
    Single = 'SINGLE',
    Multiple = 'MULTIPLE'
}

/**
 * 
 * @export
 * @interface InlineResponse20058TargetLines
 */
export interface InlineResponse20058TargetLines {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058TargetLines
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058TargetLines
     */
    target_id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058TargetLines
     */
    label: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058TargetLines
     */
    target: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058TargetLines
     */
    value: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058TargetLines
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058TargetLines
     */
    created_at: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse20059
 */
export interface InlineResponse20059 {
    /**
     * 
     * @type {Array<InlineResponse20059Data>}
     * @memberof InlineResponse20059
     */
    data?: Array<InlineResponse20059Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20059
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20059
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20059
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20059Data
 */
export interface InlineResponse20059Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20059Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059Data
     */
    description: string | null;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20059Data
     */
    images?: Array<InlineResponse2007Logo>;
    /**
     * 
     * @type {InlineResponse2003DataCompany}
     * @memberof InlineResponse20059Data
     */
    company?: InlineResponse2003DataCompany;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Array<InlineResponse2006Data>}
     * @memberof InlineResponse2006
     */
    data?: Array<InlineResponse2006Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse2006
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2006
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse2006
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20060
 */
export interface InlineResponse20060 {
    /**
     * 
     * @type {InlineResponse20059Data}
     * @memberof InlineResponse20060
     */
    data: InlineResponse20059Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20061
 */
export interface InlineResponse20061 {
    /**
     * 
     * @type {Array<InlineResponse20061Data>}
     * @memberof InlineResponse20061
     */
    data?: Array<InlineResponse20061Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse20061
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse20061
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse20061
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse20061Data
 */
export interface InlineResponse20061Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20061Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061Data
     */
    description: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061Data
     */
    start_time: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061Data
     */
    end_time: string | null;
    /**
     * 
     * @type {Array<InlineResponse2007Logo>}
     * @memberof InlineResponse20061Data
     */
    images?: Array<InlineResponse2007Logo>;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20061Data
     */
    promo_category_id: number | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20061Data
     */
    lead_category_id: number | null;
    /**
     * 
     * @type {InlineResponse2003DataCompany}
     * @memberof InlineResponse20061Data
     */
    company?: InlineResponse2003DataCompany;
}
/**
 * 
 * @export
 * @interface InlineResponse20062
 */
export interface InlineResponse20062 {
    /**
     * 
     * @type {InlineResponse20061Data}
     * @memberof InlineResponse20062
     */
    data: InlineResponse20061Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20063
 */
export interface InlineResponse20063 {
    /**
     * 
     * @type {InlineResponse20063Data}
     * @memberof InlineResponse20063
     */
    data: InlineResponse20063Data;
}
/**
 * 
 * @export
 * @interface InlineResponse20063Data
 */
export interface InlineResponse20063Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063Data
     */
    token: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Data
 */
export interface InlineResponse2006Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Data
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Data
     */
    bank_name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Data
     */
    account_name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Data
     */
    account_number: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {Array<InlineResponse2007Data>}
     * @memberof InlineResponse2007
     */
    data?: Array<InlineResponse2007Data>;
    /**
     * 
     * @type {Links}
     * @memberof InlineResponse2007
     */
    links?: Links;
    /**
     * 
     * @type {Meta}
     * @memberof InlineResponse2007
     */
    meta?: Meta;
    /**
     * 
     * @type {Query}
     * @memberof InlineResponse2007
     */
    query?: Query;
}
/**
 * 
 * @export
 * @interface InlineResponse2007Data
 */
export interface InlineResponse2007Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Data
     */
    name: string;
    /**
     * 
     * @type {InlineResponse2007Logo}
     * @memberof InlineResponse2007Data
     */
    logo?: InlineResponse2007Logo;
    /**
     * 
     * @type {InlineResponse2006Data}
     * @memberof InlineResponse2007Data
     */
    company_account?: InlineResponse2006Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2007Logo
 */
export interface InlineResponse2007Logo {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007Logo
     */
    id: number | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Logo
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Logo
     */
    mime_type: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Logo
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Logo
     */
    thumbnail: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Logo
     */
    preview: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {InlineResponse2007Data}
     * @memberof InlineResponse2008
     */
    data: InlineResponse2007Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse2009
     */
    data: InlineResponse2009Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2009Data
 */
export interface InlineResponse2009Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2009Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009Data
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2009Data
     */
    company_id: number;
}
/**
 * 
 * @export
 * @interface InlineResponse200Data
 */
export interface InlineResponse200Data {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Data
     */
    message: string;
}
/**
 * 
 * @export
 * @interface InlineResponse201
 */
export interface InlineResponse201 {
    /**
     * 
     * @type {InlineResponse201Data}
     * @memberof InlineResponse201
     */
    data: InlineResponse201Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2011
 */
export interface InlineResponse2011 {
    /**
     * 
     * @type {InlineResponse20017Data}
     * @memberof InlineResponse2011
     */
    data: InlineResponse20017Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2012
 */
export interface InlineResponse2012 {
    /**
     * 
     * @type {InlineResponse20015Data}
     * @memberof InlineResponse2012
     */
    data: InlineResponse20015Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2013
 */
export interface InlineResponse2013 {
    /**
     * 
     * @type {InlineResponse20015LatestComment}
     * @memberof InlineResponse2013
     */
    data: InlineResponse20015LatestComment;
}
/**
 * 
 * @export
 * @interface InlineResponse2014
 */
export interface InlineResponse2014 {
    /**
     * 
     * @type {InlineResponse2014Data}
     * @memberof InlineResponse2014
     */
    data: InlineResponse2014Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2014Data
 */
export interface InlineResponse2014Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2014Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2014Data
     */
    follow_up_datetime: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2014Data
     */
    feedback: string;
    /**
     * 
     * @type {InlineResponse2009Data}
     * @memberof InlineResponse2014Data
     */
    channel?: InlineResponse2009Data;
    /**
     * 
     * @type {Array<InlineResponse20015Brands>}
     * @memberof InlineResponse2014Data
     */
    brands?: Array<InlineResponse20015Brands>;
    /**
     * 
     * @type {InlineResponse20015Order}
     * @memberof InlineResponse2014Data
     */
    order?: InlineResponse20015Order;
    /**
     * 
     * @type {InlineResponse20015Lead}
     * @memberof InlineResponse2014Data
     */
    lead?: InlineResponse20015Lead;
    /**
     * 
     * @type {InlineResponse20014User}
     * @memberof InlineResponse2014Data
     */
    user?: InlineResponse20014User;
    /**
     * 
     * @type {InlineResponse20014Customer}
     * @memberof InlineResponse2014Data
     */
    customer?: InlineResponse20014Customer;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2014Data
     */
    estimated_value: number | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2014Data
     */
    reminder_datetime: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2014Data
     */
    reminder_note: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2014Data
     */
    updated_at: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2014Data
     */
    created_at: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse2015
 */
export interface InlineResponse2015 {
    /**
     * 
     * @type {InlineResponse20041Data}
     * @memberof InlineResponse2015
     */
    data: InlineResponse20041Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2016
 */
export interface InlineResponse2016 {
    /**
     * 
     * @type {InlineResponse20040Data}
     * @memberof InlineResponse2016
     */
    data: InlineResponse20040Data;
}
/**
 * 
 * @export
 * @interface InlineResponse2017
 */
export interface InlineResponse2017 {
    /**
     * 
     * @type {InlineResponse20052Data}
     * @memberof InlineResponse2017
     */
    data: InlineResponse20052Data;
}
/**
 * 
 * @export
 * @interface InlineResponse201Data
 */
export interface InlineResponse201Data {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse201Data
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse201Data
     */
    title: `${InlineResponse201DataTitleEnum}`;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse201Data
     */
    first_name: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse201Data
     */
    last_name: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse201Data
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse201Data
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse201Data
     */
    date_of_birth: string | null;
    /**
     * Possible place for a custom note from the user about the customer
     * @type {string}
     * @memberof InlineResponse201Data
     */
    description: string | null;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse201Data
     */
    default_address_id: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse201Data
     */
    has_activity: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse201DataTitleEnum {
    Mr = 'MR',
    Ms = 'MS',
    Mrs = 'MRS'
}

/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    code: string;
}
/**
 * 
 * @export
 * @interface InlineResponse403
 */
export interface InlineResponse403 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse403
     */
    code: string;
}
/**
 * 
 * @export
 * @interface InlineResponse4031
 */
export interface InlineResponse4031 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4031
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4031
     */
    code: string;
}
/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse404
     */
    message: string;
}
/**
 * 
 * @export
 * @interface InlineResponse422
 */
export interface InlineResponse422 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse422
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse422
     */
    code: string;
}
/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    first?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    last?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    prev?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    next?: string | null;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    mimeType?: string;
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    url: string;
}
/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    current_page?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    from?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Meta
     */
    path?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    per_page?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Meta
     */
    to?: number | null;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    code: string;
}
/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * 
     * @type {Array<QueryFilters>}
     * @memberof Query
     */
    filters?: Array<QueryFilters>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Query
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface QueryFilters
 */
export interface QueryFilters {
    /**
     * 
     * @type {string}
     * @memberof QueryFilters
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryFilters
     */
    dataFormat?: `${QueryFiltersDataFormatEnum}`;
    /**
     * Option will be provided when filter is based on enum options
     * @type {Array<QueryOptions>}
     * @memberof QueryFilters
     */
    options?: Array<QueryOptions> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum QueryFiltersDataFormatEnum {
    Default = 'default',
    Numeric = 'numeric',
    Boolean = 'boolean',
    Date = 'date',
    Csv = 'csv',
    Enum = 'enum'
}

/**
 * 
 * @export
 * @interface QueryOptions
 */
export interface QueryOptions {
    /**
     * 
     * @type {string}
     * @memberof QueryOptions
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof QueryOptions
     */
    label?: string;
}

/**
 * ActivityApi - axios parameter creator
 * @export
 */
export const ActivityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a activity by its id
         * @summary Delete Activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityDestroy: async (activity: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityDestroy', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sales will get all activities directly created by him. Supervisor will get all activities created by its supervised sales. Director will get all activities scoped to its active channel setting.
         * @summary Show all activity posted by user
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityIndex: async (filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterOrderId !== undefined) {
                localVarQueryParameter['filter[order_id]'] = filterOrderId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterCustomerId !== undefined) {
                localVarQueryParameter['filter[customer_id]'] = filterCustomerId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterFollowUpMethod !== undefined) {
                localVarQueryParameter['filter[follow_up_method]'] = filterFollowUpMethod;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterFeedback !== undefined) {
                localVarQueryParameter['filter[feedback]'] = filterFeedback;
            }

            if (filterTargetId !== undefined) {
                localVarQueryParameter['filter[target_id]'] = filterTargetId;
            }

            if (filterFollowUpDatetimeBefore !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_before]'] = filterFollowUpDatetimeBefore;
            }

            if (filterFollowUpDatetimeAfter !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_after]'] = filterFollowUpDatetimeAfter;
            }

            if (filterHasPayment !== undefined) {
                localVarQueryParameter['filter[has_payment]'] = filterHasPayment;
            }

            if (filterHasAnyBrands !== undefined) {
                localVarQueryParameter['filter[has_any_brands]'] = filterHasAnyBrands;
            }

            if (filterCreatedBefore !== undefined) {
                localVarQueryParameter['filter[created_before]'] = filterCreatedBefore;
            }

            if (filterCreatedAfter !== undefined) {
                localVarQueryParameter['filter[created_after]'] = filterCreatedAfter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns activity by id
         * @summary Get activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityShow: async (activity: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityShow', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new activity
         * @summary Create new Activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject12} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityStore: async (accept?: string, contentType?: string, data?: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given activity
         * @summary Update a activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject13} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityUpdate: async (activity: string, accept?: string, contentType?: string, data?: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityUpdate', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all activities of a given customer
         * @summary Show all activities of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetActivities: async (customer: number, filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerGetActivities', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}/activities`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterOrderId !== undefined) {
                localVarQueryParameter['filter[order_id]'] = filterOrderId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterCustomerId !== undefined) {
                localVarQueryParameter['filter[customer_id]'] = filterCustomerId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterFollowUpMethod !== undefined) {
                localVarQueryParameter['filter[follow_up_method]'] = filterFollowUpMethod;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterFeedback !== undefined) {
                localVarQueryParameter['filter[feedback]'] = filterFeedback;
            }

            if (filterTargetId !== undefined) {
                localVarQueryParameter['filter[target_id]'] = filterTargetId;
            }

            if (filterFollowUpDatetimeBefore !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_before]'] = filterFollowUpDatetimeBefore;
            }

            if (filterFollowUpDatetimeAfter !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_after]'] = filterFollowUpDatetimeAfter;
            }

            if (filterHasPayment !== undefined) {
                localVarQueryParameter['filter[has_payment]'] = filterHasPayment;
            }

            if (filterHasAnyBrands !== undefined) {
                localVarQueryParameter['filter[has_any_brands]'] = filterHasAnyBrands;
            }

            if (filterCreatedBefore !== undefined) {
                localVarQueryParameter['filter[created_before]'] = filterCreatedBefore;
            }

            if (filterCreatedAfter !== undefined) {
                localVarQueryParameter['filter[created_after]'] = filterCreatedAfter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityApi - functional programming interface
 * @export
 */
export const ActivityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a activity by its id
         * @summary Delete Activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityDestroy(activity: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityDestroy(activity, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sales will get all activities directly created by him. Supervisor will get all activities created by its supervised sales. Director will get all activities scoped to its active channel setting.
         * @summary Show all activity posted by user
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityIndex(filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityIndex(filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns activity by id
         * @summary Get activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityShow(activity: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityShow(activity, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new activity
         * @summary Create new Activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject12} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityStore(accept?: string, contentType?: string, data?: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given activity
         * @summary Update a activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject13} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityUpdate(activity: string, accept?: string, contentType?: string, data?: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityUpdate(activity, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all activities of a given customer
         * @summary Show all activities of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGetActivities(customer: number, filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGetActivities(customer, filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityApi - factory interface
 * @export
 */
export const ActivityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityApiFp(configuration)
    return {
        /**
         * Delete a activity by its id
         * @summary Delete Activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityDestroy(activity: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.activityDestroy(activity, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Sales will get all activities directly created by him. Supervisor will get all activities created by its supervised sales. Director will get all activities scoped to its active channel setting.
         * @summary Show all activity posted by user
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityIndex(filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.activityIndex(filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns activity by id
         * @summary Get activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityShow(activity: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.activityShow(activity, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new activity
         * @summary Create new Activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject12} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityStore(accept?: string, contentType?: string, data?: InlineObject12, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.activityStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given activity
         * @summary Update a activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject13} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityUpdate(activity: string, accept?: string, contentType?: string, data?: InlineObject13, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.activityUpdate(activity, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all activities of a given customer
         * @summary Show all activities of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetActivities(customer: number, filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.customerGetActivities(customer, filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activityDestroy operation in ActivityApi.
 * @export
 * @interface ActivityApiActivityDestroyRequest
 */
export interface ActivityApiActivityDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityDestroy
     */
    readonly activity: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityApiActivityDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityApiActivityDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityIndex operation in ActivityApi.
 * @export
 * @interface ActivityApiActivityIndexRequest
 */
export interface ActivityApiActivityIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterOrderId?: number

    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterUserId?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterCustomerId?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterChannelId?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'

    /**
     * 
     * @type {'HOT' | 'WARM' | 'COLD' | 'DROP'}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP'

    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterFeedback?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterTargetId?: number

    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterFollowUpDatetimeBefore?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterFollowUpDatetimeAfter?: string

    /**
     * 
     * @type {boolean}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterHasPayment?: boolean

    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterHasAnyBrands?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterCreatedBefore?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly filterCreatedAfter?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityApiActivityIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ActivityApiActivityIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityApiActivityIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityShow operation in ActivityApi.
 * @export
 * @interface ActivityApiActivityShowRequest
 */
export interface ActivityApiActivityShowRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityShow
     */
    readonly activity: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityApiActivityShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityApiActivityShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityStore operation in ActivityApi.
 * @export
 * @interface ActivityApiActivityStoreRequest
 */
export interface ActivityApiActivityStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityApiActivityStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityApiActivityStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject12}
     * @memberof ActivityApiActivityStore
     */
    readonly data?: InlineObject12
}

/**
 * Request parameters for activityUpdate operation in ActivityApi.
 * @export
 * @interface ActivityApiActivityUpdateRequest
 */
export interface ActivityApiActivityUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityApiActivityUpdate
     */
    readonly activity: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityApiActivityUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityApiActivityUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject13}
     * @memberof ActivityApiActivityUpdate
     */
    readonly data?: InlineObject13
}

/**
 * Request parameters for customerGetActivities operation in ActivityApi.
 * @export
 * @interface ActivityApiCustomerGetActivitiesRequest
 */
export interface ActivityApiCustomerGetActivitiesRequest {
    /**
     * 
     * @type {number}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly customer: number

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterOrderId?: number

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterUserId?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterCustomerId?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterChannelId?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'

    /**
     * 
     * @type {'HOT' | 'WARM' | 'COLD' | 'DROP'}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP'

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterFeedback?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterTargetId?: number

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterFollowUpDatetimeBefore?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterFollowUpDatetimeAfter?: string

    /**
     * 
     * @type {boolean}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterHasPayment?: boolean

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterHasAnyBrands?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterCreatedBefore?: string

    /**
     * 
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly filterCreatedAfter?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityApiCustomerGetActivities
     */
    readonly contentType?: string
}

/**
 * ActivityApi - object-oriented interface
 * @export
 * @class ActivityApi
 * @extends {BaseAPI}
 */
export class ActivityApi extends BaseAPI {
    /**
     * Delete a activity by its id
     * @summary Delete Activity
     * @param {ActivityApiActivityDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public activityDestroy(requestParameters: ActivityApiActivityDestroyRequest, options?: any) {
        return ActivityApiFp(this.configuration).activityDestroy(requestParameters.activity, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sales will get all activities directly created by him. Supervisor will get all activities created by its supervised sales. Director will get all activities scoped to its active channel setting.
     * @summary Show all activity posted by user
     * @param {ActivityApiActivityIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public activityIndex(requestParameters: ActivityApiActivityIndexRequest = {}, options?: any) {
        return ActivityApiFp(this.configuration).activityIndex(requestParameters.filterId, requestParameters.filterOrderId, requestParameters.filterUserId, requestParameters.filterCustomerId, requestParameters.filterChannelId, requestParameters.filterCompanyId, requestParameters.filterFollowUpMethod, requestParameters.filterStatus, requestParameters.filterFeedback, requestParameters.filterTargetId, requestParameters.filterFollowUpDatetimeBefore, requestParameters.filterFollowUpDatetimeAfter, requestParameters.filterHasPayment, requestParameters.filterHasAnyBrands, requestParameters.filterCreatedBefore, requestParameters.filterCreatedAfter, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns activity by id
     * @summary Get activity
     * @param {ActivityApiActivityShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public activityShow(requestParameters: ActivityApiActivityShowRequest, options?: any) {
        return ActivityApiFp(this.configuration).activityShow(requestParameters.activity, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new activity
     * @summary Create new Activity
     * @param {ActivityApiActivityStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public activityStore(requestParameters: ActivityApiActivityStoreRequest = {}, options?: any) {
        return ActivityApiFp(this.configuration).activityStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given activity
     * @summary Update a activity
     * @param {ActivityApiActivityUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public activityUpdate(requestParameters: ActivityApiActivityUpdateRequest, options?: any) {
        return ActivityApiFp(this.configuration).activityUpdate(requestParameters.activity, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all activities of a given customer
     * @summary Show all activities of a customer.
     * @param {ActivityApiCustomerGetActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityApi
     */
    public customerGetActivities(requestParameters: ActivityApiCustomerGetActivitiesRequest, options?: any) {
        return ActivityApiFp(this.configuration).customerGetActivities(requestParameters.customer, requestParameters.filterId, requestParameters.filterOrderId, requestParameters.filterUserId, requestParameters.filterCustomerId, requestParameters.filterChannelId, requestParameters.filterCompanyId, requestParameters.filterFollowUpMethod, requestParameters.filterStatus, requestParameters.filterFeedback, requestParameters.filterTargetId, requestParameters.filterFollowUpDatetimeBefore, requestParameters.filterFollowUpDatetimeAfter, requestParameters.filterHasPayment, requestParameters.filterHasAnyBrands, requestParameters.filterCreatedBefore, requestParameters.filterCreatedAfter, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ActivityCommentApi - axios parameter creator
 * @export
 */
export const ActivityCommentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a activityComment by its id
         * @summary Delete ActivityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentDestroy: async (activityComment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityComment' is not null or undefined
            assertParamExists('activityCommentDestroy', 'activityComment', activityComment)
            const localVarPath = `/api/v1/activity-comments/{activity_comment}`
                .replace(`{${"activity_comment"}}`, encodeURIComponent(String(activityComment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all activity comments posted by this user
         * @summary Show user\'s activity comment.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentIndex: async (filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activity-comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterActivityId !== undefined) {
                localVarQueryParameter['filter[activity_id]'] = filterActivityId;
            }

            if (filterActivityCommentId !== undefined) {
                localVarQueryParameter['filter[activity_comment_id]'] = filterActivityCommentId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns activityComment by id
         * @summary Get activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentShow: async (activityComment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityComment' is not null or undefined
            assertParamExists('activityCommentShow', 'activityComment', activityComment)
            const localVarPath = `/api/v1/activity-comments/{activity_comment}`
                .replace(`{${"activity_comment"}}`, encodeURIComponent(String(activityComment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new activityComment
         * @summary Create new ActivityComment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject14} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentStore: async (accept?: string, contentType?: string, data?: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activity-comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given activityComment
         * @summary Update a activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject15} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentUpdate: async (activityComment: string, accept?: string, contentType?: string, data?: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityComment' is not null or undefined
            assertParamExists('activityCommentUpdate', 'activityComment', activityComment)
            const localVarPath = `/api/v1/activity-comments/{activity_comment}`
                .replace(`{${"activity_comment"}}`, encodeURIComponent(String(activityComment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all activity comments for a given activity.
         * @summary Show all activity comments of an activity.
         * @param {number} activity 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityGetComments: async (activity: number, filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityGetComments', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}/comments`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterActivityId !== undefined) {
                localVarQueryParameter['filter[activity_id]'] = filterActivityId;
            }

            if (filterActivityCommentId !== undefined) {
                localVarQueryParameter['filter[activity_comment_id]'] = filterActivityCommentId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityCommentApi - functional programming interface
 * @export
 */
export const ActivityCommentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityCommentApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a activityComment by its id
         * @summary Delete ActivityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentDestroy(activityComment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentDestroy(activityComment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all activity comments posted by this user
         * @summary Show user\'s activity comment.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentIndex(filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentIndex(filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns activityComment by id
         * @summary Get activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentShow(activityComment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentShow(activityComment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new activityComment
         * @summary Create new ActivityComment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject14} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentStore(accept?: string, contentType?: string, data?: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given activityComment
         * @summary Update a activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject15} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentUpdate(activityComment: string, accept?: string, contentType?: string, data?: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentUpdate(activityComment, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all activity comments for a given activity.
         * @summary Show all activity comments of an activity.
         * @param {number} activity 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityGetComments(activity: number, filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityGetComments(activity, filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivityCommentApi - factory interface
 * @export
 */
export const ActivityCommentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityCommentApiFp(configuration)
    return {
        /**
         * Delete a activityComment by its id
         * @summary Delete ActivityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentDestroy(activityComment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.activityCommentDestroy(activityComment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all activity comments posted by this user
         * @summary Show user\'s activity comment.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentIndex(filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.activityCommentIndex(filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns activityComment by id
         * @summary Get activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentShow(activityComment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2013> {
            return localVarFp.activityCommentShow(activityComment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new activityComment
         * @summary Create new ActivityComment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject14} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentStore(accept?: string, contentType?: string, data?: InlineObject14, options?: any): AxiosPromise<InlineResponse2013> {
            return localVarFp.activityCommentStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given activityComment
         * @summary Update a activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject15} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentUpdate(activityComment: string, accept?: string, contentType?: string, data?: InlineObject15, options?: any): AxiosPromise<InlineResponse2013> {
            return localVarFp.activityCommentUpdate(activityComment, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all activity comments for a given activity.
         * @summary Show all activity comments of an activity.
         * @param {number} activity 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityGetComments(activity: number, filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.activityGetComments(activity, filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activityCommentDestroy operation in ActivityCommentApi.
 * @export
 * @interface ActivityCommentApiActivityCommentDestroyRequest
 */
export interface ActivityCommentApiActivityCommentDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentDestroy
     */
    readonly activityComment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCommentIndex operation in ActivityCommentApi.
 * @export
 * @interface ActivityCommentApiActivityCommentIndexRequest
 */
export interface ActivityCommentApiActivityCommentIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly filterActivityId?: number

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly filterActivityCommentId?: number

    /**
     * 
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly filterContent?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCommentShow operation in ActivityCommentApi.
 * @export
 * @interface ActivityCommentApiActivityCommentShowRequest
 */
export interface ActivityCommentApiActivityCommentShowRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentShow
     */
    readonly activityComment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCommentStore operation in ActivityCommentApi.
 * @export
 * @interface ActivityCommentApiActivityCommentStoreRequest
 */
export interface ActivityCommentApiActivityCommentStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject14}
     * @memberof ActivityCommentApiActivityCommentStore
     */
    readonly data?: InlineObject14
}

/**
 * Request parameters for activityCommentUpdate operation in ActivityCommentApi.
 * @export
 * @interface ActivityCommentApiActivityCommentUpdateRequest
 */
export interface ActivityCommentApiActivityCommentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentUpdate
     */
    readonly activityComment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityCommentApiActivityCommentUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject15}
     * @memberof ActivityCommentApiActivityCommentUpdate
     */
    readonly data?: InlineObject15
}

/**
 * Request parameters for activityGetComments operation in ActivityCommentApi.
 * @export
 * @interface ActivityCommentApiActivityGetCommentsRequest
 */
export interface ActivityCommentApiActivityGetCommentsRequest {
    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly activity: number

    /**
     * 
     * @type {string}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly filterActivityId?: number

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly filterActivityCommentId?: number

    /**
     * 
     * @type {string}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly filterContent?: string

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ActivityCommentApiActivityGetComments
     */
    readonly contentType?: string
}

/**
 * ActivityCommentApi - object-oriented interface
 * @export
 * @class ActivityCommentApi
 * @extends {BaseAPI}
 */
export class ActivityCommentApi extends BaseAPI {
    /**
     * Delete a activityComment by its id
     * @summary Delete ActivityComment
     * @param {ActivityCommentApiActivityCommentDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityCommentApi
     */
    public activityCommentDestroy(requestParameters: ActivityCommentApiActivityCommentDestroyRequest, options?: any) {
        return ActivityCommentApiFp(this.configuration).activityCommentDestroy(requestParameters.activityComment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all activity comments posted by this user
     * @summary Show user\'s activity comment.
     * @param {ActivityCommentApiActivityCommentIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityCommentApi
     */
    public activityCommentIndex(requestParameters: ActivityCommentApiActivityCommentIndexRequest = {}, options?: any) {
        return ActivityCommentApiFp(this.configuration).activityCommentIndex(requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterActivityId, requestParameters.filterActivityCommentId, requestParameters.filterContent, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns activityComment by id
     * @summary Get activityComment
     * @param {ActivityCommentApiActivityCommentShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityCommentApi
     */
    public activityCommentShow(requestParameters: ActivityCommentApiActivityCommentShowRequest, options?: any) {
        return ActivityCommentApiFp(this.configuration).activityCommentShow(requestParameters.activityComment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new activityComment
     * @summary Create new ActivityComment
     * @param {ActivityCommentApiActivityCommentStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityCommentApi
     */
    public activityCommentStore(requestParameters: ActivityCommentApiActivityCommentStoreRequest = {}, options?: any) {
        return ActivityCommentApiFp(this.configuration).activityCommentStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given activityComment
     * @summary Update a activityComment
     * @param {ActivityCommentApiActivityCommentUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityCommentApi
     */
    public activityCommentUpdate(requestParameters: ActivityCommentApiActivityCommentUpdateRequest, options?: any) {
        return ActivityCommentApiFp(this.configuration).activityCommentUpdate(requestParameters.activityComment, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all activity comments for a given activity.
     * @summary Show all activity comments of an activity.
     * @param {ActivityCommentApiActivityGetCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityCommentApi
     */
    public activityGetComments(requestParameters: ActivityCommentApiActivityGetCommentsRequest, options?: any) {
        return ActivityCommentApiFp(this.configuration).activityGetComments(requestParameters.activity, requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterActivityId, requestParameters.filterActivityCommentId, requestParameters.filterContent, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddressApi - axios parameter creator
 * @export
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a address by its id
         * @summary Delete Address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy: async (address: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressDestroy', 'address', address)
            const localVarPath = `/api/v1/addresses/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all address
         * @summary Show all address.
         * @param {string} [filterId] 
         * @param {number} [filterCustomerId] 
         * @param {string} [filterAddressLine1] 
         * @param {string} [filterAddressLine2] 
         * @param {string} [filterCity] 
         * @param {string} [filterCountry] 
         * @param {string} [filterProvince] 
         * @param {string} [filterPhone] 
         * @param {'ADDRESS' | 'DELIVERY' | 'BILLING'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex: async (filterId?: string, filterCustomerId?: number, filterAddressLine1?: string, filterAddressLine2?: string, filterCity?: string, filterCountry?: string, filterProvince?: string, filterPhone?: string, filterType?: 'ADDRESS' | 'DELIVERY' | 'BILLING', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterCustomerId !== undefined) {
                localVarQueryParameter['filter[customer_id]'] = filterCustomerId;
            }

            if (filterAddressLine1 !== undefined) {
                localVarQueryParameter['filter[address_line_1]'] = filterAddressLine1;
            }

            if (filterAddressLine2 !== undefined) {
                localVarQueryParameter['filter[address_line_2]'] = filterAddressLine2;
            }

            if (filterCity !== undefined) {
                localVarQueryParameter['filter[city]'] = filterCity;
            }

            if (filterCountry !== undefined) {
                localVarQueryParameter['filter[country]'] = filterCountry;
            }

            if (filterProvince !== undefined) {
                localVarQueryParameter['filter[province]'] = filterProvince;
            }

            if (filterPhone !== undefined) {
                localVarQueryParameter['filter[phone]'] = filterPhone;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns address by id
         * @summary Get address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow: async (address: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressShow', 'address', address)
            const localVarPath = `/api/v1/addresses/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating address
         * @summary Create new Address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject4} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore: async (accept?: string, contentType?: string, data?: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given address
         * @summary Update a address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject5} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate: async (address: string, accept?: string, contentType?: string, data?: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressUpdate', 'address', address)
            const localVarPath = `/api/v1/addresses/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a address by its id
         * @summary Delete Address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressDestroy(address: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressDestroy(address, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all address
         * @summary Show all address.
         * @param {string} [filterId] 
         * @param {number} [filterCustomerId] 
         * @param {string} [filterAddressLine1] 
         * @param {string} [filterAddressLine2] 
         * @param {string} [filterCity] 
         * @param {string} [filterCountry] 
         * @param {string} [filterProvince] 
         * @param {string} [filterPhone] 
         * @param {'ADDRESS' | 'DELIVERY' | 'BILLING'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressIndex(filterId?: string, filterCustomerId?: number, filterAddressLine1?: string, filterAddressLine2?: string, filterCity?: string, filterCountry?: string, filterProvince?: string, filterPhone?: string, filterType?: 'ADDRESS' | 'DELIVERY' | 'BILLING', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressIndex(filterId, filterCustomerId, filterAddressLine1, filterAddressLine2, filterCity, filterCountry, filterProvince, filterPhone, filterType, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns address by id
         * @summary Get address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressShow(address: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressShow(address, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating address
         * @summary Create new Address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject4} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressStore(accept?: string, contentType?: string, data?: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given address
         * @summary Update a address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject5} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressUpdate(address: string, accept?: string, contentType?: string, data?: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressUpdate(address, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressApiFp(configuration)
    return {
        /**
         * Delete a address by its id
         * @summary Delete Address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy(address: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.addressDestroy(address, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all address
         * @summary Show all address.
         * @param {string} [filterId] 
         * @param {number} [filterCustomerId] 
         * @param {string} [filterAddressLine1] 
         * @param {string} [filterAddressLine2] 
         * @param {string} [filterCity] 
         * @param {string} [filterCountry] 
         * @param {string} [filterProvince] 
         * @param {string} [filterPhone] 
         * @param {'ADDRESS' | 'DELIVERY' | 'BILLING'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex(filterId?: string, filterCustomerId?: number, filterAddressLine1?: string, filterAddressLine2?: string, filterCity?: string, filterCountry?: string, filterProvince?: string, filterPhone?: string, filterType?: 'ADDRESS' | 'DELIVERY' | 'BILLING', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.addressIndex(filterId, filterCustomerId, filterAddressLine1, filterAddressLine2, filterCity, filterCountry, filterProvince, filterPhone, filterType, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns address by id
         * @summary Get address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow(address: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.addressShow(address, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating address
         * @summary Create new Address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject4} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore(accept?: string, contentType?: string, data?: InlineObject4, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.addressStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given address
         * @summary Update a address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject5} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate(address: string, accept?: string, contentType?: string, data?: InlineObject5, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.addressUpdate(address, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addressDestroy operation in AddressApi.
 * @export
 * @interface AddressApiAddressDestroyRequest
 */
export interface AddressApiAddressDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressDestroy
     */
    readonly address: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof AddressApiAddressDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof AddressApiAddressDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressIndex operation in AddressApi.
 * @export
 * @interface AddressApiAddressIndexRequest
 */
export interface AddressApiAddressIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof AddressApiAddressIndex
     */
    readonly filterCustomerId?: number

    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly filterAddressLine1?: string

    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly filterAddressLine2?: string

    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly filterCity?: string

    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly filterCountry?: string

    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly filterProvince?: string

    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly filterPhone?: string

    /**
     * 
     * @type {'ADDRESS' | 'DELIVERY' | 'BILLING'}
     * @memberof AddressApiAddressIndex
     */
    readonly filterType?: 'ADDRESS' | 'DELIVERY' | 'BILLING'

    /**
     * 
     * @type {number}
     * @memberof AddressApiAddressIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof AddressApiAddressIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof AddressApiAddressIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressShow operation in AddressApi.
 * @export
 * @interface AddressApiAddressShowRequest
 */
export interface AddressApiAddressShowRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressShow
     */
    readonly address: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof AddressApiAddressShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof AddressApiAddressShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressStore operation in AddressApi.
 * @export
 * @interface AddressApiAddressStoreRequest
 */
export interface AddressApiAddressStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof AddressApiAddressStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof AddressApiAddressStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject4}
     * @memberof AddressApiAddressStore
     */
    readonly data?: InlineObject4
}

/**
 * Request parameters for addressUpdate operation in AddressApi.
 * @export
 * @interface AddressApiAddressUpdateRequest
 */
export interface AddressApiAddressUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressApiAddressUpdate
     */
    readonly address: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof AddressApiAddressUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof AddressApiAddressUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject5}
     * @memberof AddressApiAddressUpdate
     */
    readonly data?: InlineObject5
}

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * Delete a address by its id
     * @summary Delete Address
     * @param {AddressApiAddressDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressDestroy(requestParameters: AddressApiAddressDestroyRequest, options?: any) {
        return AddressApiFp(this.configuration).addressDestroy(requestParameters.address, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all address
     * @summary Show all address.
     * @param {AddressApiAddressIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressIndex(requestParameters: AddressApiAddressIndexRequest = {}, options?: any) {
        return AddressApiFp(this.configuration).addressIndex(requestParameters.filterId, requestParameters.filterCustomerId, requestParameters.filterAddressLine1, requestParameters.filterAddressLine2, requestParameters.filterCity, requestParameters.filterCountry, requestParameters.filterProvince, requestParameters.filterPhone, requestParameters.filterType, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns address by id
     * @summary Get address
     * @param {AddressApiAddressShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressShow(requestParameters: AddressApiAddressShowRequest, options?: any) {
        return AddressApiFp(this.configuration).addressShow(requestParameters.address, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating address
     * @summary Create new Address
     * @param {AddressApiAddressStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressStore(requestParameters: AddressApiAddressStoreRequest = {}, options?: any) {
        return AddressApiFp(this.configuration).addressStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given address
     * @summary Update a address
     * @param {AddressApiAddressUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressUpdate(requestParameters: AddressApiAddressUpdateRequest, options?: any) {
        return AddressApiFp(this.configuration).addressUpdate(requestParameters.address, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a user token
         * @summary Get Token
         * @param {InlineObject32} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authToken: async (data?: InlineObject32, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register sales SMS
         * @summary Register sales SMS
         * @param {InlineObject33} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (data?: InlineObject33, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a user token
         * @summary Get Token
         * @param {InlineObject32} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authToken(data?: InlineObject32, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20063>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authToken(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register sales SMS
         * @summary Register sales SMS
         * @param {InlineObject33} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(data?: InlineObject33, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Get a user token
         * @summary Get Token
         * @param {InlineObject32} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authToken(data?: InlineObject32, options?: any): AxiosPromise<InlineResponse20063> {
            return localVarFp.authToken(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Register sales SMS
         * @summary Register sales SMS
         * @param {InlineObject33} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(data?: InlineObject33, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.register(data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authToken operation in AuthApi.
 * @export
 * @interface AuthApiAuthTokenRequest
 */
export interface AuthApiAuthTokenRequest {
    /**
     * 
     * @type {InlineObject32}
     * @memberof AuthApiAuthToken
     */
    readonly data?: InlineObject32
}

/**
 * Request parameters for register operation in AuthApi.
 * @export
 * @interface AuthApiRegisterRequest
 */
export interface AuthApiRegisterRequest {
    /**
     * 
     * @type {InlineObject33}
     * @memberof AuthApiRegister
     */
    readonly data?: InlineObject33
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Get a user token
     * @summary Get Token
     * @param {AuthApiAuthTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authToken(requestParameters: AuthApiAuthTokenRequest = {}, options?: any) {
        return AuthApiFp(this.configuration).authToken(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register sales SMS
     * @summary Register sales SMS
     * @param {AuthApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public register(requestParameters: AuthApiRegisterRequest = {}, options?: any) {
        return AuthApiFp(this.configuration).register(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CartApi - axios parameter creator
 * @export
 */
export const CartApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show cart of logged in user
         * @summary Show user cart.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartIndex: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/carts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync user cart content
         * @summary Sync cart
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject21} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartSync: async (accept?: string, contentType?: string, data?: InlineObject21, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/carts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get discount that match the given discount code.
         * @summary Get discount by code
         * @param {string} code The discount activation code
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountGetByCode: async (code: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('discountGetByCode', 'code', code)
            const localVarPath = `/api/v1/discounts/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all public discounts.
         * @summary Get discounts
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterActivationCode] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountIndex: async (filterId?: string, filterName?: string, filterActivationCode?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/discounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterActivationCode !== undefined) {
                localVarQueryParameter['filter[activation_code]'] = filterActivationCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartApi - functional programming interface
 * @export
 */
export const CartApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartApiAxiosParamCreator(configuration)
    return {
        /**
         * Show cart of logged in user
         * @summary Show user cart.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartIndex(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartIndex(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sync user cart content
         * @summary Sync cart
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject21} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartSync(accept?: string, contentType?: string, data?: InlineObject21, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartSync(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get discount that match the given discount code.
         * @summary Get discount by code
         * @param {string} code The discount activation code
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountGetByCode(code: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20046>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountGetByCode(code, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all public discounts.
         * @summary Get discounts
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterActivationCode] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountIndex(filterId?: string, filterName?: string, filterActivationCode?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20045>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountIndex(filterId, filterName, filterActivationCode, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CartApi - factory interface
 * @export
 */
export const CartApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartApiFp(configuration)
    return {
        /**
         * Show cart of logged in user
         * @summary Show user cart.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartIndex(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20043> {
            return localVarFp.cartIndex(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync user cart content
         * @summary Sync cart
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject21} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartSync(accept?: string, contentType?: string, data?: InlineObject21, options?: any): AxiosPromise<InlineResponse20043> {
            return localVarFp.cartSync(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Get discount that match the given discount code.
         * @summary Get discount by code
         * @param {string} code The discount activation code
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountGetByCode(code: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20046> {
            return localVarFp.discountGetByCode(code, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all public discounts.
         * @summary Get discounts
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterActivationCode] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountIndex(filterId?: string, filterName?: string, filterActivationCode?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20045> {
            return localVarFp.discountIndex(filterId, filterName, filterActivationCode, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cartIndex operation in CartApi.
 * @export
 * @interface CartApiCartIndexRequest
 */
export interface CartApiCartIndexRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof CartApiCartIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CartApiCartIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for cartSync operation in CartApi.
 * @export
 * @interface CartApiCartSyncRequest
 */
export interface CartApiCartSyncRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof CartApiCartSync
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CartApiCartSync
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject21}
     * @memberof CartApiCartSync
     */
    readonly data?: InlineObject21
}

/**
 * Request parameters for discountGetByCode operation in CartApi.
 * @export
 * @interface CartApiDiscountGetByCodeRequest
 */
export interface CartApiDiscountGetByCodeRequest {
    /**
     * The discount activation code
     * @type {string}
     * @memberof CartApiDiscountGetByCode
     */
    readonly code: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CartApiDiscountGetByCode
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CartApiDiscountGetByCode
     */
    readonly contentType?: string
}

/**
 * Request parameters for discountIndex operation in CartApi.
 * @export
 * @interface CartApiDiscountIndexRequest
 */
export interface CartApiDiscountIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof CartApiDiscountIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof CartApiDiscountIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof CartApiDiscountIndex
     */
    readonly filterActivationCode?: string

    /**
     * 
     * @type {number}
     * @memberof CartApiDiscountIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CartApiDiscountIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof CartApiDiscountIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CartApiDiscountIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CartApiDiscountIndex
     */
    readonly contentType?: string
}

/**
 * CartApi - object-oriented interface
 * @export
 * @class CartApi
 * @extends {BaseAPI}
 */
export class CartApi extends BaseAPI {
    /**
     * Show cart of logged in user
     * @summary Show user cart.
     * @param {CartApiCartIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartIndex(requestParameters: CartApiCartIndexRequest = {}, options?: any) {
        return CartApiFp(this.configuration).cartIndex(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync user cart content
     * @summary Sync cart
     * @param {CartApiCartSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public cartSync(requestParameters: CartApiCartSyncRequest = {}, options?: any) {
        return CartApiFp(this.configuration).cartSync(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get discount that match the given discount code.
     * @summary Get discount by code
     * @param {CartApiDiscountGetByCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public discountGetByCode(requestParameters: CartApiDiscountGetByCodeRequest, options?: any) {
        return CartApiFp(this.configuration).discountGetByCode(requestParameters.code, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all public discounts.
     * @summary Get discounts
     * @param {CartApiDiscountIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartApi
     */
    public discountIndex(requestParameters: CartApiDiscountIndexRequest = {}, options?: any) {
        return CartApiFp(this.configuration).discountIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.filterActivationCode, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CartDemandApi - axios parameter creator
 * @export
 */
export const CartDemandApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a cart demand by its id
         * @summary Delete cart demand
         * @param {string} cartDemand 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandDestroy: async (cartDemand: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartDemand' is not null or undefined
            assertParamExists('cartDemandDestroy', 'cartDemand', cartDemand)
            const localVarPath = `/api/v1/cart-demands/{cart_demand}`
                .replace(`{${"cart_demand"}}`, encodeURIComponent(String(cartDemand)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show cart demand of logged in user
         * @summary Show user cart demand.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandIndex: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cart-demands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync user cart demand content
         * @summary Sync cart demand
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject22} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandSync: async (accept?: string, contentType?: string, data?: InlineObject22, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cart-demands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} cartDemand 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody1} [imageRequestBody1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandUploadImage: async (cartDemand: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody1?: ImageRequestBody1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartDemand' is not null or undefined
            assertParamExists('cartDemandUploadImage', 'cartDemand', cartDemand)
            const localVarPath = `/api/v1/cart-demands/{cartDemand}/upload`
                .replace(`{${"cartDemand"}}`, encodeURIComponent(String(cartDemand)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequestBody1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CartDemandApi - functional programming interface
 * @export
 */
export const CartDemandApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CartDemandApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a cart demand by its id
         * @summary Delete cart demand
         * @param {string} cartDemand 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartDemandDestroy(cartDemand: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartDemandDestroy(cartDemand, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show cart demand of logged in user
         * @summary Show user cart demand.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartDemandIndex(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartDemandIndex(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sync user cart demand content
         * @summary Sync cart demand
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject22} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartDemandSync(accept?: string, contentType?: string, data?: InlineObject22, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartDemandSync(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} cartDemand 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody1} [imageRequestBody1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartDemandUploadImage(cartDemand: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody1?: ImageRequestBody1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartDemandUploadImage(cartDemand, filterId, page, perPage, sort, accept, contentType, imageRequestBody1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CartDemandApi - factory interface
 * @export
 */
export const CartDemandApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CartDemandApiFp(configuration)
    return {
        /**
         * Delete a cart demand by its id
         * @summary Delete cart demand
         * @param {string} cartDemand 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandDestroy(cartDemand: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.cartDemandDestroy(cartDemand, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show cart demand of logged in user
         * @summary Show user cart demand.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandIndex(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20044> {
            return localVarFp.cartDemandIndex(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync user cart demand content
         * @summary Sync cart demand
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject22} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandSync(accept?: string, contentType?: string, data?: InlineObject22, options?: any): AxiosPromise<InlineResponse20044> {
            return localVarFp.cartDemandSync(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} cartDemand 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody1} [imageRequestBody1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandUploadImage(cartDemand: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody1?: ImageRequestBody1, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.cartDemandUploadImage(cartDemand, filterId, page, perPage, sort, accept, contentType, imageRequestBody1, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cartDemandDestroy operation in CartDemandApi.
 * @export
 * @interface CartDemandApiCartDemandDestroyRequest
 */
export interface CartDemandApiCartDemandDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof CartDemandApiCartDemandDestroy
     */
    readonly cartDemand: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CartDemandApiCartDemandDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CartDemandApiCartDemandDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for cartDemandIndex operation in CartDemandApi.
 * @export
 * @interface CartDemandApiCartDemandIndexRequest
 */
export interface CartDemandApiCartDemandIndexRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof CartDemandApiCartDemandIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CartDemandApiCartDemandIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for cartDemandSync operation in CartDemandApi.
 * @export
 * @interface CartDemandApiCartDemandSyncRequest
 */
export interface CartDemandApiCartDemandSyncRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof CartDemandApiCartDemandSync
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CartDemandApiCartDemandSync
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject22}
     * @memberof CartDemandApiCartDemandSync
     */
    readonly data?: InlineObject22
}

/**
 * Request parameters for cartDemandUploadImage operation in CartDemandApi.
 * @export
 * @interface CartDemandApiCartDemandUploadImageRequest
 */
export interface CartDemandApiCartDemandUploadImageRequest {
    /**
     * 
     * @type {string}
     * @memberof CartDemandApiCartDemandUploadImage
     */
    readonly cartDemand: string

    /**
     * 
     * @type {string}
     * @memberof CartDemandApiCartDemandUploadImage
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof CartDemandApiCartDemandUploadImage
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CartDemandApiCartDemandUploadImage
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof CartDemandApiCartDemandUploadImage
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CartDemandApiCartDemandUploadImage
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CartDemandApiCartDemandUploadImage
     */
    readonly contentType?: string

    /**
     * 
     * @type {ImageRequestBody1}
     * @memberof CartDemandApiCartDemandUploadImage
     */
    readonly imageRequestBody1?: ImageRequestBody1
}

/**
 * CartDemandApi - object-oriented interface
 * @export
 * @class CartDemandApi
 * @extends {BaseAPI}
 */
export class CartDemandApi extends BaseAPI {
    /**
     * Delete a cart demand by its id
     * @summary Delete cart demand
     * @param {CartDemandApiCartDemandDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartDemandApi
     */
    public cartDemandDestroy(requestParameters: CartDemandApiCartDemandDestroyRequest, options?: any) {
        return CartDemandApiFp(this.configuration).cartDemandDestroy(requestParameters.cartDemand, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show cart demand of logged in user
     * @summary Show user cart demand.
     * @param {CartDemandApiCartDemandIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartDemandApi
     */
    public cartDemandIndex(requestParameters: CartDemandApiCartDemandIndexRequest = {}, options?: any) {
        return CartDemandApiFp(this.configuration).cartDemandIndex(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync user cart demand content
     * @summary Sync cart demand
     * @param {CartDemandApiCartDemandSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartDemandApi
     */
    public cartDemandSync(requestParameters: CartDemandApiCartDemandSyncRequest = {}, options?: any) {
        return CartDemandApiFp(this.configuration).cartDemandSync(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload order detail product unit image
     * @summary Upload order detail product unit image
     * @param {CartDemandApiCartDemandUploadImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CartDemandApi
     */
    public cartDemandUploadImage(requestParameters: CartDemandApiCartDemandUploadImageRequest, options?: any) {
        return CartDemandApiFp(this.configuration).cartDemandUploadImage(requestParameters.cartDemand, requestParameters.filterId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, requestParameters.imageRequestBody1, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the default channel of authenticated user
         * @summary Get default channel
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefault: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/channels/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all channels available for this user
         * @summary Show all channels.
         * @param {string} [filterId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {string} [filterSupervisorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelIndex: async (filterId?: string, filterCompanyId?: number, filterName?: string, filterSupervisorId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterSupervisorId !== undefined) {
                localVarQueryParameter['filter[supervisor_id]'] = filterSupervisorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns channel by id
         * @summary Get channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelShow: async (channel: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('channelShow', 'channel', channel)
            const localVarPath = `/api/v1/channels/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the default channel of authenticated user
         * @summary Get default channel
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelDefault(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelDefault(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all channels available for this user
         * @summary Show all channels.
         * @param {string} [filterId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {string} [filterSupervisorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelIndex(filterId?: string, filterCompanyId?: number, filterName?: string, filterSupervisorId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelIndex(filterId, filterCompanyId, filterName, filterSupervisorId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns channel by id
         * @summary Get channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelShow(channel: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelShow(channel, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelApiFp(configuration)
    return {
        /**
         * Returns the default channel of authenticated user
         * @summary Get default channel
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefault(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.channelDefault(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all channels available for this user
         * @summary Show all channels.
         * @param {string} [filterId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {string} [filterSupervisorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelIndex(filterId?: string, filterCompanyId?: number, filterName?: string, filterSupervisorId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.channelIndex(filterId, filterCompanyId, filterName, filterSupervisorId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns channel by id
         * @summary Get channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelShow(channel: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.channelShow(channel, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for channelDefault operation in ChannelApi.
 * @export
 * @interface ChannelApiChannelDefaultRequest
 */
export interface ChannelApiChannelDefaultRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof ChannelApiChannelDefault
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ChannelApiChannelDefault
     */
    readonly contentType?: string
}

/**
 * Request parameters for channelIndex operation in ChannelApi.
 * @export
 * @interface ChannelApiChannelIndexRequest
 */
export interface ChannelApiChannelIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelApiChannelIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof ChannelApiChannelIndex
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {string}
     * @memberof ChannelApiChannelIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof ChannelApiChannelIndex
     */
    readonly filterSupervisorId?: string

    /**
     * 
     * @type {number}
     * @memberof ChannelApiChannelIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ChannelApiChannelIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ChannelApiChannelIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ChannelApiChannelIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ChannelApiChannelIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for channelShow operation in ChannelApi.
 * @export
 * @interface ChannelApiChannelShowRequest
 */
export interface ChannelApiChannelShowRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelApiChannelShow
     */
    readonly channel: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ChannelApiChannelShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ChannelApiChannelShow
     */
    readonly contentType?: string
}

/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI {
    /**
     * Returns the default channel of authenticated user
     * @summary Get default channel
     * @param {ChannelApiChannelDefaultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public channelDefault(requestParameters: ChannelApiChannelDefaultRequest = {}, options?: any) {
        return ChannelApiFp(this.configuration).channelDefault(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all channels available for this user
     * @summary Show all channels.
     * @param {ChannelApiChannelIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public channelIndex(requestParameters: ChannelApiChannelIndexRequest = {}, options?: any) {
        return ChannelApiFp(this.configuration).channelIndex(requestParameters.filterId, requestParameters.filterCompanyId, requestParameters.filterName, requestParameters.filterSupervisorId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns channel by id
     * @summary Get channel
     * @param {ChannelApiChannelShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public channelShow(requestParameters: ChannelApiChannelShowRequest, options?: any) {
        return ChannelApiFp(this.configuration).channelShow(requestParameters.channel, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CompanyApi - axios parameter creator
 * @export
 */
export const CompanyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show companies
         * @summary Get all company account
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAccountIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/company-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show companies
         * @summary Get all Companies
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns company by id
         * @summary Get Company
         * @param {string} company 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyShow: async (company: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'company' is not null or undefined
            assertParamExists('companyShow', 'company', company)
            const localVarPath = `/api/v1/companies/{company}`
                .replace(`{${"company"}}`, encodeURIComponent(String(company)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyApi - functional programming interface
 * @export
 */
export const CompanyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompanyApiAxiosParamCreator(configuration)
    return {
        /**
         * Show companies
         * @summary Get all company account
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyAccountIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyAccountIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show companies
         * @summary Get all Companies
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns company by id
         * @summary Get Company
         * @param {string} company 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyShow(company: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyShow(company, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CompanyApi - factory interface
 * @export
 */
export const CompanyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompanyApiFp(configuration)
    return {
        /**
         * Show companies
         * @summary Get all company account
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAccountIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.companyAccountIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show companies
         * @summary Get all Companies
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.companyIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns company by id
         * @summary Get Company
         * @param {string} company 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyShow(company: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.companyShow(company, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for companyAccountIndex operation in CompanyApi.
 * @export
 * @interface CompanyApiCompanyAccountIndexRequest
 */
export interface CompanyApiCompanyAccountIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof CompanyApiCompanyAccountIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof CompanyApiCompanyAccountIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof CompanyApiCompanyAccountIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CompanyApiCompanyAccountIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof CompanyApiCompanyAccountIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CompanyApiCompanyAccountIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CompanyApiCompanyAccountIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for companyIndex operation in CompanyApi.
 * @export
 * @interface CompanyApiCompanyIndexRequest
 */
export interface CompanyApiCompanyIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof CompanyApiCompanyIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof CompanyApiCompanyIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof CompanyApiCompanyIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CompanyApiCompanyIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof CompanyApiCompanyIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CompanyApiCompanyIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CompanyApiCompanyIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for companyShow operation in CompanyApi.
 * @export
 * @interface CompanyApiCompanyShowRequest
 */
export interface CompanyApiCompanyShowRequest {
    /**
     * 
     * @type {string}
     * @memberof CompanyApiCompanyShow
     */
    readonly company: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CompanyApiCompanyShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CompanyApiCompanyShow
     */
    readonly contentType?: string
}

/**
 * CompanyApi - object-oriented interface
 * @export
 * @class CompanyApi
 * @extends {BaseAPI}
 */
export class CompanyApi extends BaseAPI {
    /**
     * Show companies
     * @summary Get all company account
     * @param {CompanyApiCompanyAccountIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public companyAccountIndex(requestParameters: CompanyApiCompanyAccountIndexRequest = {}, options?: any) {
        return CompanyApiFp(this.configuration).companyAccountIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show companies
     * @summary Get all Companies
     * @param {CompanyApiCompanyIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public companyIndex(requestParameters: CompanyApiCompanyIndexRequest = {}, options?: any) {
        return CompanyApiFp(this.configuration).companyIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns company by id
     * @summary Get Company
     * @param {CompanyApiCompanyShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public companyShow(requestParameters: CompanyApiCompanyShowRequest, options?: any) {
        return CompanyApiFp(this.configuration).companyShow(requestParameters.company, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerApi - axios parameter creator
 * @export
 */
export const CustomerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all activity comments for a given activity.
         * @summary Show all activity comments of an activity.
         * @param {number} activity 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityGetComments: async (activity: number, filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityGetComments', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}/comments`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterActivityId !== undefined) {
                localVarQueryParameter['filter[activity_id]'] = filterActivityId;
            }

            if (filterActivityCommentId !== undefined) {
                localVarQueryParameter['filter[activity_comment_id]'] = filterActivityCommentId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating customer with address
         * @summary Show create customer with address rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreateWithAddress: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers/addresses/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a customer by its id
         * @summary Delete Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDelete: async (customer: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerDelete', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all activities of a given customer
         * @summary Show all activities of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetActivities: async (customer: number, filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerGetActivities', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}/activities`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterOrderId !== undefined) {
                localVarQueryParameter['filter[order_id]'] = filterOrderId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterCustomerId !== undefined) {
                localVarQueryParameter['filter[customer_id]'] = filterCustomerId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterFollowUpMethod !== undefined) {
                localVarQueryParameter['filter[follow_up_method]'] = filterFollowUpMethod;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterFeedback !== undefined) {
                localVarQueryParameter['filter[feedback]'] = filterFeedback;
            }

            if (filterTargetId !== undefined) {
                localVarQueryParameter['filter[target_id]'] = filterTargetId;
            }

            if (filterFollowUpDatetimeBefore !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_before]'] = filterFollowUpDatetimeBefore;
            }

            if (filterFollowUpDatetimeAfter !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_after]'] = filterFollowUpDatetimeAfter;
            }

            if (filterHasPayment !== undefined) {
                localVarQueryParameter['filter[has_payment]'] = filterHasPayment;
            }

            if (filterHasAnyBrands !== undefined) {
                localVarQueryParameter['filter[has_any_brands]'] = filterHasAnyBrands;
            }

            if (filterCreatedBefore !== undefined) {
                localVarQueryParameter['filter[created_before]'] = filterCreatedBefore;
            }

            if (filterCreatedAfter !== undefined) {
                localVarQueryParameter['filter[created_after]'] = filterCreatedAfter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all leads of a given customer
         * @summary Show all leads of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetLeads: async (customer: number, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerGetLeads', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}/leads`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all Customer stored globally in the application.
         * @summary Show all customer.
         * @param {string} [filterId] 
         * @param {string} [filterFirstName] 
         * @param {string} [filterLastName] 
         * @param {string} [filterEmail] 
         * @param {string} [filterPhone] 
         * @param {string} [filterSearch] 
         * @param {boolean} [filterHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerIndex: async (filterId?: string, filterFirstName?: string, filterLastName?: string, filterEmail?: string, filterPhone?: string, filterSearch?: string, filterHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterFirstName !== undefined) {
                localVarQueryParameter['filter[first_name]'] = filterFirstName;
            }

            if (filterLastName !== undefined) {
                localVarQueryParameter['filter[last_name]'] = filterLastName;
            }

            if (filterEmail !== undefined) {
                localVarQueryParameter['filter[email]'] = filterEmail;
            }

            if (filterPhone !== undefined) {
                localVarQueryParameter['filter[phone]'] = filterPhone;
            }

            if (filterSearch !== undefined) {
                localVarQueryParameter['filter[search]'] = filterSearch;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns customer by id
         * @summary Get Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerShow: async (customer: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerShow', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating customer
         * @summary Create new Customer
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject2} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerStore: async (accept?: string, contentType?: string, data?: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new customer with address. This will assign the address as the customer\'s default address id as well
         * @summary Create new customer with address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject1} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerStoreWithAddress: async (accept?: string, contentType?: string, data?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given customer
         * @summary Update a customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject3} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate: async (customer: string, accept?: string, contentType?: string, data?: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerUpdate', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all activity comments for a given activity.
         * @summary Show all activity comments of an activity.
         * @param {number} activity 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityGetComments(activity: number, filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityGetComments(activity, filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating customer with address
         * @summary Show create customer with address rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerCreateWithAddress(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreateWithAddress(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a customer by its id
         * @summary Delete Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDelete(customer: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDelete(customer, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all activities of a given customer
         * @summary Show all activities of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGetActivities(customer: number, filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGetActivities(customer, filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all leads of a given customer
         * @summary Show all leads of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGetLeads(customer: number, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGetLeads(customer, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all Customer stored globally in the application.
         * @summary Show all customer.
         * @param {string} [filterId] 
         * @param {string} [filterFirstName] 
         * @param {string} [filterLastName] 
         * @param {string} [filterEmail] 
         * @param {string} [filterPhone] 
         * @param {string} [filterSearch] 
         * @param {boolean} [filterHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerIndex(filterId?: string, filterFirstName?: string, filterLastName?: string, filterEmail?: string, filterPhone?: string, filterSearch?: string, filterHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerIndex(filterId, filterFirstName, filterLastName, filterEmail, filterPhone, filterSearch, filterHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns customer by id
         * @summary Get Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerShow(customer: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerShow(customer, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating customer
         * @summary Create new Customer
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject2} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerStore(accept?: string, contentType?: string, data?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new customer with address. This will assign the address as the customer\'s default address id as well
         * @summary Create new customer with address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject1} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerStoreWithAddress(accept?: string, contentType?: string, data?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerStoreWithAddress(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given customer
         * @summary Update a customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject3} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerUpdate(customer: string, accept?: string, contentType?: string, data?: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerUpdate(customer, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerApiFp(configuration)
    return {
        /**
         * Show all activity comments for a given activity.
         * @summary Show all activity comments of an activity.
         * @param {number} activity 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityGetComments(activity: number, filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.activityGetComments(activity, filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating customer with address
         * @summary Show create customer with address rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreateWithAddress(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.customerCreateWithAddress(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a customer by its id
         * @summary Delete Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDelete(customer: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.customerDelete(customer, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all activities of a given customer
         * @summary Show all activities of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetActivities(customer: number, filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.customerGetActivities(customer, filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all leads of a given customer
         * @summary Show all leads of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetLeads(customer: number, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.customerGetLeads(customer, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all Customer stored globally in the application.
         * @summary Show all customer.
         * @param {string} [filterId] 
         * @param {string} [filterFirstName] 
         * @param {string} [filterLastName] 
         * @param {string} [filterEmail] 
         * @param {string} [filterPhone] 
         * @param {string} [filterSearch] 
         * @param {boolean} [filterHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerIndex(filterId?: string, filterFirstName?: string, filterLastName?: string, filterEmail?: string, filterPhone?: string, filterSearch?: string, filterHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.customerIndex(filterId, filterFirstName, filterLastName, filterEmail, filterPhone, filterSearch, filterHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns customer by id
         * @summary Get Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerShow(customer: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.customerShow(customer, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating customer
         * @summary Create new Customer
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject2} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerStore(accept?: string, contentType?: string, data?: InlineObject2, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.customerStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new customer with address. This will assign the address as the customer\'s default address id as well
         * @summary Create new customer with address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject1} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerStoreWithAddress(accept?: string, contentType?: string, data?: InlineObject1, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.customerStoreWithAddress(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given customer
         * @summary Update a customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject3} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate(customer: string, accept?: string, contentType?: string, data?: InlineObject3, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.customerUpdate(customer, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activityGetComments operation in CustomerApi.
 * @export
 * @interface CustomerApiActivityGetCommentsRequest
 */
export interface CustomerApiActivityGetCommentsRequest {
    /**
     * 
     * @type {number}
     * @memberof CustomerApiActivityGetComments
     */
    readonly activity: number

    /**
     * 
     * @type {string}
     * @memberof CustomerApiActivityGetComments
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof CustomerApiActivityGetComments
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {number}
     * @memberof CustomerApiActivityGetComments
     */
    readonly filterActivityId?: number

    /**
     * 
     * @type {number}
     * @memberof CustomerApiActivityGetComments
     */
    readonly filterActivityCommentId?: number

    /**
     * 
     * @type {string}
     * @memberof CustomerApiActivityGetComments
     */
    readonly filterContent?: string

    /**
     * 
     * @type {number}
     * @memberof CustomerApiActivityGetComments
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CustomerApiActivityGetComments
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof CustomerApiActivityGetComments
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiActivityGetComments
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiActivityGetComments
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerCreateWithAddress operation in CustomerApi.
 * @export
 * @interface CustomerApiCustomerCreateWithAddressRequest
 */
export interface CustomerApiCustomerCreateWithAddressRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiCustomerCreateWithAddress
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiCustomerCreateWithAddress
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerDelete operation in CustomerApi.
 * @export
 * @interface CustomerApiCustomerDeleteRequest
 */
export interface CustomerApiCustomerDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerDelete
     */
    readonly customer: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiCustomerDelete
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiCustomerDelete
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerGetActivities operation in CustomerApi.
 * @export
 * @interface CustomerApiCustomerGetActivitiesRequest
 */
export interface CustomerApiCustomerGetActivitiesRequest {
    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly customer: number

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterOrderId?: number

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterUserId?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterCustomerId?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterChannelId?: string

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'

    /**
     * 
     * @type {'HOT' | 'WARM' | 'COLD' | 'DROP'}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP'

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterFeedback?: string

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterTargetId?: number

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterFollowUpDatetimeBefore?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterFollowUpDatetimeAfter?: string

    /**
     * 
     * @type {boolean}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterHasPayment?: boolean

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterHasAnyBrands?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterCreatedBefore?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly filterCreatedAfter?: string

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiCustomerGetActivities
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerGetLeads operation in CustomerApi.
 * @export
 * @interface CustomerApiCustomerGetLeadsRequest
 */
export interface CustomerApiCustomerGetLeadsRequest {
    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly customer: number

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiCustomerGetLeads
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerIndex operation in CustomerApi.
 * @export
 * @interface CustomerApiCustomerIndexRequest
 */
export interface CustomerApiCustomerIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerIndex
     */
    readonly filterFirstName?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerIndex
     */
    readonly filterLastName?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerIndex
     */
    readonly filterEmail?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerIndex
     */
    readonly filterPhone?: string

    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerIndex
     */
    readonly filterSearch?: string

    /**
     * 
     * @type {boolean}
     * @memberof CustomerApiCustomerIndex
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof CustomerApiCustomerIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof CustomerApiCustomerIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiCustomerIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiCustomerIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerShow operation in CustomerApi.
 * @export
 * @interface CustomerApiCustomerShowRequest
 */
export interface CustomerApiCustomerShowRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerShow
     */
    readonly customer: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiCustomerShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiCustomerShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerStore operation in CustomerApi.
 * @export
 * @interface CustomerApiCustomerStoreRequest
 */
export interface CustomerApiCustomerStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiCustomerStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiCustomerStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject2}
     * @memberof CustomerApiCustomerStore
     */
    readonly data?: InlineObject2
}

/**
 * Request parameters for customerStoreWithAddress operation in CustomerApi.
 * @export
 * @interface CustomerApiCustomerStoreWithAddressRequest
 */
export interface CustomerApiCustomerStoreWithAddressRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiCustomerStoreWithAddress
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiCustomerStoreWithAddress
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject1}
     * @memberof CustomerApiCustomerStoreWithAddress
     */
    readonly data?: InlineObject1
}

/**
 * Request parameters for customerUpdate operation in CustomerApi.
 * @export
 * @interface CustomerApiCustomerUpdateRequest
 */
export interface CustomerApiCustomerUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomerApiCustomerUpdate
     */
    readonly customer: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerApiCustomerUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerApiCustomerUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject3}
     * @memberof CustomerApiCustomerUpdate
     */
    readonly data?: InlineObject3
}

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     * Show all activity comments for a given activity.
     * @summary Show all activity comments of an activity.
     * @param {CustomerApiActivityGetCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public activityGetComments(requestParameters: CustomerApiActivityGetCommentsRequest, options?: any) {
        return CustomerApiFp(this.configuration).activityGetComments(requestParameters.activity, requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterActivityId, requestParameters.filterActivityCommentId, requestParameters.filterContent, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating customer with address
     * @summary Show create customer with address rule
     * @param {CustomerApiCustomerCreateWithAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerCreateWithAddress(requestParameters: CustomerApiCustomerCreateWithAddressRequest = {}, options?: any) {
        return CustomerApiFp(this.configuration).customerCreateWithAddress(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a customer by its id
     * @summary Delete Customer
     * @param {CustomerApiCustomerDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerDelete(requestParameters: CustomerApiCustomerDeleteRequest, options?: any) {
        return CustomerApiFp(this.configuration).customerDelete(requestParameters.customer, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all activities of a given customer
     * @summary Show all activities of a customer.
     * @param {CustomerApiCustomerGetActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerGetActivities(requestParameters: CustomerApiCustomerGetActivitiesRequest, options?: any) {
        return CustomerApiFp(this.configuration).customerGetActivities(requestParameters.customer, requestParameters.filterId, requestParameters.filterOrderId, requestParameters.filterUserId, requestParameters.filterCustomerId, requestParameters.filterChannelId, requestParameters.filterCompanyId, requestParameters.filterFollowUpMethod, requestParameters.filterStatus, requestParameters.filterFeedback, requestParameters.filterTargetId, requestParameters.filterFollowUpDatetimeBefore, requestParameters.filterFollowUpDatetimeAfter, requestParameters.filterHasPayment, requestParameters.filterHasAnyBrands, requestParameters.filterCreatedBefore, requestParameters.filterCreatedAfter, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all leads of a given customer
     * @summary Show all leads of a customer.
     * @param {CustomerApiCustomerGetLeadsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerGetLeads(requestParameters: CustomerApiCustomerGetLeadsRequest, options?: any) {
        return CustomerApiFp(this.configuration).customerGetLeads(requestParameters.customer, requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all Customer stored globally in the application.
     * @summary Show all customer.
     * @param {CustomerApiCustomerIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerIndex(requestParameters: CustomerApiCustomerIndexRequest = {}, options?: any) {
        return CustomerApiFp(this.configuration).customerIndex(requestParameters.filterId, requestParameters.filterFirstName, requestParameters.filterLastName, requestParameters.filterEmail, requestParameters.filterPhone, requestParameters.filterSearch, requestParameters.filterHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns customer by id
     * @summary Get Customer
     * @param {CustomerApiCustomerShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerShow(requestParameters: CustomerApiCustomerShowRequest, options?: any) {
        return CustomerApiFp(this.configuration).customerShow(requestParameters.customer, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating customer
     * @summary Create new Customer
     * @param {CustomerApiCustomerStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerStore(requestParameters: CustomerApiCustomerStoreRequest = {}, options?: any) {
        return CustomerApiFp(this.configuration).customerStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new customer with address. This will assign the address as the customer\'s default address id as well
     * @summary Create new customer with address
     * @param {CustomerApiCustomerStoreWithAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerStoreWithAddress(requestParameters: CustomerApiCustomerStoreWithAddressRequest = {}, options?: any) {
        return CustomerApiFp(this.configuration).customerStoreWithAddress(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given customer
     * @summary Update a customer
     * @param {CustomerApiCustomerUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public customerUpdate(requestParameters: CustomerApiCustomerUpdateRequest, options?: any) {
        return CustomerApiFp(this.configuration).customerUpdate(requestParameters.customer, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerDepositApi - axios parameter creator
 * @export
 */
export const CustomerDepositApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new CustomerDeposit
         * @summary Create new CustomerDeposit
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject16} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDepositStore: async (accept?: string, contentType?: string, data?: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customer-deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerDepositApi - functional programming interface
 * @export
 */
export const CustomerDepositApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerDepositApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new CustomerDeposit
         * @summary Create new CustomerDeposit
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject16} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDepositStore(accept?: string, contentType?: string, data?: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDepositStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerDepositApi - factory interface
 * @export
 */
export const CustomerDepositApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerDepositApiFp(configuration)
    return {
        /**
         * Create a new CustomerDeposit
         * @summary Create new CustomerDeposit
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject16} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDepositStore(accept?: string, contentType?: string, data?: InlineObject16, options?: any): AxiosPromise<InlineResponse2014> {
            return localVarFp.customerDepositStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for customerDepositStore operation in CustomerDepositApi.
 * @export
 * @interface CustomerDepositApiCustomerDepositStoreRequest
 */
export interface CustomerDepositApiCustomerDepositStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof CustomerDepositApiCustomerDepositStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof CustomerDepositApiCustomerDepositStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject16}
     * @memberof CustomerDepositApiCustomerDepositStore
     */
    readonly data?: InlineObject16
}

/**
 * CustomerDepositApi - object-oriented interface
 * @export
 * @class CustomerDepositApi
 * @extends {BaseAPI}
 */
export class CustomerDepositApi extends BaseAPI {
    /**
     * Create a new CustomerDeposit
     * @summary Create new CustomerDeposit
     * @param {CustomerDepositApiCustomerDepositStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerDepositApi
     */
    public customerDepositStore(requestParameters: CustomerDepositApiCustomerDepositStoreRequest = {}, options?: any) {
        return CustomerDepositApiFp(this.configuration).customerDepositStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiscountApi - axios parameter creator
 * @export
 */
export const DiscountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get discount that match the given discount code.
         * @summary Get discount by code
         * @param {string} code The discount activation code
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountGetByCode: async (code: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('discountGetByCode', 'code', code)
            const localVarPath = `/api/v1/discounts/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all public discounts.
         * @summary Get discounts
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterActivationCode] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountIndex: async (filterId?: string, filterName?: string, filterActivationCode?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/discounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterActivationCode !== undefined) {
                localVarQueryParameter['filter[activation_code]'] = filterActivationCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscountApi - functional programming interface
 * @export
 */
export const DiscountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscountApiAxiosParamCreator(configuration)
    return {
        /**
         * Get discount that match the given discount code.
         * @summary Get discount by code
         * @param {string} code The discount activation code
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountGetByCode(code: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20046>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountGetByCode(code, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all public discounts.
         * @summary Get discounts
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterActivationCode] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountIndex(filterId?: string, filterName?: string, filterActivationCode?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20045>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountIndex(filterId, filterName, filterActivationCode, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiscountApi - factory interface
 * @export
 */
export const DiscountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscountApiFp(configuration)
    return {
        /**
         * Get discount that match the given discount code.
         * @summary Get discount by code
         * @param {string} code The discount activation code
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountGetByCode(code: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20046> {
            return localVarFp.discountGetByCode(code, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all public discounts.
         * @summary Get discounts
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterActivationCode] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountIndex(filterId?: string, filterName?: string, filterActivationCode?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20045> {
            return localVarFp.discountIndex(filterId, filterName, filterActivationCode, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for discountGetByCode operation in DiscountApi.
 * @export
 * @interface DiscountApiDiscountGetByCodeRequest
 */
export interface DiscountApiDiscountGetByCodeRequest {
    /**
     * The discount activation code
     * @type {string}
     * @memberof DiscountApiDiscountGetByCode
     */
    readonly code: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof DiscountApiDiscountGetByCode
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof DiscountApiDiscountGetByCode
     */
    readonly contentType?: string
}

/**
 * Request parameters for discountIndex operation in DiscountApi.
 * @export
 * @interface DiscountApiDiscountIndexRequest
 */
export interface DiscountApiDiscountIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof DiscountApiDiscountIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof DiscountApiDiscountIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof DiscountApiDiscountIndex
     */
    readonly filterActivationCode?: string

    /**
     * 
     * @type {number}
     * @memberof DiscountApiDiscountIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof DiscountApiDiscountIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof DiscountApiDiscountIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof DiscountApiDiscountIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof DiscountApiDiscountIndex
     */
    readonly contentType?: string
}

/**
 * DiscountApi - object-oriented interface
 * @export
 * @class DiscountApi
 * @extends {BaseAPI}
 */
export class DiscountApi extends BaseAPI {
    /**
     * Get discount that match the given discount code.
     * @summary Get discount by code
     * @param {DiscountApiDiscountGetByCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public discountGetByCode(requestParameters: DiscountApiDiscountGetByCodeRequest, options?: any) {
        return DiscountApiFp(this.configuration).discountGetByCode(requestParameters.code, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all public discounts.
     * @summary Get discounts
     * @param {DiscountApiDiscountIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountApi
     */
    public discountIndex(requestParameters: DiscountApiDiscountIndexRequest = {}, options?: any) {
        return DiscountApiFp(this.configuration).discountIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.filterActivationCode, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InteriorDesignApi - axios parameter creator
 * @export
 */
export const InteriorDesignApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all InteriorDesigns available for this user
         * @summary Show all InteriorDesigns.
         * @param {string} [filterId] 
         * @param {number} [filterReligionId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interiorDesignIndex: async (filterId?: string, filterReligionId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/interior-designs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterReligionId !== undefined) {
                localVarQueryParameter['filter[religion_id]'] = filterReligionId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns InteriorDesign by id
         * @summary Get InteriorDesign
         * @param {string} interiorDesign 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interiorDesignShow: async (interiorDesign: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'interiorDesign' is not null or undefined
            assertParamExists('interiorDesignShow', 'interiorDesign', interiorDesign)
            const localVarPath = `/api/v1/interior-designs/{interior_design}`
                .replace(`{${"interior_design"}}`, encodeURIComponent(String(interiorDesign)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InteriorDesignApi - functional programming interface
 * @export
 */
export const InteriorDesignApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InteriorDesignApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all InteriorDesigns available for this user
         * @summary Show all InteriorDesigns.
         * @param {string} [filterId] 
         * @param {number} [filterReligionId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interiorDesignIndex(filterId?: string, filterReligionId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interiorDesignIndex(filterId, filterReligionId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns InteriorDesign by id
         * @summary Get InteriorDesign
         * @param {string} interiorDesign 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interiorDesignShow(interiorDesign: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interiorDesignShow(interiorDesign, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InteriorDesignApi - factory interface
 * @export
 */
export const InteriorDesignApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InteriorDesignApiFp(configuration)
    return {
        /**
         * Show all InteriorDesigns available for this user
         * @summary Show all InteriorDesigns.
         * @param {string} [filterId] 
         * @param {number} [filterReligionId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interiorDesignIndex(filterId?: string, filterReligionId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.interiorDesignIndex(filterId, filterReligionId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns InteriorDesign by id
         * @summary Get InteriorDesign
         * @param {string} interiorDesign 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interiorDesignShow(interiorDesign: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.interiorDesignShow(interiorDesign, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for interiorDesignIndex operation in InteriorDesignApi.
 * @export
 * @interface InteriorDesignApiInteriorDesignIndexRequest
 */
export interface InteriorDesignApiInteriorDesignIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof InteriorDesignApiInteriorDesignIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof InteriorDesignApiInteriorDesignIndex
     */
    readonly filterReligionId?: number

    /**
     * 
     * @type {string}
     * @memberof InteriorDesignApiInteriorDesignIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof InteriorDesignApiInteriorDesignIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof InteriorDesignApiInteriorDesignIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof InteriorDesignApiInteriorDesignIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof InteriorDesignApiInteriorDesignIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof InteriorDesignApiInteriorDesignIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for interiorDesignShow operation in InteriorDesignApi.
 * @export
 * @interface InteriorDesignApiInteriorDesignShowRequest
 */
export interface InteriorDesignApiInteriorDesignShowRequest {
    /**
     * 
     * @type {string}
     * @memberof InteriorDesignApiInteriorDesignShow
     */
    readonly interiorDesign: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof InteriorDesignApiInteriorDesignShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof InteriorDesignApiInteriorDesignShow
     */
    readonly contentType?: string
}

/**
 * InteriorDesignApi - object-oriented interface
 * @export
 * @class InteriorDesignApi
 * @extends {BaseAPI}
 */
export class InteriorDesignApi extends BaseAPI {
    /**
     * Show all InteriorDesigns available for this user
     * @summary Show all InteriorDesigns.
     * @param {InteriorDesignApiInteriorDesignIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteriorDesignApi
     */
    public interiorDesignIndex(requestParameters: InteriorDesignApiInteriorDesignIndexRequest = {}, options?: any) {
        return InteriorDesignApiFp(this.configuration).interiorDesignIndex(requestParameters.filterId, requestParameters.filterReligionId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns InteriorDesign by id
     * @summary Get InteriorDesign
     * @param {InteriorDesignApiInteriorDesignShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteriorDesignApi
     */
    public interiorDesignShow(requestParameters: InteriorDesignApiInteriorDesignShowRequest, options?: any) {
        return InteriorDesignApiFp(this.configuration).interiorDesignShow(requestParameters.interiorDesign, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LeadApi - axios parameter creator
 * @export
 */
export const LeadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @summary Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @param {string} userId 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityReport: async (userId: string, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('activityReport', 'userId', userId)
            const localVarPath = `/api/v1/activities/report/detail/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all leads of a given customer
         * @summary Show all leads of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetLeads: async (customer: number, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerGetLeads', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}/leads`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns order deals by lead id
         * @summary Get order deals
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsleadSms: async (id: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dealsleadSms', 'id', id)
            const localVarPath = `/api/v1/leads/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign an unhandled lead
         * @summary Assign an unhandled lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject9} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadAssign: async (lead: string, accept?: string, contentType?: string, data?: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadAssign', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}/assign`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all lead categories.
         * @summary Show all lead categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadCategories: async (filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a lead by its id
         * @summary Delete Lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadDestroy: async (lead: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadDestroy', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadIndex: async (filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns lead by id
         * @summary Get lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadShow: async (lead: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadShow', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all sms user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadSms: async (filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/sms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Lead. Currently only sales are allowed to perform this action. This is because lead must be related to a sales. If we want to allow supervisor to add a new lead, they must pick which sales to assign this sales to (which is not supported yet).
         * @summary Create new Lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject10} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadStore: async (accept?: string, contentType?: string, data?: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Lead SMS. Currently only sales are allowed to perform this action. This is because lead must be related to a sales.
         * @summary Create new Lead SMS
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject7} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadStoreSms: async (accept?: string, contentType?: string, data?: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint only returns unhandled leads that the authenticated user is able to assign to. (i.e., sales will not be able to see any unhandled leads)
         * @summary Show all unhandled leads.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUnhandledIndex: async (filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/unhandled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given lead
         * @summary Update a lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject11} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUpdate: async (lead: string, accept?: string, contentType?: string, data?: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadUpdate', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given lead SMS
         * @summary Update a lead SMS
         * @param {number} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject8} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUpdateSms: async (id: number, accept?: string, contentType?: string, data?: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leadUpdateSms', 'id', id)
            const localVarPath = `/api/v1/leads/update/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns lead sms by id
         * @summary Get lead sms
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showleadSms: async (id: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showleadSms', 'id', id)
            const localVarPath = `/api/v1/leads/sms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sub lead categories.
         * @summary Get sub lead categories.
         * @param {string} leadCategory 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subLeadCategories: async (leadCategory: string, filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leadCategory' is not null or undefined
            assertParamExists('subLeadCategories', 'leadCategory', leadCategory)
            const localVarPath = `/api/v1/leads/sub-categories/{leadCategory}`
                .replace(`{${"leadCategory"}}`, encodeURIComponent(String(leadCategory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadApi - functional programming interface
 * @export
 */
export const LeadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeadApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @summary Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @param {string} userId 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityReport(userId: string, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityReport(userId, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all leads of a given customer
         * @summary Show all leads of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGetLeads(customer: number, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGetLeads(customer, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns order deals by lead id
         * @summary Get order deals
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dealsleadSms(id: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dealsleadSms(id, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assign an unhandled lead
         * @summary Assign an unhandled lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject9} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadAssign(lead: string, accept?: string, contentType?: string, data?: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadAssign(lead, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all lead categories.
         * @summary Show all lead categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadCategories(filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadCategories(filterId, filterName, filterDescription, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a lead by its id
         * @summary Delete Lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadDestroy(lead: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadDestroy(lead, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadIndex(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadIndex(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns lead by id
         * @summary Get lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadShow(lead: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadShow(lead, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all sms user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadSms(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadSms(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Lead. Currently only sales are allowed to perform this action. This is because lead must be related to a sales. If we want to allow supervisor to add a new lead, they must pick which sales to assign this sales to (which is not supported yet).
         * @summary Create new Lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject10} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadStore(accept?: string, contentType?: string, data?: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Lead SMS. Currently only sales are allowed to perform this action. This is because lead must be related to a sales.
         * @summary Create new Lead SMS
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject7} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadStoreSms(accept?: string, contentType?: string, data?: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadStoreSms(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint only returns unhandled leads that the authenticated user is able to assign to. (i.e., sales will not be able to see any unhandled leads)
         * @summary Show all unhandled leads.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadUnhandledIndex(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadUnhandledIndex(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given lead
         * @summary Update a lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject11} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadUpdate(lead: string, accept?: string, contentType?: string, data?: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadUpdate(lead, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given lead SMS
         * @summary Update a lead SMS
         * @param {number} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject8} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadUpdateSms(id: number, accept?: string, contentType?: string, data?: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadUpdateSms(id, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns lead sms by id
         * @summary Get lead sms
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showleadSms(id: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showleadSms(id, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sub lead categories.
         * @summary Get sub lead categories.
         * @param {string} leadCategory 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subLeadCategories(leadCategory: string, filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subLeadCategories(leadCategory, filterId, filterName, filterDescription, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LeadApi - factory interface
 * @export
 */
export const LeadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeadApiFp(configuration)
    return {
        /**
         * Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @summary Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @param {string} userId 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityReport(userId: string, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.activityReport(userId, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all leads of a given customer
         * @summary Show all leads of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetLeads(customer: number, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.customerGetLeads(customer, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns order deals by lead id
         * @summary Get order deals
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsleadSms(id: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.dealsleadSms(id, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign an unhandled lead
         * @summary Assign an unhandled lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject9} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadAssign(lead: string, accept?: string, contentType?: string, data?: InlineObject9, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.leadAssign(lead, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all lead categories.
         * @summary Show all lead categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadCategories(filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.leadCategories(filterId, filterName, filterDescription, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a lead by its id
         * @summary Delete Lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadDestroy(lead: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.leadDestroy(lead, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadIndex(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.leadIndex(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns lead by id
         * @summary Get lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadShow(lead: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.leadShow(lead, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all sms user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadSms(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.leadSms(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Lead. Currently only sales are allowed to perform this action. This is because lead must be related to a sales. If we want to allow supervisor to add a new lead, they must pick which sales to assign this sales to (which is not supported yet).
         * @summary Create new Lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject10} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadStore(accept?: string, contentType?: string, data?: InlineObject10, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.leadStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Lead SMS. Currently only sales are allowed to perform this action. This is because lead must be related to a sales.
         * @summary Create new Lead SMS
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject7} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadStoreSms(accept?: string, contentType?: string, data?: InlineObject7, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.leadStoreSms(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint only returns unhandled leads that the authenticated user is able to assign to. (i.e., sales will not be able to see any unhandled leads)
         * @summary Show all unhandled leads.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUnhandledIndex(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.leadUnhandledIndex(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given lead
         * @summary Update a lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject11} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUpdate(lead: string, accept?: string, contentType?: string, data?: InlineObject11, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.leadUpdate(lead, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given lead SMS
         * @summary Update a lead SMS
         * @param {number} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject8} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUpdateSms(id: number, accept?: string, contentType?: string, data?: InlineObject8, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.leadUpdateSms(id, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns lead sms by id
         * @summary Get lead sms
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showleadSms(id: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.showleadSms(id, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sub lead categories.
         * @summary Get sub lead categories.
         * @param {string} leadCategory 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subLeadCategories(leadCategory: string, filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20023> {
            return localVarFp.subLeadCategories(leadCategory, filterId, filterName, filterDescription, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activityReport operation in LeadApi.
 * @export
 * @interface LeadApiActivityReportRequest
 */
export interface LeadApiActivityReportRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiActivityReport
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof LeadApiActivityReport
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof LeadApiActivityReport
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiActivityReport
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiActivityReport
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiActivityReport
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiActivityReport
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiActivityReport
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof LeadApiActivityReport
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiActivityReport
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiActivityReport
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerGetLeads operation in LeadApi.
 * @export
 * @interface LeadApiCustomerGetLeadsRequest
 */
export interface LeadApiCustomerGetLeadsRequest {
    /**
     * 
     * @type {number}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly customer: number

    /**
     * 
     * @type {string}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiCustomerGetLeads
     */
    readonly contentType?: string
}

/**
 * Request parameters for dealsleadSms operation in LeadApi.
 * @export
 * @interface LeadApiDealsleadSmsRequest
 */
export interface LeadApiDealsleadSmsRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiDealsleadSms
     */
    readonly id: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiDealsleadSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiDealsleadSms
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadAssign operation in LeadApi.
 * @export
 * @interface LeadApiLeadAssignRequest
 */
export interface LeadApiLeadAssignRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadAssign
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadAssign
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadAssign
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject9}
     * @memberof LeadApiLeadAssign
     */
    readonly data?: InlineObject9
}

/**
 * Request parameters for leadCategories operation in LeadApi.
 * @export
 * @interface LeadApiLeadCategoriesRequest
 */
export interface LeadApiLeadCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadCategories
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadCategories
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadCategories
     */
    readonly filterDescription?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadCategories
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadCategories
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof LeadApiLeadCategories
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadCategories
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadCategories
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadDestroy operation in LeadApi.
 * @export
 * @interface LeadApiLeadDestroyRequest
 */
export interface LeadApiLeadDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadDestroy
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadIndex operation in LeadApi.
 * @export
 * @interface LeadApiLeadIndexRequest
 */
export interface LeadApiLeadIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadIndex
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof LeadApiLeadIndex
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof LeadApiLeadIndex
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadIndex
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadIndex
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadIndex
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadIndex
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadIndex
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadIndex
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadIndex
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiLeadIndex
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiLeadIndex
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiLeadIndex
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof LeadApiLeadIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadShow operation in LeadApi.
 * @export
 * @interface LeadApiLeadShowRequest
 */
export interface LeadApiLeadShowRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadShow
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadSms operation in LeadApi.
 * @export
 * @interface LeadApiLeadSmsRequest
 */
export interface LeadApiLeadSmsRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadSms
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadSms
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof LeadApiLeadSms
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof LeadApiLeadSms
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadSms
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadSms
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadSms
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadSms
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadSms
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadSms
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadSms
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiLeadSms
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiLeadSms
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiLeadSms
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadSms
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadSms
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof LeadApiLeadSms
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadSms
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadStore operation in LeadApi.
 * @export
 * @interface LeadApiLeadStoreRequest
 */
export interface LeadApiLeadStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject10}
     * @memberof LeadApiLeadStore
     */
    readonly data?: InlineObject10
}

/**
 * Request parameters for leadStoreSms operation in LeadApi.
 * @export
 * @interface LeadApiLeadStoreSmsRequest
 */
export interface LeadApiLeadStoreSmsRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadStoreSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadStoreSms
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject7}
     * @memberof LeadApiLeadStoreSms
     */
    readonly data?: InlineObject7
}

/**
 * Request parameters for leadUnhandledIndex operation in LeadApi.
 * @export
 * @interface LeadApiLeadUnhandledIndexRequest
 */
export interface LeadApiLeadUnhandledIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadUnhandledIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadUpdate operation in LeadApi.
 * @export
 * @interface LeadApiLeadUpdateRequest
 */
export interface LeadApiLeadUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiLeadUpdate
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject11}
     * @memberof LeadApiLeadUpdate
     */
    readonly data?: InlineObject11
}

/**
 * Request parameters for leadUpdateSms operation in LeadApi.
 * @export
 * @interface LeadApiLeadUpdateSmsRequest
 */
export interface LeadApiLeadUpdateSmsRequest {
    /**
     * 
     * @type {number}
     * @memberof LeadApiLeadUpdateSms
     */
    readonly id: number

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiLeadUpdateSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiLeadUpdateSms
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject8}
     * @memberof LeadApiLeadUpdateSms
     */
    readonly data?: InlineObject8
}

/**
 * Request parameters for showleadSms operation in LeadApi.
 * @export
 * @interface LeadApiShowleadSmsRequest
 */
export interface LeadApiShowleadSmsRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiShowleadSms
     */
    readonly id: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiShowleadSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiShowleadSms
     */
    readonly contentType?: string
}

/**
 * Request parameters for subLeadCategories operation in LeadApi.
 * @export
 * @interface LeadApiSubLeadCategoriesRequest
 */
export interface LeadApiSubLeadCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof LeadApiSubLeadCategories
     */
    readonly leadCategory: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiSubLeadCategories
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiSubLeadCategories
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof LeadApiSubLeadCategories
     */
    readonly filterDescription?: string

    /**
     * 
     * @type {number}
     * @memberof LeadApiSubLeadCategories
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof LeadApiSubLeadCategories
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof LeadApiSubLeadCategories
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof LeadApiSubLeadCategories
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof LeadApiSubLeadCategories
     */
    readonly contentType?: string
}

/**
 * LeadApi - object-oriented interface
 * @export
 * @class LeadApi
 * @extends {BaseAPI}
 */
export class LeadApi extends BaseAPI {
    /**
     * Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
     * @summary Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
     * @param {LeadApiActivityReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public activityReport(requestParameters: LeadApiActivityReportRequest, options?: any) {
        return LeadApiFp(this.configuration).activityReport(requestParameters.userId, requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all leads of a given customer
     * @summary Show all leads of a customer.
     * @param {LeadApiCustomerGetLeadsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public customerGetLeads(requestParameters: LeadApiCustomerGetLeadsRequest, options?: any) {
        return LeadApiFp(this.configuration).customerGetLeads(requestParameters.customer, requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns order deals by lead id
     * @summary Get order deals
     * @param {LeadApiDealsleadSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public dealsleadSms(requestParameters: LeadApiDealsleadSmsRequest, options?: any) {
        return LeadApiFp(this.configuration).dealsleadSms(requestParameters.id, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign an unhandled lead
     * @summary Assign an unhandled lead
     * @param {LeadApiLeadAssignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadAssign(requestParameters: LeadApiLeadAssignRequest, options?: any) {
        return LeadApiFp(this.configuration).leadAssign(requestParameters.lead, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all lead categories.
     * @summary Show all lead categories.
     * @param {LeadApiLeadCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadCategories(requestParameters: LeadApiLeadCategoriesRequest = {}, options?: any) {
        return LeadApiFp(this.configuration).leadCategories(requestParameters.filterId, requestParameters.filterName, requestParameters.filterDescription, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a lead by its id
     * @summary Delete Lead
     * @param {LeadApiLeadDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadDestroy(requestParameters: LeadApiLeadDestroyRequest, options?: any) {
        return LeadApiFp(this.configuration).leadDestroy(requestParameters.lead, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
     * @summary Show all user\'s lead.
     * @param {LeadApiLeadIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadIndex(requestParameters: LeadApiLeadIndexRequest = {}, options?: any) {
        return LeadApiFp(this.configuration).leadIndex(requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns lead by id
     * @summary Get lead
     * @param {LeadApiLeadShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadShow(requestParameters: LeadApiLeadShowRequest, options?: any) {
        return LeadApiFp(this.configuration).leadShow(requestParameters.lead, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
     * @summary Show all sms user\'s lead.
     * @param {LeadApiLeadSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadSms(requestParameters: LeadApiLeadSmsRequest = {}, options?: any) {
        return LeadApiFp(this.configuration).leadSms(requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Lead. Currently only sales are allowed to perform this action. This is because lead must be related to a sales. If we want to allow supervisor to add a new lead, they must pick which sales to assign this sales to (which is not supported yet).
     * @summary Create new Lead
     * @param {LeadApiLeadStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadStore(requestParameters: LeadApiLeadStoreRequest = {}, options?: any) {
        return LeadApiFp(this.configuration).leadStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Lead SMS. Currently only sales are allowed to perform this action. This is because lead must be related to a sales.
     * @summary Create new Lead SMS
     * @param {LeadApiLeadStoreSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadStoreSms(requestParameters: LeadApiLeadStoreSmsRequest = {}, options?: any) {
        return LeadApiFp(this.configuration).leadStoreSms(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint only returns unhandled leads that the authenticated user is able to assign to. (i.e., sales will not be able to see any unhandled leads)
     * @summary Show all unhandled leads.
     * @param {LeadApiLeadUnhandledIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadUnhandledIndex(requestParameters: LeadApiLeadUnhandledIndexRequest = {}, options?: any) {
        return LeadApiFp(this.configuration).leadUnhandledIndex(requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given lead
     * @summary Update a lead
     * @param {LeadApiLeadUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadUpdate(requestParameters: LeadApiLeadUpdateRequest, options?: any) {
        return LeadApiFp(this.configuration).leadUpdate(requestParameters.lead, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given lead SMS
     * @summary Update a lead SMS
     * @param {LeadApiLeadUpdateSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public leadUpdateSms(requestParameters: LeadApiLeadUpdateSmsRequest, options?: any) {
        return LeadApiFp(this.configuration).leadUpdateSms(requestParameters.id, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns lead sms by id
     * @summary Get lead sms
     * @param {LeadApiShowleadSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public showleadSms(requestParameters: LeadApiShowleadSmsRequest, options?: any) {
        return LeadApiFp(this.configuration).showleadSms(requestParameters.id, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sub lead categories.
     * @summary Get sub lead categories.
     * @param {LeadApiSubLeadCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadApi
     */
    public subLeadCategories(requestParameters: LeadApiSubLeadCategoriesRequest, options?: any) {
        return LeadApiFp(this.configuration).subLeadCategories(requestParameters.leadCategory, requestParameters.filterId, requestParameters.filterName, requestParameters.filterDescription, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This will cancel an order.
         * @summary Cancel an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCancel: async (order: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderCancel', 'order', order)
            const localVarPath = `/api/v1/orders/cancel/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will clone and cancel a given order. Newly cloned order will be returned as response.
         * @summary Clone an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject27} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClone: async (order: string, accept?: string, contentType?: string, data?: InlineObject27, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderClone', 'order', order)
            const localVarPath = `/api/v1/orders/clone/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all order
         * @summary Show all order.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIndex: async (filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterSearch !== undefined) {
                localVarQueryParameter['filter[search]'] = filterSearch;
            }

            if (filterInvoiceNumber !== undefined) {
                localVarQueryParameter['filter[invoice_number]'] = filterInvoiceNumber;
            }

            if (filterApprovalStatus !== undefined) {
                localVarQueryParameter['filter[approval_status]'] = filterApprovalStatus;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint only return orders that can be approved by the authenticated user.
         * @summary Show all orders waiting for approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIndexWaitingApproval: async (filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/waiting-approval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterSearch !== undefined) {
                localVarQueryParameter['filter[search]'] = filterSearch;
            }

            if (filterInvoiceNumber !== undefined) {
                localVarQueryParameter['filter[invoice_number]'] = filterInvoiceNumber;
            }

            if (filterApprovalStatus !== undefined) {
                localVarQueryParameter['filter[approval_status]'] = filterApprovalStatus;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint return approval discount orders that related with the authenticated user.
         * @summary Show all orders approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderListApproval: async (filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/list-approval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterSearch !== undefined) {
                localVarQueryParameter['filter[search]'] = filterSearch;
            }

            if (filterInvoiceNumber !== undefined) {
                localVarQueryParameter['filter[invoice_number]'] = filterInvoiceNumber;
            }

            if (filterApprovalStatus !== undefined) {
                localVarQueryParameter['filter[approval_status]'] = filterApprovalStatus;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a dummy order for preview purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject23} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPreview: async (accept?: string, contentType?: string, data?: InlineObject23, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a dummy order for preview update purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview update
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject24} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPreviewUpdate: async (order: string, accept?: string, contentType?: string, data?: InlineObject24, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderPreviewUpdate', 'order', order)
            const localVarPath = `/api/v1/orders/preview-update/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request Approve order
         * @summary Request Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject26} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRequestApprove: async (order: string, accept?: string, contentType?: string, data?: InlineObject26, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderRequestApprove', 'order', order)
            const localVarPath = `/api/v1/orders/request-approval/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns order by id
         * @summary Get order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShow: async (order: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderShow', 'order', order)
            const localVarPath = `/api/v1/orders/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new order
         * @summary Create new Order
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject28} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderStore: async (accept?: string, contentType?: string, data?: InlineObject28, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an order
         * @summary Update an Order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject29} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderUpdate: async (order: string, accept?: string, contentType?: string, data?: InlineObject29, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderUpdate', 'order', order)
            const localVarPath = `/api/v1/orders/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * This will cancel an order.
         * @summary Cancel an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderCancel(order: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderCancel(order, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will clone and cancel a given order. Newly cloned order will be returned as response.
         * @summary Clone an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject27} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderClone(order: string, accept?: string, contentType?: string, data?: InlineObject27, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderClone(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all order
         * @summary Show all order.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderIndex(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderIndex(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint only return orders that can be approved by the authenticated user.
         * @summary Show all orders waiting for approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderIndexWaitingApproval(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderIndexWaitingApproval(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint return approval discount orders that related with the authenticated user.
         * @summary Show all orders approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderListApproval(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderListApproval(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a dummy order for preview purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject23} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderPreview(accept?: string, contentType?: string, data?: InlineObject23, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderPreview(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a dummy order for preview update purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview update
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject24} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderPreviewUpdate(order: string, accept?: string, contentType?: string, data?: InlineObject24, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderPreviewUpdate(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request Approve order
         * @summary Request Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject26} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderRequestApprove(order: string, accept?: string, contentType?: string, data?: InlineObject26, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderRequestApprove(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns order by id
         * @summary Get order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderShow(order: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderShow(order, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new order
         * @summary Create new Order
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject28} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderStore(accept?: string, contentType?: string, data?: InlineObject28, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an order
         * @summary Update an Order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject29} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderUpdate(order: string, accept?: string, contentType?: string, data?: InlineObject29, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderUpdate(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * This will cancel an order.
         * @summary Cancel an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCancel(order: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderCancel(order, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * This will clone and cancel a given order. Newly cloned order will be returned as response.
         * @summary Clone an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject27} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClone(order: string, accept?: string, contentType?: string, data?: InlineObject27, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderClone(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all order
         * @summary Show all order.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIndex(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20048> {
            return localVarFp.orderIndex(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint only return orders that can be approved by the authenticated user.
         * @summary Show all orders waiting for approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIndexWaitingApproval(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20048> {
            return localVarFp.orderIndexWaitingApproval(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint return approval discount orders that related with the authenticated user.
         * @summary Show all orders approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderListApproval(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20048> {
            return localVarFp.orderListApproval(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a dummy order for preview purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject23} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPreview(accept?: string, contentType?: string, data?: InlineObject23, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderPreview(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a dummy order for preview update purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview update
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject24} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPreviewUpdate(order: string, accept?: string, contentType?: string, data?: InlineObject24, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderPreviewUpdate(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Request Approve order
         * @summary Request Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject26} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRequestApprove(order: string, accept?: string, contentType?: string, data?: InlineObject26, options?: any): AxiosPromise<void> {
            return localVarFp.orderRequestApprove(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns order by id
         * @summary Get order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShow(order: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderShow(order, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new order
         * @summary Create new Order
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject28} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderStore(accept?: string, contentType?: string, data?: InlineObject28, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an order
         * @summary Update an Order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject29} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderUpdate(order: string, accept?: string, contentType?: string, data?: InlineObject29, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderUpdate(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orderCancel operation in OrderApi.
 * @export
 * @interface OrderApiOrderCancelRequest
 */
export interface OrderApiOrderCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderCancel
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderCancel
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderCancel
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderClone operation in OrderApi.
 * @export
 * @interface OrderApiOrderCloneRequest
 */
export interface OrderApiOrderCloneRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderClone
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderClone
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderClone
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject27}
     * @memberof OrderApiOrderClone
     */
    readonly data?: InlineObject27
}

/**
 * Request parameters for orderIndex operation in OrderApi.
 * @export
 * @interface OrderApiOrderIndexRequest
 */
export interface OrderApiOrderIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderIndex
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderIndex
     */
    readonly filterSearch?: string

    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderIndex
     */
    readonly filterInvoiceNumber?: string

    /**
     * 
     * @type {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'}
     * @memberof OrderApiOrderIndex
     */
    readonly filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'

    /**
     * 
     * @type {number}
     * @memberof OrderApiOrderIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrderApiOrderIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof OrderApiOrderIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderIndexWaitingApproval operation in OrderApi.
 * @export
 * @interface OrderApiOrderIndexWaitingApprovalRequest
 */
export interface OrderApiOrderIndexWaitingApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly filterSearch?: string

    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly filterInvoiceNumber?: string

    /**
     * 
     * @type {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'

    /**
     * 
     * @type {number}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderIndexWaitingApproval
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderListApproval operation in OrderApi.
 * @export
 * @interface OrderApiOrderListApprovalRequest
 */
export interface OrderApiOrderListApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderListApproval
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderListApproval
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderListApproval
     */
    readonly filterSearch?: string

    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderListApproval
     */
    readonly filterInvoiceNumber?: string

    /**
     * 
     * @type {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'}
     * @memberof OrderApiOrderListApproval
     */
    readonly filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'

    /**
     * 
     * @type {number}
     * @memberof OrderApiOrderListApproval
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrderApiOrderListApproval
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof OrderApiOrderListApproval
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderListApproval
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderListApproval
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderPreview operation in OrderApi.
 * @export
 * @interface OrderApiOrderPreviewRequest
 */
export interface OrderApiOrderPreviewRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderPreview
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderPreview
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject23}
     * @memberof OrderApiOrderPreview
     */
    readonly data?: InlineObject23
}

/**
 * Request parameters for orderPreviewUpdate operation in OrderApi.
 * @export
 * @interface OrderApiOrderPreviewUpdateRequest
 */
export interface OrderApiOrderPreviewUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderPreviewUpdate
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderPreviewUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderPreviewUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject24}
     * @memberof OrderApiOrderPreviewUpdate
     */
    readonly data?: InlineObject24
}

/**
 * Request parameters for orderRequestApprove operation in OrderApi.
 * @export
 * @interface OrderApiOrderRequestApproveRequest
 */
export interface OrderApiOrderRequestApproveRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderRequestApprove
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderRequestApprove
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderRequestApprove
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject26}
     * @memberof OrderApiOrderRequestApprove
     */
    readonly data?: InlineObject26
}

/**
 * Request parameters for orderShow operation in OrderApi.
 * @export
 * @interface OrderApiOrderShowRequest
 */
export interface OrderApiOrderShowRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderShow
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderStore operation in OrderApi.
 * @export
 * @interface OrderApiOrderStoreRequest
 */
export interface OrderApiOrderStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject28}
     * @memberof OrderApiOrderStore
     */
    readonly data?: InlineObject28
}

/**
 * Request parameters for orderUpdate operation in OrderApi.
 * @export
 * @interface OrderApiOrderUpdateRequest
 */
export interface OrderApiOrderUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderApiOrderUpdate
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderApiOrderUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderApiOrderUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject29}
     * @memberof OrderApiOrderUpdate
     */
    readonly data?: InlineObject29
}

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * This will cancel an order.
     * @summary Cancel an order
     * @param {OrderApiOrderCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderCancel(requestParameters: OrderApiOrderCancelRequest, options?: any) {
        return OrderApiFp(this.configuration).orderCancel(requestParameters.order, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will clone and cancel a given order. Newly cloned order will be returned as response.
     * @summary Clone an order
     * @param {OrderApiOrderCloneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderClone(requestParameters: OrderApiOrderCloneRequest, options?: any) {
        return OrderApiFp(this.configuration).orderClone(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all order
     * @summary Show all order.
     * @param {OrderApiOrderIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderIndex(requestParameters: OrderApiOrderIndexRequest = {}, options?: any) {
        return OrderApiFp(this.configuration).orderIndex(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterSearch, requestParameters.filterInvoiceNumber, requestParameters.filterApprovalStatus, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint only return orders that can be approved by the authenticated user.
     * @summary Show all orders waiting for approval
     * @param {OrderApiOrderIndexWaitingApprovalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderIndexWaitingApproval(requestParameters: OrderApiOrderIndexWaitingApprovalRequest = {}, options?: any) {
        return OrderApiFp(this.configuration).orderIndexWaitingApproval(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterSearch, requestParameters.filterInvoiceNumber, requestParameters.filterApprovalStatus, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint return approval discount orders that related with the authenticated user.
     * @summary Show all orders approval
     * @param {OrderApiOrderListApprovalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderListApproval(requestParameters: OrderApiOrderListApprovalRequest = {}, options?: any) {
        return OrderApiFp(this.configuration).orderListApproval(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterSearch, requestParameters.filterInvoiceNumber, requestParameters.filterApprovalStatus, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a dummy order for preview purposes. Use this endpoint to check how the order will look like with the discount applied.
     * @summary Order preview
     * @param {OrderApiOrderPreviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderPreview(requestParameters: OrderApiOrderPreviewRequest = {}, options?: any) {
        return OrderApiFp(this.configuration).orderPreview(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a dummy order for preview update purposes. Use this endpoint to check how the order will look like with the discount applied.
     * @summary Order preview update
     * @param {OrderApiOrderPreviewUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderPreviewUpdate(requestParameters: OrderApiOrderPreviewUpdateRequest, options?: any) {
        return OrderApiFp(this.configuration).orderPreviewUpdate(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request Approve order
     * @summary Request Approve order
     * @param {OrderApiOrderRequestApproveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderRequestApprove(requestParameters: OrderApiOrderRequestApproveRequest, options?: any) {
        return OrderApiFp(this.configuration).orderRequestApprove(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns order by id
     * @summary Get order
     * @param {OrderApiOrderShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderShow(requestParameters: OrderApiOrderShowRequest, options?: any) {
        return OrderApiFp(this.configuration).orderShow(requestParameters.order, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new order
     * @summary Create new Order
     * @param {OrderApiOrderStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderStore(requestParameters: OrderApiOrderStoreRequest = {}, options?: any) {
        return OrderApiFp(this.configuration).orderStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an order
     * @summary Update an Order
     * @param {OrderApiOrderUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderUpdate(requestParameters: OrderApiOrderUpdateRequest, options?: any) {
        return OrderApiFp(this.configuration).orderUpdate(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderDetailApi - axios parameter creator
 * @export
 */
export const OrderDetailApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} orderDetail 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody2} [imageRequestBody2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetail: async (orderDetail: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody2?: ImageRequestBody2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderDetail' is not null or undefined
            assertParamExists('orderDetail', 'orderDetail', orderDetail)
            const localVarPath = `/api/v1/order-details/{orderDetail}/upload`
                .replace(`{${"orderDetail"}}`, encodeURIComponent(String(orderDetail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequestBody2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns orderDetail by id
         * @summary Get orderDetail
         * @param {string} orderDetail 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailShow: async (orderDetail: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderDetail' is not null or undefined
            assertParamExists('orderDetailShow', 'orderDetail', orderDetail)
            const localVarPath = `/api/v1/order-details/{order_detail}`
                .replace(`{${"order_detail"}}`, encodeURIComponent(String(orderDetail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderDetailApi - functional programming interface
 * @export
 */
export const OrderDetailApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderDetailApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} orderDetail 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody2} [imageRequestBody2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDetail(orderDetail: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody2?: ImageRequestBody2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDetail(orderDetail, filterId, page, perPage, sort, accept, contentType, imageRequestBody2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns orderDetail by id
         * @summary Get orderDetail
         * @param {string} orderDetail 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDetailShow(orderDetail: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20049>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDetailShow(orderDetail, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderDetailApi - factory interface
 * @export
 */
export const OrderDetailApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderDetailApiFp(configuration)
    return {
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} orderDetail 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody2} [imageRequestBody2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetail(orderDetail: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody2?: ImageRequestBody2, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.orderDetail(orderDetail, filterId, page, perPage, sort, accept, contentType, imageRequestBody2, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns orderDetail by id
         * @summary Get orderDetail
         * @param {string} orderDetail 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailShow(orderDetail: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20049> {
            return localVarFp.orderDetailShow(orderDetail, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orderDetail operation in OrderDetailApi.
 * @export
 * @interface OrderDetailApiOrderDetailRequest
 */
export interface OrderDetailApiOrderDetailRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailApiOrderDetail
     */
    readonly orderDetail: string

    /**
     * 
     * @type {string}
     * @memberof OrderDetailApiOrderDetail
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof OrderDetailApiOrderDetail
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrderDetailApiOrderDetail
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof OrderDetailApiOrderDetail
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderDetailApiOrderDetail
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderDetailApiOrderDetail
     */
    readonly contentType?: string

    /**
     * 
     * @type {ImageRequestBody2}
     * @memberof OrderDetailApiOrderDetail
     */
    readonly imageRequestBody2?: ImageRequestBody2
}

/**
 * Request parameters for orderDetailShow operation in OrderDetailApi.
 * @export
 * @interface OrderDetailApiOrderDetailShowRequest
 */
export interface OrderDetailApiOrderDetailShowRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailApiOrderDetailShow
     */
    readonly orderDetail: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof OrderDetailApiOrderDetailShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof OrderDetailApiOrderDetailShow
     */
    readonly contentType?: string
}

/**
 * OrderDetailApi - object-oriented interface
 * @export
 * @class OrderDetailApi
 * @extends {BaseAPI}
 */
export class OrderDetailApi extends BaseAPI {
    /**
     * Upload order detail product unit image
     * @summary Upload order detail product unit image
     * @param {OrderDetailApiOrderDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderDetailApi
     */
    public orderDetail(requestParameters: OrderDetailApiOrderDetailRequest, options?: any) {
        return OrderDetailApiFp(this.configuration).orderDetail(requestParameters.orderDetail, requestParameters.filterId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, requestParameters.imageRequestBody2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns orderDetail by id
     * @summary Get orderDetail
     * @param {OrderDetailApiOrderDetailShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderDetailApi
     */
    public orderDetailShow(requestParameters: OrderDetailApiOrderDetailShowRequest, options?: any) {
        return OrderDetailApiFp(this.configuration).orderDetailShow(requestParameters.orderDetail, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all payment category
         * @summary Show all payment category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCategoryIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payment-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all payment
         * @summary Show all payment.
         * @param {string} [filterId] 
         * @param {number} [filterAmount] 
         * @param {string} [filterReference] 
         * @param {'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'} [filterStatus] 
         * @param {string} [filterPaymentTypeId] 
         * @param {string} [filterAddedById] 
         * @param {string} [filterApprovedById] 
         * @param {string} [filterOrderId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIndex: async (filterId?: string, filterAmount?: number, filterReference?: string, filterStatus?: 'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT', filterPaymentTypeId?: string, filterAddedById?: string, filterApprovedById?: string, filterOrderId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterAmount !== undefined) {
                localVarQueryParameter['filter[amount]'] = filterAmount;
            }

            if (filterReference !== undefined) {
                localVarQueryParameter['filter[reference]'] = filterReference;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterPaymentTypeId !== undefined) {
                localVarQueryParameter['filter[payment_type_id]'] = filterPaymentTypeId;
            }

            if (filterAddedById !== undefined) {
                localVarQueryParameter['filter[added_by_id]'] = filterAddedById;
            }

            if (filterApprovedById !== undefined) {
                localVarQueryParameter['filter[approved_by_id]'] = filterApprovedById;
            }

            if (filterOrderId !== undefined) {
                localVarQueryParameter['filter[order_id]'] = filterOrderId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload proof of payment
         * @summary Upload proof of payment
         * @param {string} payment 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody3} [imageRequestBody3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentProofUpload: async (payment: string, filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody3?: ImageRequestBody3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('paymentProofUpload', 'payment', payment)
            const localVarPath = `/api/v1/payments/{payment}/proof`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequestBody3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns payment by id
         * @summary Get payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentShow: async (payment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('paymentShow', 'payment', payment)
            const localVarPath = `/api/v1/payments/{payment}`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new payment
         * @summary Create new Payment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject30} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentStore: async (accept?: string, contentType?: string, data?: InlineObject30, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all payment types
         * @summary Show all payment types.
         * @param {string} [filterId] 
         * @param {string} [filterPaymentCategoryId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypeIndex: async (filterId?: string, filterPaymentCategoryId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payment-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterPaymentCategoryId !== undefined) {
                localVarQueryParameter['filter[payment_category_id]'] = filterPaymentCategoryId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given payment
         * @summary Update a payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject31} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUpdate: async (payment: string, accept?: string, contentType?: string, data?: InlineObject31, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('paymentUpdate', 'payment', payment)
            const localVarPath = `/api/v1/payments/{payment}`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all payment category
         * @summary Show all payment category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentCategoryIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20050>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentCategoryIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all payment
         * @summary Show all payment.
         * @param {string} [filterId] 
         * @param {number} [filterAmount] 
         * @param {string} [filterReference] 
         * @param {'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'} [filterStatus] 
         * @param {string} [filterPaymentTypeId] 
         * @param {string} [filterAddedById] 
         * @param {string} [filterApprovedById] 
         * @param {string} [filterOrderId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentIndex(filterId?: string, filterAmount?: number, filterReference?: string, filterStatus?: 'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT', filterPaymentTypeId?: string, filterAddedById?: string, filterApprovedById?: string, filterOrderId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20052>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentIndex(filterId, filterAmount, filterReference, filterStatus, filterPaymentTypeId, filterAddedById, filterApprovedById, filterOrderId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload proof of payment
         * @summary Upload proof of payment
         * @param {string} payment 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody3} [imageRequestBody3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentProofUpload(payment: string, filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody3?: ImageRequestBody3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentProofUpload(payment, filterId, filterName, page, perPage, sort, accept, contentType, imageRequestBody3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns payment by id
         * @summary Get payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentShow(payment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentShow(payment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new payment
         * @summary Create new Payment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject30} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentStore(accept?: string, contentType?: string, data?: InlineObject30, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all payment types
         * @summary Show all payment types.
         * @param {string} [filterId] 
         * @param {string} [filterPaymentCategoryId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentTypeIndex(filterId?: string, filterPaymentCategoryId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentTypeIndex(filterId, filterPaymentCategoryId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given payment
         * @summary Update a payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject31} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentUpdate(payment: string, accept?: string, contentType?: string, data?: InlineObject31, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentUpdate(payment, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * Show all payment category
         * @summary Show all payment category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCategoryIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20050> {
            return localVarFp.paymentCategoryIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all payment
         * @summary Show all payment.
         * @param {string} [filterId] 
         * @param {number} [filterAmount] 
         * @param {string} [filterReference] 
         * @param {'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'} [filterStatus] 
         * @param {string} [filterPaymentTypeId] 
         * @param {string} [filterAddedById] 
         * @param {string} [filterApprovedById] 
         * @param {string} [filterOrderId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIndex(filterId?: string, filterAmount?: number, filterReference?: string, filterStatus?: 'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT', filterPaymentTypeId?: string, filterAddedById?: string, filterApprovedById?: string, filterOrderId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20052> {
            return localVarFp.paymentIndex(filterId, filterAmount, filterReference, filterStatus, filterPaymentTypeId, filterAddedById, filterApprovedById, filterOrderId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload proof of payment
         * @summary Upload proof of payment
         * @param {string} payment 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody3} [imageRequestBody3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentProofUpload(payment: string, filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody3?: ImageRequestBody3, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.paymentProofUpload(payment, filterId, filterName, page, perPage, sort, accept, contentType, imageRequestBody3, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns payment by id
         * @summary Get payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentShow(payment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.paymentShow(payment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new payment
         * @summary Create new Payment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject30} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentStore(accept?: string, contentType?: string, data?: InlineObject30, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.paymentStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all payment types
         * @summary Show all payment types.
         * @param {string} [filterId] 
         * @param {string} [filterPaymentCategoryId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypeIndex(filterId?: string, filterPaymentCategoryId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20051> {
            return localVarFp.paymentTypeIndex(filterId, filterPaymentCategoryId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given payment
         * @summary Update a payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject31} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUpdate(payment: string, accept?: string, contentType?: string, data?: InlineObject31, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.paymentUpdate(payment, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for paymentCategoryIndex operation in PaymentApi.
 * @export
 * @interface PaymentApiPaymentCategoryIndexRequest
 */
export interface PaymentApiPaymentCategoryIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentCategoryIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentCategoryIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof PaymentApiPaymentCategoryIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PaymentApiPaymentCategoryIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof PaymentApiPaymentCategoryIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PaymentApiPaymentCategoryIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PaymentApiPaymentCategoryIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentIndex operation in PaymentApi.
 * @export
 * @interface PaymentApiPaymentIndexRequest
 */
export interface PaymentApiPaymentIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof PaymentApiPaymentIndex
     */
    readonly filterAmount?: number

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentIndex
     */
    readonly filterReference?: string

    /**
     * 
     * @type {'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'}
     * @memberof PaymentApiPaymentIndex
     */
    readonly filterStatus?: 'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentIndex
     */
    readonly filterPaymentTypeId?: string

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentIndex
     */
    readonly filterAddedById?: string

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentIndex
     */
    readonly filterApprovedById?: string

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentIndex
     */
    readonly filterOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof PaymentApiPaymentIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PaymentApiPaymentIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof PaymentApiPaymentIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PaymentApiPaymentIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PaymentApiPaymentIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentProofUpload operation in PaymentApi.
 * @export
 * @interface PaymentApiPaymentProofUploadRequest
 */
export interface PaymentApiPaymentProofUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentProofUpload
     */
    readonly payment: string

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentProofUpload
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentProofUpload
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof PaymentApiPaymentProofUpload
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PaymentApiPaymentProofUpload
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof PaymentApiPaymentProofUpload
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PaymentApiPaymentProofUpload
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PaymentApiPaymentProofUpload
     */
    readonly contentType?: string

    /**
     * 
     * @type {ImageRequestBody3}
     * @memberof PaymentApiPaymentProofUpload
     */
    readonly imageRequestBody3?: ImageRequestBody3
}

/**
 * Request parameters for paymentShow operation in PaymentApi.
 * @export
 * @interface PaymentApiPaymentShowRequest
 */
export interface PaymentApiPaymentShowRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentShow
     */
    readonly payment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PaymentApiPaymentShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PaymentApiPaymentShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentStore operation in PaymentApi.
 * @export
 * @interface PaymentApiPaymentStoreRequest
 */
export interface PaymentApiPaymentStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof PaymentApiPaymentStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PaymentApiPaymentStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject30}
     * @memberof PaymentApiPaymentStore
     */
    readonly data?: InlineObject30
}

/**
 * Request parameters for paymentTypeIndex operation in PaymentApi.
 * @export
 * @interface PaymentApiPaymentTypeIndexRequest
 */
export interface PaymentApiPaymentTypeIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentTypeIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentTypeIndex
     */
    readonly filterPaymentCategoryId?: string

    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentTypeIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof PaymentApiPaymentTypeIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PaymentApiPaymentTypeIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof PaymentApiPaymentTypeIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PaymentApiPaymentTypeIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PaymentApiPaymentTypeIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentUpdate operation in PaymentApi.
 * @export
 * @interface PaymentApiPaymentUpdateRequest
 */
export interface PaymentApiPaymentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PaymentApiPaymentUpdate
     */
    readonly payment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PaymentApiPaymentUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PaymentApiPaymentUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject31}
     * @memberof PaymentApiPaymentUpdate
     */
    readonly data?: InlineObject31
}

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * Show all payment category
     * @summary Show all payment category.
     * @param {PaymentApiPaymentCategoryIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentCategoryIndex(requestParameters: PaymentApiPaymentCategoryIndexRequest = {}, options?: any) {
        return PaymentApiFp(this.configuration).paymentCategoryIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all payment
     * @summary Show all payment.
     * @param {PaymentApiPaymentIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentIndex(requestParameters: PaymentApiPaymentIndexRequest = {}, options?: any) {
        return PaymentApiFp(this.configuration).paymentIndex(requestParameters.filterId, requestParameters.filterAmount, requestParameters.filterReference, requestParameters.filterStatus, requestParameters.filterPaymentTypeId, requestParameters.filterAddedById, requestParameters.filterApprovedById, requestParameters.filterOrderId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload proof of payment
     * @summary Upload proof of payment
     * @param {PaymentApiPaymentProofUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentProofUpload(requestParameters: PaymentApiPaymentProofUploadRequest, options?: any) {
        return PaymentApiFp(this.configuration).paymentProofUpload(requestParameters.payment, requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, requestParameters.imageRequestBody3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns payment by id
     * @summary Get payment
     * @param {PaymentApiPaymentShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentShow(requestParameters: PaymentApiPaymentShowRequest, options?: any) {
        return PaymentApiFp(this.configuration).paymentShow(requestParameters.payment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new payment
     * @summary Create new Payment
     * @param {PaymentApiPaymentStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentStore(requestParameters: PaymentApiPaymentStoreRequest = {}, options?: any) {
        return PaymentApiFp(this.configuration).paymentStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all payment types
     * @summary Show all payment types.
     * @param {PaymentApiPaymentTypeIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentTypeIndex(requestParameters: PaymentApiPaymentTypeIndexRequest = {}, options?: any) {
        return PaymentApiFp(this.configuration).paymentTypeIndex(requestParameters.filterId, requestParameters.filterPaymentCategoryId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given payment
     * @summary Update a payment
     * @param {PaymentApiPaymentUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public paymentUpdate(requestParameters: PaymentApiPaymentUpdateRequest, options?: any) {
        return PaymentApiFp(this.configuration).paymentUpdate(requestParameters.payment, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productBrand: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/brands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryCodes: async (filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/category-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterProductModelId !== undefined) {
                localVarQueryParameter['filter[product_model_id]'] = filterProductModelId;
            }

            if (filterProductVersionId !== undefined) {
                localVarQueryParameter['filter[product_version_id]'] = filterProductVersionId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product
         * @summary Show all product.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {string} [filterProductCategoryCodeId] 
         * @param {string} [filterName] 
         * @param {string} [filterTags] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIndex: async (filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, filterProductCategoryCodeId?: string, filterName?: string, filterTags?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterProductModelId !== undefined) {
                localVarQueryParameter['filter[product_model_id]'] = filterProductModelId;
            }

            if (filterProductVersionId !== undefined) {
                localVarQueryParameter['filter[product_version_id]'] = filterProductVersionId;
            }

            if (filterProductCategoryCodeId !== undefined) {
                localVarQueryParameter['filter[product_category_code_id]'] = filterProductCategoryCodeId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterTags !== undefined) {
                localVarQueryParameter['filter[tags]'] = filterTags;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product model available.
         * @summary Show all product model.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productModel: async (filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product model for a given id.
         * @summary Get product model by id.
         * @param {string} model 
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productModelById: async (model: string, filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('productModelById', 'model', model)
            const localVarPath = `/api/v1/models/{model}`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns product by id
         * @summary Get product
         * @param {string} product 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productShow: async (product: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('productShow', 'product', product)
            const localVarPath = `/api/v1/products/{product}`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVersion: async (filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterProductModelId !== undefined) {
                localVarQueryParameter['filter[product_model_id]'] = filterProductModelId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsProductBrand: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sms-brands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productBrand(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productBrand(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryCodes(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryCodes(filterId, filterProductBrandId, filterProductModelId, filterProductVersionId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product
         * @summary Show all product.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {string} [filterProductCategoryCodeId] 
         * @param {string} [filterName] 
         * @param {string} [filterTags] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productIndex(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, filterProductCategoryCodeId?: string, filterName?: string, filterTags?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productIndex(filterId, filterProductBrandId, filterProductModelId, filterProductVersionId, filterProductCategoryCodeId, filterName, filterTags, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product model available.
         * @summary Show all product model.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productModel(filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productModel(filterId, filterProductBrandId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product model for a given id.
         * @summary Get product model by id.
         * @param {string} model 
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productModelById(model: string, filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productModelById(model, filterId, filterProductBrandId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns product by id
         * @summary Get product
         * @param {string} product 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productShow(product: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productShow(product, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVersion(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVersion(filterId, filterProductBrandId, filterProductModelId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smsProductBrand(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smsProductBrand(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productBrand(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.productBrand(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryCodes(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20029> {
            return localVarFp.productCategoryCodes(filterId, filterProductBrandId, filterProductModelId, filterProductVersionId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product
         * @summary Show all product.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {string} [filterProductCategoryCodeId] 
         * @param {string} [filterName] 
         * @param {string} [filterTags] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIndex(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, filterProductCategoryCodeId?: string, filterName?: string, filterTags?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20030> {
            return localVarFp.productIndex(filterId, filterProductBrandId, filterProductModelId, filterProductVersionId, filterProductCategoryCodeId, filterName, filterTags, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product model available.
         * @summary Show all product model.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productModel(filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20026> {
            return localVarFp.productModel(filterId, filterProductBrandId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product model for a given id.
         * @summary Get product model by id.
         * @param {string} model 
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productModelById(model: string, filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20027> {
            return localVarFp.productModelById(model, filterId, filterProductBrandId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns product by id
         * @summary Get product
         * @param {string} product 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productShow(product: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20031> {
            return localVarFp.productShow(product, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVersion(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20028> {
            return localVarFp.productVersion(filterId, filterProductBrandId, filterProductModelId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsProductBrand(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.smsProductBrand(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productBrand operation in ProductApi.
 * @export
 * @interface ProductApiProductBrandRequest
 */
export interface ProductApiProductBrandRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiProductBrand
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductBrand
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductBrand
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductBrand
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductApiProductBrand
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductApiProductBrand
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductApiProductBrand
     */
    readonly contentType?: string
}

/**
 * Request parameters for productCategoryCodes operation in ProductApi.
 * @export
 * @interface ProductApiProductCategoryCodesRequest
 */
export interface ProductApiProductCategoryCodesRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiProductCategoryCodes
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductCategoryCodes
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductCategoryCodes
     */
    readonly filterProductModelId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductCategoryCodes
     */
    readonly filterProductVersionId?: string

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductCategoryCodes
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductCategoryCodes
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductApiProductCategoryCodes
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductApiProductCategoryCodes
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductApiProductCategoryCodes
     */
    readonly contentType?: string
}

/**
 * Request parameters for productIndex operation in ProductApi.
 * @export
 * @interface ProductApiProductIndexRequest
 */
export interface ProductApiProductIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly filterProductModelId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly filterProductVersionId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly filterProductCategoryCodeId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly filterTags?: string

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductApiProductIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for productModel operation in ProductApi.
 * @export
 * @interface ProductApiProductModelRequest
 */
export interface ProductApiProductModelRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiProductModel
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductModel
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductModel
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductModel
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductModel
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductApiProductModel
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductApiProductModel
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductApiProductModel
     */
    readonly contentType?: string
}

/**
 * Request parameters for productModelById operation in ProductApi.
 * @export
 * @interface ProductApiProductModelByIdRequest
 */
export interface ProductApiProductModelByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiProductModelById
     */
    readonly model: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductModelById
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductModelById
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductModelById
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductModelById
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductModelById
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductApiProductModelById
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductApiProductModelById
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductApiProductModelById
     */
    readonly contentType?: string
}

/**
 * Request parameters for productShow operation in ProductApi.
 * @export
 * @interface ProductApiProductShowRequest
 */
export interface ProductApiProductShowRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiProductShow
     */
    readonly product: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductApiProductShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductApiProductShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for productVersion operation in ProductApi.
 * @export
 * @interface ProductApiProductVersionRequest
 */
export interface ProductApiProductVersionRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiProductVersion
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductVersion
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiProductVersion
     */
    readonly filterProductModelId?: string

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductVersion
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductApiProductVersion
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductApiProductVersion
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductApiProductVersion
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductApiProductVersion
     */
    readonly contentType?: string
}

/**
 * Request parameters for smsProductBrand operation in ProductApi.
 * @export
 * @interface ProductApiSmsProductBrandRequest
 */
export interface ProductApiSmsProductBrandRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductApiSmsProductBrand
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductApiSmsProductBrand
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof ProductApiSmsProductBrand
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductApiSmsProductBrand
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductApiSmsProductBrand
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductApiSmsProductBrand
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductApiSmsProductBrand
     */
    readonly contentType?: string
}

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * Show all product brands available for the active company
     * @summary Show all brands.
     * @param {ProductApiProductBrandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productBrand(requestParameters: ProductApiProductBrandRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).productBrand(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product version available.
     * @summary Show all product version.
     * @param {ProductApiProductCategoryCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productCategoryCodes(requestParameters: ProductApiProductCategoryCodesRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).productCategoryCodes(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterProductModelId, requestParameters.filterProductVersionId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product
     * @summary Show all product.
     * @param {ProductApiProductIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productIndex(requestParameters: ProductApiProductIndexRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).productIndex(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterProductModelId, requestParameters.filterProductVersionId, requestParameters.filterProductCategoryCodeId, requestParameters.filterName, requestParameters.filterTags, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product model available.
     * @summary Show all product model.
     * @param {ProductApiProductModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productModel(requestParameters: ProductApiProductModelRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).productModel(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product model for a given id.
     * @summary Get product model by id.
     * @param {ProductApiProductModelByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productModelById(requestParameters: ProductApiProductModelByIdRequest, options?: any) {
        return ProductApiFp(this.configuration).productModelById(requestParameters.model, requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns product by id
     * @summary Get product
     * @param {ProductApiProductShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productShow(requestParameters: ProductApiProductShowRequest, options?: any) {
        return ProductApiFp(this.configuration).productShow(requestParameters.product, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product version available.
     * @summary Show all product version.
     * @param {ProductApiProductVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productVersion(requestParameters: ProductApiProductVersionRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).productVersion(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterProductModelId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product brands available for the active company
     * @summary Show all brands.
     * @param {ProductApiSmsProductBrandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public smsProductBrand(requestParameters: ProductApiSmsProductBrandRequest = {}, options?: any) {
        return ProductApiFp(this.configuration).smsProductBrand(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductCategoryApi - axios parameter creator
 * @export
 */
export const ProductCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all product category
         * @summary Show all product category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'} [filterType] 
         * @param {number} [filterParentId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryIndex: async (filterId?: string, filterName?: string, filterDescription?: string, filterType?: 'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY', filterParentId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterParentId !== undefined) {
                localVarQueryParameter['filter[parent_id]'] = filterParentId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns product category by id
         * @summary Get product category
         * @param {string} productCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryShow: async (productCategory: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productCategory' is not null or undefined
            assertParamExists('productCategoryShow', 'productCategory', productCategory)
            const localVarPath = `/api/v1/product-categories/{product_category}`
                .replace(`{${"product_category"}}`, encodeURIComponent(String(productCategory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoryApi - functional programming interface
 * @export
 */
export const ProductCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all product category
         * @summary Show all product category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'} [filterType] 
         * @param {number} [filterParentId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryIndex(filterId?: string, filterName?: string, filterDescription?: string, filterType?: 'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY', filterParentId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20038>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryIndex(filterId, filterName, filterDescription, filterType, filterParentId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns product category by id
         * @summary Get product category
         * @param {string} productCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryShow(productCategory: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20039>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryShow(productCategory, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductCategoryApi - factory interface
 * @export
 */
export const ProductCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCategoryApiFp(configuration)
    return {
        /**
         * Show all product category
         * @summary Show all product category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'} [filterType] 
         * @param {number} [filterParentId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryIndex(filterId?: string, filterName?: string, filterDescription?: string, filterType?: 'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY', filterParentId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20038> {
            return localVarFp.productCategoryIndex(filterId, filterName, filterDescription, filterType, filterParentId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns product category by id
         * @summary Get product category
         * @param {string} productCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryShow(productCategory: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20039> {
            return localVarFp.productCategoryShow(productCategory, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productCategoryIndex operation in ProductCategoryApi.
 * @export
 * @interface ProductCategoryApiProductCategoryIndexRequest
 */
export interface ProductCategoryApiProductCategoryIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly filterDescription?: string

    /**
     * 
     * @type {'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly filterType?: 'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'

    /**
     * 
     * @type {number}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly filterParentId?: number

    /**
     * 
     * @type {number}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductCategoryApiProductCategoryIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for productCategoryShow operation in ProductCategoryApi.
 * @export
 * @interface ProductCategoryApiProductCategoryShowRequest
 */
export interface ProductCategoryApiProductCategoryShowRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryApiProductCategoryShow
     */
    readonly productCategory: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductCategoryApiProductCategoryShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductCategoryApiProductCategoryShow
     */
    readonly contentType?: string
}

/**
 * ProductCategoryApi - object-oriented interface
 * @export
 * @class ProductCategoryApi
 * @extends {BaseAPI}
 */
export class ProductCategoryApi extends BaseAPI {
    /**
     * Show all product category
     * @summary Show all product category.
     * @param {ProductCategoryApiProductCategoryIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public productCategoryIndex(requestParameters: ProductCategoryApiProductCategoryIndexRequest = {}, options?: any) {
        return ProductCategoryApiFp(this.configuration).productCategoryIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.filterDescription, requestParameters.filterType, requestParameters.filterParentId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns product category by id
     * @summary Get product category
     * @param {ProductCategoryApiProductCategoryShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public productCategoryShow(requestParameters: ProductCategoryApiProductCategoryShowRequest, options?: any) {
        return ProductCategoryApiFp(this.configuration).productCategoryShow(requestParameters.productCategory, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductTagApi - axios parameter creator
 * @export
 */
export const ProductTagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all product tag
         * @summary Show all product tag.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterSlug] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagIndex: async (filterId?: string, filterName?: string, filterSlug?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/product-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterSlug !== undefined) {
                localVarQueryParameter['filter[slug]'] = filterSlug;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns product tag by id
         * @summary Get product tag
         * @param {string} productTag 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagShow: async (productTag: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productTag' is not null or undefined
            assertParamExists('productTagShow', 'productTag', productTag)
            const localVarPath = `/api/v1/product-tags/{product_tag}`
                .replace(`{${"product_tag"}}`, encodeURIComponent(String(productTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductTagApi - functional programming interface
 * @export
 */
export const ProductTagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductTagApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all product tag
         * @summary Show all product tag.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterSlug] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productTagIndex(filterId?: string, filterName?: string, filterSlug?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productTagIndex(filterId, filterName, filterSlug, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns product tag by id
         * @summary Get product tag
         * @param {string} productTag 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productTagShow(productTag: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productTagShow(productTag, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductTagApi - factory interface
 * @export
 */
export const ProductTagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductTagApiFp(configuration)
    return {
        /**
         * Show all product tag
         * @summary Show all product tag.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterSlug] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagIndex(filterId?: string, filterName?: string, filterSlug?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20036> {
            return localVarFp.productTagIndex(filterId, filterName, filterSlug, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns product tag by id
         * @summary Get product tag
         * @param {string} productTag 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagShow(productTag: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20037> {
            return localVarFp.productTagShow(productTag, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productTagIndex operation in ProductTagApi.
 * @export
 * @interface ProductTagApiProductTagIndexRequest
 */
export interface ProductTagApiProductTagIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductTagApiProductTagIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductTagApiProductTagIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof ProductTagApiProductTagIndex
     */
    readonly filterSlug?: string

    /**
     * 
     * @type {number}
     * @memberof ProductTagApiProductTagIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductTagApiProductTagIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductTagApiProductTagIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductTagApiProductTagIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductTagApiProductTagIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for productTagShow operation in ProductTagApi.
 * @export
 * @interface ProductTagApiProductTagShowRequest
 */
export interface ProductTagApiProductTagShowRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductTagApiProductTagShow
     */
    readonly productTag: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductTagApiProductTagShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductTagApiProductTagShow
     */
    readonly contentType?: string
}

/**
 * ProductTagApi - object-oriented interface
 * @export
 * @class ProductTagApi
 * @extends {BaseAPI}
 */
export class ProductTagApi extends BaseAPI {
    /**
     * Show all product tag
     * @summary Show all product tag.
     * @param {ProductTagApiProductTagIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public productTagIndex(requestParameters: ProductTagApiProductTagIndexRequest = {}, options?: any) {
        return ProductTagApiFp(this.configuration).productTagIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.filterSlug, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns product tag by id
     * @summary Get product tag
     * @param {ProductTagApiProductTagShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductTagApi
     */
    public productTagShow(requestParameters: ProductTagApiProductTagShowRequest, options?: any) {
        return ProductTagApiFp(this.configuration).productTagShow(requestParameters.productTag, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductUnitApi - axios parameter creator
 * @export
 */
export const ProductUnitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all product unit colours
         * @summary Show all product unit colours.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [filterProductId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitColours: async (filterId?: string, filterName?: string, filterDescription?: string, filterProductId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/colours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (filterProductId !== undefined) {
                localVarQueryParameter['filter[product_id]'] = filterProductId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product unit coverings
         * @summary Show all product unit coverings.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {string} [filterName] 
         * @param {string} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitCoverings: async (filterId?: string, filterProductId?: number, filterName?: string, filterType?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/coverings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductId !== undefined) {
                localVarQueryParameter['filter[product_id]'] = filterProductId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product unit
         * @summary Show all product unit.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitIndex: async (filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/product-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductId !== undefined) {
                localVarQueryParameter['filter[product_id]'] = filterProductId;
            }

            if (filterColourId !== undefined) {
                localVarQueryParameter['filter[colour_id]'] = filterColourId;
            }

            if (filterCoveringId !== undefined) {
                localVarQueryParameter['filter[covering_id]'] = filterCoveringId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns product unit by id
         * @summary Get product unit
         * @param {string} productUnit 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitShow: async (productUnit: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productUnit' is not null or undefined
            assertParamExists('productUnitShow', 'productUnit', productUnit)
            const localVarPath = `/api/v1/product-units/{product_unit}`
                .replace(`{${"product_unit"}}`, encodeURIComponent(String(productUnit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload product unit image
         * @summary Upload product unit image
         * @param {string} productUnit 
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody} [imageRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitUpload: async (productUnit: string, filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody?: ImageRequestBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productUnit' is not null or undefined
            assertParamExists('productUnitUpload', 'productUnit', productUnit)
            const localVarPath = `/api/v1/product-units/{productUnit}/upload`
                .replace(`{${"productUnit"}}`, encodeURIComponent(String(productUnit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductId !== undefined) {
                localVarQueryParameter['filter[product_id]'] = filterProductId;
            }

            if (filterColourId !== undefined) {
                localVarQueryParameter['filter[colour_id]'] = filterColourId;
            }

            if (filterCoveringId !== undefined) {
                localVarQueryParameter['filter[covering_id]'] = filterCoveringId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductUnitApi - functional programming interface
 * @export
 */
export const ProductUnitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductUnitApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all product unit colours
         * @summary Show all product unit colours.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [filterProductId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitColours(filterId?: string, filterName?: string, filterDescription?: string, filterProductId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitColours(filterId, filterName, filterDescription, filterProductId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product unit coverings
         * @summary Show all product unit coverings.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {string} [filterName] 
         * @param {string} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitCoverings(filterId?: string, filterProductId?: number, filterName?: string, filterType?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitCoverings(filterId, filterProductId, filterName, filterType, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product unit
         * @summary Show all product unit.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitIndex(filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitIndex(filterId, filterProductId, filterColourId, filterCoveringId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns product unit by id
         * @summary Get product unit
         * @param {string} productUnit 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitShow(productUnit: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitShow(productUnit, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload product unit image
         * @summary Upload product unit image
         * @param {string} productUnit 
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody} [imageRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitUpload(productUnit: string, filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody?: ImageRequestBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitUpload(productUnit, filterId, filterProductId, filterColourId, filterCoveringId, filterName, page, perPage, sort, accept, contentType, imageRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductUnitApi - factory interface
 * @export
 */
export const ProductUnitApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductUnitApiFp(configuration)
    return {
        /**
         * Show all product unit colours
         * @summary Show all product unit colours.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [filterProductId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitColours(filterId?: string, filterName?: string, filterDescription?: string, filterProductId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20032> {
            return localVarFp.productUnitColours(filterId, filterName, filterDescription, filterProductId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product unit coverings
         * @summary Show all product unit coverings.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {string} [filterName] 
         * @param {string} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitCoverings(filterId?: string, filterProductId?: number, filterName?: string, filterType?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20033> {
            return localVarFp.productUnitCoverings(filterId, filterProductId, filterName, filterType, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product unit
         * @summary Show all product unit.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitIndex(filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20034> {
            return localVarFp.productUnitIndex(filterId, filterProductId, filterColourId, filterCoveringId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns product unit by id
         * @summary Get product unit
         * @param {string} productUnit 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitShow(productUnit: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20035> {
            return localVarFp.productUnitShow(productUnit, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload product unit image
         * @summary Upload product unit image
         * @param {string} productUnit 
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody} [imageRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitUpload(productUnit: string, filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody?: ImageRequestBody, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.productUnitUpload(productUnit, filterId, filterProductId, filterColourId, filterCoveringId, filterName, page, perPage, sort, accept, contentType, imageRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for productUnitColours operation in ProductUnitApi.
 * @export
 * @interface ProductUnitApiProductUnitColoursRequest
 */
export interface ProductUnitApiProductUnitColoursRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitColours
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitColours
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitColours
     */
    readonly filterDescription?: string

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitColours
     */
    readonly filterProductId?: number

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitColours
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitColours
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductUnitApiProductUnitColours
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductUnitApiProductUnitColours
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductUnitApiProductUnitColours
     */
    readonly contentType?: string
}

/**
 * Request parameters for productUnitCoverings operation in ProductUnitApi.
 * @export
 * @interface ProductUnitApiProductUnitCoveringsRequest
 */
export interface ProductUnitApiProductUnitCoveringsRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitCoverings
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitCoverings
     */
    readonly filterProductId?: number

    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitCoverings
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitCoverings
     */
    readonly filterType?: string

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitCoverings
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitCoverings
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductUnitApiProductUnitCoverings
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductUnitApiProductUnitCoverings
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductUnitApiProductUnitCoverings
     */
    readonly contentType?: string
}

/**
 * Request parameters for productUnitIndex operation in ProductUnitApi.
 * @export
 * @interface ProductUnitApiProductUnitIndexRequest
 */
export interface ProductUnitApiProductUnitIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly filterProductId?: number

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly filterColourId?: number

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly filterCoveringId?: number

    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductUnitApiProductUnitIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for productUnitShow operation in ProductUnitApi.
 * @export
 * @interface ProductUnitApiProductUnitShowRequest
 */
export interface ProductUnitApiProductUnitShowRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitShow
     */
    readonly productUnit: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductUnitApiProductUnitShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductUnitApiProductUnitShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for productUnitUpload operation in ProductUnitApi.
 * @export
 * @interface ProductUnitApiProductUnitUploadRequest
 */
export interface ProductUnitApiProductUnitUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly productUnit: string

    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly filterProductId?: number

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly filterColourId?: number

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly filterCoveringId?: number

    /**
     * 
     * @type {string}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly contentType?: string

    /**
     * 
     * @type {ImageRequestBody}
     * @memberof ProductUnitApiProductUnitUpload
     */
    readonly imageRequestBody?: ImageRequestBody
}

/**
 * ProductUnitApi - object-oriented interface
 * @export
 * @class ProductUnitApi
 * @extends {BaseAPI}
 */
export class ProductUnitApi extends BaseAPI {
    /**
     * Show all product unit colours
     * @summary Show all product unit colours.
     * @param {ProductUnitApiProductUnitColoursRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUnitApi
     */
    public productUnitColours(requestParameters: ProductUnitApiProductUnitColoursRequest = {}, options?: any) {
        return ProductUnitApiFp(this.configuration).productUnitColours(requestParameters.filterId, requestParameters.filterName, requestParameters.filterDescription, requestParameters.filterProductId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product unit coverings
     * @summary Show all product unit coverings.
     * @param {ProductUnitApiProductUnitCoveringsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUnitApi
     */
    public productUnitCoverings(requestParameters: ProductUnitApiProductUnitCoveringsRequest = {}, options?: any) {
        return ProductUnitApiFp(this.configuration).productUnitCoverings(requestParameters.filterId, requestParameters.filterProductId, requestParameters.filterName, requestParameters.filterType, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product unit
     * @summary Show all product unit.
     * @param {ProductUnitApiProductUnitIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUnitApi
     */
    public productUnitIndex(requestParameters: ProductUnitApiProductUnitIndexRequest = {}, options?: any) {
        return ProductUnitApiFp(this.configuration).productUnitIndex(requestParameters.filterId, requestParameters.filterProductId, requestParameters.filterColourId, requestParameters.filterCoveringId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns product unit by id
     * @summary Get product unit
     * @param {ProductUnitApiProductUnitShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUnitApi
     */
    public productUnitShow(requestParameters: ProductUnitApiProductUnitShowRequest, options?: any) {
        return ProductUnitApiFp(this.configuration).productUnitShow(requestParameters.productUnit, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload product unit image
     * @summary Upload product unit image
     * @param {ProductUnitApiProductUnitUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUnitApi
     */
    public productUnitUpload(requestParameters: ProductUnitApiProductUnitUploadRequest, options?: any) {
        return ProductUnitApiFp(this.configuration).productUnitUpload(requestParameters.productUnit, requestParameters.filterId, requestParameters.filterProductId, requestParameters.filterColourId, requestParameters.filterCoveringId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, requestParameters.imageRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PromoApi - axios parameter creator
 * @export
 */
export const PromoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all promo
         * @summary Show all promo.
         * @param {string} [filterId] 
         * @param {number} [filterPromoCategoryId] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoIndex: async (filterId?: string, filterPromoCategoryId?: number, filterStartAfter?: string, filterEndBefore?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/promos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterPromoCategoryId !== undefined) {
                localVarQueryParameter['filter[promo_category_id]'] = filterPromoCategoryId;
            }

            if (filterStartAfter !== undefined) {
                localVarQueryParameter['filter[start_after]'] = filterStartAfter;
            }

            if (filterEndBefore !== undefined) {
                localVarQueryParameter['filter[end_before]'] = filterEndBefore;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns promo by id
         * @summary Get promo
         * @param {string} promo 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoShow: async (promo: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'promo' is not null or undefined
            assertParamExists('promoShow', 'promo', promo)
            const localVarPath = `/api/v1/promos/{promo}`
                .replace(`{${"promo"}}`, encodeURIComponent(String(promo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromoApi - functional programming interface
 * @export
 */
export const PromoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromoApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all promo
         * @summary Show all promo.
         * @param {string} [filterId] 
         * @param {number} [filterPromoCategoryId] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoIndex(filterId?: string, filterPromoCategoryId?: number, filterStartAfter?: string, filterEndBefore?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20061>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoIndex(filterId, filterPromoCategoryId, filterStartAfter, filterEndBefore, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns promo by id
         * @summary Get promo
         * @param {string} promo 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoShow(promo: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20062>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoShow(promo, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PromoApi - factory interface
 * @export
 */
export const PromoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromoApiFp(configuration)
    return {
        /**
         * Show all promo
         * @summary Show all promo.
         * @param {string} [filterId] 
         * @param {number} [filterPromoCategoryId] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoIndex(filterId?: string, filterPromoCategoryId?: number, filterStartAfter?: string, filterEndBefore?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20061> {
            return localVarFp.promoIndex(filterId, filterPromoCategoryId, filterStartAfter, filterEndBefore, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns promo by id
         * @summary Get promo
         * @param {string} promo 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoShow(promo: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20062> {
            return localVarFp.promoShow(promo, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for promoIndex operation in PromoApi.
 * @export
 * @interface PromoApiPromoIndexRequest
 */
export interface PromoApiPromoIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof PromoApiPromoIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof PromoApiPromoIndex
     */
    readonly filterPromoCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof PromoApiPromoIndex
     */
    readonly filterStartAfter?: string

    /**
     * 
     * @type {string}
     * @memberof PromoApiPromoIndex
     */
    readonly filterEndBefore?: string

    /**
     * 
     * @type {number}
     * @memberof PromoApiPromoIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PromoApiPromoIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof PromoApiPromoIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PromoApiPromoIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PromoApiPromoIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for promoShow operation in PromoApi.
 * @export
 * @interface PromoApiPromoShowRequest
 */
export interface PromoApiPromoShowRequest {
    /**
     * 
     * @type {string}
     * @memberof PromoApiPromoShow
     */
    readonly promo: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PromoApiPromoShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PromoApiPromoShow
     */
    readonly contentType?: string
}

/**
 * PromoApi - object-oriented interface
 * @export
 * @class PromoApi
 * @extends {BaseAPI}
 */
export class PromoApi extends BaseAPI {
    /**
     * Show all promo
     * @summary Show all promo.
     * @param {PromoApiPromoIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoIndex(requestParameters: PromoApiPromoIndexRequest = {}, options?: any) {
        return PromoApiFp(this.configuration).promoIndex(requestParameters.filterId, requestParameters.filterPromoCategoryId, requestParameters.filterStartAfter, requestParameters.filterEndBefore, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns promo by id
     * @summary Get promo
     * @param {PromoApiPromoShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoApi
     */
    public promoShow(requestParameters: PromoApiPromoShowRequest, options?: any) {
        return PromoApiFp(this.configuration).promoShow(requestParameters.promo, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PromoCategoryApi - axios parameter creator
 * @export
 */
export const PromoCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all promo categories.
         * @summary Show all promo categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoCategoryIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/promo-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns promo category by id
         * @summary Get promo category
         * @param {string} promoCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoCategoryShow: async (promoCategory: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'promoCategory' is not null or undefined
            assertParamExists('promoCategoryShow', 'promoCategory', promoCategory)
            const localVarPath = `/api/v1/promo-categories/{promo_category}`
                .replace(`{${"promo_category"}}`, encodeURIComponent(String(promoCategory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromoCategoryApi - functional programming interface
 * @export
 */
export const PromoCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromoCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all promo categories.
         * @summary Show all promo categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoCategoryIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20059>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoCategoryIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns promo category by id
         * @summary Get promo category
         * @param {string} promoCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoCategoryShow(promoCategory: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20060>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoCategoryShow(promoCategory, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PromoCategoryApi - factory interface
 * @export
 */
export const PromoCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromoCategoryApiFp(configuration)
    return {
        /**
         * Show all promo categories.
         * @summary Show all promo categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoCategoryIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20059> {
            return localVarFp.promoCategoryIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns promo category by id
         * @summary Get promo category
         * @param {string} promoCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoCategoryShow(promoCategory: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20060> {
            return localVarFp.promoCategoryShow(promoCategory, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for promoCategoryIndex operation in PromoCategoryApi.
 * @export
 * @interface PromoCategoryApiPromoCategoryIndexRequest
 */
export interface PromoCategoryApiPromoCategoryIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof PromoCategoryApiPromoCategoryIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof PromoCategoryApiPromoCategoryIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof PromoCategoryApiPromoCategoryIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PromoCategoryApiPromoCategoryIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof PromoCategoryApiPromoCategoryIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PromoCategoryApiPromoCategoryIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PromoCategoryApiPromoCategoryIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for promoCategoryShow operation in PromoCategoryApi.
 * @export
 * @interface PromoCategoryApiPromoCategoryShowRequest
 */
export interface PromoCategoryApiPromoCategoryShowRequest {
    /**
     * 
     * @type {string}
     * @memberof PromoCategoryApiPromoCategoryShow
     */
    readonly promoCategory: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PromoCategoryApiPromoCategoryShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PromoCategoryApiPromoCategoryShow
     */
    readonly contentType?: string
}

/**
 * PromoCategoryApi - object-oriented interface
 * @export
 * @class PromoCategoryApi
 * @extends {BaseAPI}
 */
export class PromoCategoryApi extends BaseAPI {
    /**
     * Show all promo categories.
     * @summary Show all promo categories.
     * @param {PromoCategoryApiPromoCategoryIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoCategoryApi
     */
    public promoCategoryIndex(requestParameters: PromoCategoryApiPromoCategoryIndexRequest = {}, options?: any) {
        return PromoCategoryApiFp(this.configuration).promoCategoryIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns promo category by id
     * @summary Get promo category
     * @param {PromoCategoryApiPromoCategoryShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromoCategoryApi
     */
    public promoCategoryShow(requestParameters: PromoCategoryApiPromoCategoryShowRequest, options?: any) {
        return PromoCategoryApiFp(this.configuration).promoCategoryShow(requestParameters.promoCategory, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PushNotificationApi - axios parameter creator
 * @export
 */
export const PushNotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set all current user notification as read
         * @summary Clear all notifications
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationClear: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all notifications
         * @summary Show all notifications
         * @param {'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationIndex: async (filterType?: 'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribe device code to push notification
         * @summary Subscribe device code to push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationSubscribe: async (code: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('pushNotificationSubscribe', 'code', code)
            const localVarPath = `/api/v1/notifications/{code}/subscribe`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a test notification
         * @summary Send a test notification
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject6} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationTest: async (accept?: string, contentType?: string, data?: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribe device code from push notification
         * @summary Unsubscribe device code from push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationUnsubscribe: async (code: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('pushNotificationUnsubscribe', 'code', code)
            const localVarPath = `/api/v1/notifications/{code}/unsubscribe`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushNotificationApi - functional programming interface
 * @export
 */
export const PushNotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PushNotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Set all current user notification as read
         * @summary Clear all notifications
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationClear(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationClear(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all notifications
         * @summary Show all notifications
         * @param {'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationIndex(filterType?: 'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationIndex(filterType, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Subscribe device code to push notification
         * @summary Subscribe device code to push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationSubscribe(code: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationSubscribe(code, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a test notification
         * @summary Send a test notification
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject6} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationTest(accept?: string, contentType?: string, data?: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationTest(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unsubscribe device code from push notification
         * @summary Unsubscribe device code from push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationUnsubscribe(code: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationUnsubscribe(code, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PushNotificationApi - factory interface
 * @export
 */
export const PushNotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PushNotificationApiFp(configuration)
    return {
        /**
         * Set all current user notification as read
         * @summary Clear all notifications
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationClear(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.pushNotificationClear(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all notifications
         * @summary Show all notifications
         * @param {'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationIndex(filterType?: 'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.pushNotificationIndex(filterType, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscribe device code to push notification
         * @summary Subscribe device code to push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationSubscribe(code: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.pushNotificationSubscribe(code, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a test notification
         * @summary Send a test notification
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject6} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationTest(accept?: string, contentType?: string, data?: InlineObject6, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.pushNotificationTest(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribe device code from push notification
         * @summary Unsubscribe device code from push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationUnsubscribe(code: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.pushNotificationUnsubscribe(code, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for pushNotificationClear operation in PushNotificationApi.
 * @export
 * @interface PushNotificationApiPushNotificationClearRequest
 */
export interface PushNotificationApiPushNotificationClearRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof PushNotificationApiPushNotificationClear
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PushNotificationApiPushNotificationClear
     */
    readonly contentType?: string
}

/**
 * Request parameters for pushNotificationIndex operation in PushNotificationApi.
 * @export
 * @interface PushNotificationApiPushNotificationIndexRequest
 */
export interface PushNotificationApiPushNotificationIndexRequest {
    /**
     * 
     * @type {'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'}
     * @memberof PushNotificationApiPushNotificationIndex
     */
    readonly filterType?: 'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'

    /**
     * 
     * @type {number}
     * @memberof PushNotificationApiPushNotificationIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof PushNotificationApiPushNotificationIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof PushNotificationApiPushNotificationIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PushNotificationApiPushNotificationIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PushNotificationApiPushNotificationIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for pushNotificationSubscribe operation in PushNotificationApi.
 * @export
 * @interface PushNotificationApiPushNotificationSubscribeRequest
 */
export interface PushNotificationApiPushNotificationSubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof PushNotificationApiPushNotificationSubscribe
     */
    readonly code: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PushNotificationApiPushNotificationSubscribe
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PushNotificationApiPushNotificationSubscribe
     */
    readonly contentType?: string
}

/**
 * Request parameters for pushNotificationTest operation in PushNotificationApi.
 * @export
 * @interface PushNotificationApiPushNotificationTestRequest
 */
export interface PushNotificationApiPushNotificationTestRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof PushNotificationApiPushNotificationTest
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PushNotificationApiPushNotificationTest
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject6}
     * @memberof PushNotificationApiPushNotificationTest
     */
    readonly data?: InlineObject6
}

/**
 * Request parameters for pushNotificationUnsubscribe operation in PushNotificationApi.
 * @export
 * @interface PushNotificationApiPushNotificationUnsubscribeRequest
 */
export interface PushNotificationApiPushNotificationUnsubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof PushNotificationApiPushNotificationUnsubscribe
     */
    readonly code: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof PushNotificationApiPushNotificationUnsubscribe
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof PushNotificationApiPushNotificationUnsubscribe
     */
    readonly contentType?: string
}

/**
 * PushNotificationApi - object-oriented interface
 * @export
 * @class PushNotificationApi
 * @extends {BaseAPI}
 */
export class PushNotificationApi extends BaseAPI {
    /**
     * Set all current user notification as read
     * @summary Clear all notifications
     * @param {PushNotificationApiPushNotificationClearRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationApi
     */
    public pushNotificationClear(requestParameters: PushNotificationApiPushNotificationClearRequest = {}, options?: any) {
        return PushNotificationApiFp(this.configuration).pushNotificationClear(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all notifications
     * @summary Show all notifications
     * @param {PushNotificationApiPushNotificationIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationApi
     */
    public pushNotificationIndex(requestParameters: PushNotificationApiPushNotificationIndexRequest = {}, options?: any) {
        return PushNotificationApiFp(this.configuration).pushNotificationIndex(requestParameters.filterType, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscribe device code to push notification
     * @summary Subscribe device code to push notification
     * @param {PushNotificationApiPushNotificationSubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationApi
     */
    public pushNotificationSubscribe(requestParameters: PushNotificationApiPushNotificationSubscribeRequest, options?: any) {
        return PushNotificationApiFp(this.configuration).pushNotificationSubscribe(requestParameters.code, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a test notification
     * @summary Send a test notification
     * @param {PushNotificationApiPushNotificationTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationApi
     */
    public pushNotificationTest(requestParameters: PushNotificationApiPushNotificationTestRequest = {}, options?: any) {
        return PushNotificationApiFp(this.configuration).pushNotificationTest(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribe device code from push notification
     * @summary Unsubscribe device code from push notification
     * @param {PushNotificationApiPushNotificationUnsubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationApi
     */
    public pushNotificationUnsubscribe(requestParameters: PushNotificationApiPushNotificationUnsubscribeRequest, options?: any) {
        return PushNotificationApiFp(this.configuration).pushNotificationUnsubscribe(requestParameters.code, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QaMessageApi - axios parameter creator
 * @export
 */
export const QaMessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a qa message by its id
         * @summary Delete Qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageDestroy: async (qaMessage: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaMessage' is not null or undefined
            assertParamExists('qaMessageDestroy', 'qaMessage', qaMessage)
            const localVarPath = `/api/v1/qa-messages/{qa_message}`
                .replace(`{${"qa_message"}}`, encodeURIComponent(String(qaMessage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all qa message
         * @summary Show all qa message.
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageIndex: async (filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (filterTopicId !== undefined) {
                localVarQueryParameter['filter[topic_id]'] = filterTopicId;
            }

            if (filterSenderId !== undefined) {
                localVarQueryParameter['filter[sender_id]'] = filterSenderId;
            }

            if (filterIsUnread !== undefined) {
                localVarQueryParameter['filter[is_unread]'] = filterIsUnread;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns qa message by id
         * @summary Get qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageShow: async (qaMessage: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaMessage' is not null or undefined
            assertParamExists('qaMessageShow', 'qaMessage', qaMessage)
            const localVarPath = `/api/v1/qa-messages/{qa_message}`
                .replace(`{${"qa_message"}}`, encodeURIComponent(String(qaMessage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new qa message
         * @summary Create new Qa message
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject19} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageStore: async (accept?: string, contentType?: string, data?: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given qa message
         * @summary Update a qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject20} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageUpdate: async (qaMessage: string, accept?: string, contentType?: string, data?: InlineObject20, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaMessage' is not null or undefined
            assertParamExists('qaMessageUpdate', 'qaMessage', qaMessage)
            const localVarPath = `/api/v1/qa-messages/{qa_message}`
                .replace(`{${"qa_message"}}`, encodeURIComponent(String(qaMessage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
         * @summary Get all Qa Messages of a Qa Topic
         * @param {number} topic 
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicGetQaMessages: async (topic: number, filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('qaTopicGetQaMessages', 'topic', topic)
            const localVarPath = `/api/v1/qa-topics/{topic}/qa-messages`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (filterTopicId !== undefined) {
                localVarQueryParameter['filter[topic_id]'] = filterTopicId;
            }

            if (filterSenderId !== undefined) {
                localVarQueryParameter['filter[sender_id]'] = filterSenderId;
            }

            if (filterIsUnread !== undefined) {
                localVarQueryParameter['filter[is_unread]'] = filterIsUnread;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QaMessageApi - functional programming interface
 * @export
 */
export const QaMessageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QaMessageApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a qa message by its id
         * @summary Delete Qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageDestroy(qaMessage: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageDestroy(qaMessage, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all qa message
         * @summary Show all qa message.
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageIndex(filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageIndex(filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns qa message by id
         * @summary Get qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageShow(qaMessage: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageShow(qaMessage, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new qa message
         * @summary Create new Qa message
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject19} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageStore(accept?: string, contentType?: string, data?: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given qa message
         * @summary Update a qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject20} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageUpdate(qaMessage: string, accept?: string, contentType?: string, data?: InlineObject20, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageUpdate(qaMessage, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
         * @summary Get all Qa Messages of a Qa Topic
         * @param {number} topic 
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicGetQaMessages(topic: number, filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicGetQaMessages(topic, filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QaMessageApi - factory interface
 * @export
 */
export const QaMessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QaMessageApiFp(configuration)
    return {
        /**
         * Delete a qa message by its id
         * @summary Delete Qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageDestroy(qaMessage: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.qaMessageDestroy(qaMessage, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all qa message
         * @summary Show all qa message.
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageIndex(filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20040> {
            return localVarFp.qaMessageIndex(filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns qa message by id
         * @summary Get qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageShow(qaMessage: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2016> {
            return localVarFp.qaMessageShow(qaMessage, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new qa message
         * @summary Create new Qa message
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject19} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageStore(accept?: string, contentType?: string, data?: InlineObject19, options?: any): AxiosPromise<InlineResponse2016> {
            return localVarFp.qaMessageStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given qa message
         * @summary Update a qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject20} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageUpdate(qaMessage: string, accept?: string, contentType?: string, data?: InlineObject20, options?: any): AxiosPromise<InlineResponse2016> {
            return localVarFp.qaMessageUpdate(qaMessage, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
         * @summary Get all Qa Messages of a Qa Topic
         * @param {number} topic 
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicGetQaMessages(topic: number, filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20040> {
            return localVarFp.qaTopicGetQaMessages(topic, filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for qaMessageDestroy operation in QaMessageApi.
 * @export
 * @interface QaMessageApiQaMessageDestroyRequest
 */
export interface QaMessageApiQaMessageDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaMessageDestroy
     */
    readonly qaMessage: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaMessageApiQaMessageDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaMessageApiQaMessageDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageIndex operation in QaMessageApi.
 * @export
 * @interface QaMessageApiQaMessageIndexRequest
 */
export interface QaMessageApiQaMessageIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly filterContent?: string

    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly filterTopicId?: string

    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly filterSenderId?: string

    /**
     * 
     * @type {boolean}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly filterIsUnread?: boolean

    /**
     * 
     * @type {number}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaMessageApiQaMessageIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageShow operation in QaMessageApi.
 * @export
 * @interface QaMessageApiQaMessageShowRequest
 */
export interface QaMessageApiQaMessageShowRequest {
    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaMessageShow
     */
    readonly qaMessage: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaMessageApiQaMessageShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaMessageApiQaMessageShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageStore operation in QaMessageApi.
 * @export
 * @interface QaMessageApiQaMessageStoreRequest
 */
export interface QaMessageApiQaMessageStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaMessageApiQaMessageStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaMessageApiQaMessageStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject19}
     * @memberof QaMessageApiQaMessageStore
     */
    readonly data?: InlineObject19
}

/**
 * Request parameters for qaMessageUpdate operation in QaMessageApi.
 * @export
 * @interface QaMessageApiQaMessageUpdateRequest
 */
export interface QaMessageApiQaMessageUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaMessageUpdate
     */
    readonly qaMessage: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaMessageApiQaMessageUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaMessageApiQaMessageUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject20}
     * @memberof QaMessageApiQaMessageUpdate
     */
    readonly data?: InlineObject20
}

/**
 * Request parameters for qaTopicGetQaMessages operation in QaMessageApi.
 * @export
 * @interface QaMessageApiQaTopicGetQaMessagesRequest
 */
export interface QaMessageApiQaTopicGetQaMessagesRequest {
    /**
     * 
     * @type {number}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly topic: number

    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly filterContent?: string

    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly filterTopicId?: string

    /**
     * 
     * @type {string}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly filterSenderId?: string

    /**
     * 
     * @type {boolean}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly filterIsUnread?: boolean

    /**
     * 
     * @type {number}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaMessageApiQaTopicGetQaMessages
     */
    readonly contentType?: string
}

/**
 * QaMessageApi - object-oriented interface
 * @export
 * @class QaMessageApi
 * @extends {BaseAPI}
 */
export class QaMessageApi extends BaseAPI {
    /**
     * Delete a qa message by its id
     * @summary Delete Qa message
     * @param {QaMessageApiQaMessageDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaMessageApi
     */
    public qaMessageDestroy(requestParameters: QaMessageApiQaMessageDestroyRequest, options?: any) {
        return QaMessageApiFp(this.configuration).qaMessageDestroy(requestParameters.qaMessage, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all qa message
     * @summary Show all qa message.
     * @param {QaMessageApiQaMessageIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaMessageApi
     */
    public qaMessageIndex(requestParameters: QaMessageApiQaMessageIndexRequest = {}, options?: any) {
        return QaMessageApiFp(this.configuration).qaMessageIndex(requestParameters.filterId, requestParameters.filterContent, requestParameters.filterTopicId, requestParameters.filterSenderId, requestParameters.filterIsUnread, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns qa message by id
     * @summary Get qa message
     * @param {QaMessageApiQaMessageShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaMessageApi
     */
    public qaMessageShow(requestParameters: QaMessageApiQaMessageShowRequest, options?: any) {
        return QaMessageApiFp(this.configuration).qaMessageShow(requestParameters.qaMessage, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new qa message
     * @summary Create new Qa message
     * @param {QaMessageApiQaMessageStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaMessageApi
     */
    public qaMessageStore(requestParameters: QaMessageApiQaMessageStoreRequest = {}, options?: any) {
        return QaMessageApiFp(this.configuration).qaMessageStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given qa message
     * @summary Update a qa message
     * @param {QaMessageApiQaMessageUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaMessageApi
     */
    public qaMessageUpdate(requestParameters: QaMessageApiQaMessageUpdateRequest, options?: any) {
        return QaMessageApiFp(this.configuration).qaMessageUpdate(requestParameters.qaMessage, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
     * @summary Get all Qa Messages of a Qa Topic
     * @param {QaMessageApiQaTopicGetQaMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaMessageApi
     */
    public qaTopicGetQaMessages(requestParameters: QaMessageApiQaTopicGetQaMessagesRequest, options?: any) {
        return QaMessageApiFp(this.configuration).qaTopicGetQaMessages(requestParameters.topic, requestParameters.filterId, requestParameters.filterContent, requestParameters.filterTopicId, requestParameters.filterSenderId, requestParameters.filterIsUnread, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QaTopicApi - axios parameter creator
 * @export
 */
export const QaTopicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a qa topic by its id
         * @summary Delete Qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicDestroy: async (qaTopic: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaTopic' is not null or undefined
            assertParamExists('qaTopicDestroy', 'qaTopic', qaTopic)
            const localVarPath = `/api/v1/qa-topics/{qa_topic}`
                .replace(`{${"qa_topic"}}`, encodeURIComponent(String(qaTopic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
         * @summary Get all Qa Messages of a Qa Topic
         * @param {number} topic 
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicGetQaMessages: async (topic: number, filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('qaTopicGetQaMessages', 'topic', topic)
            const localVarPath = `/api/v1/qa-topics/{topic}/qa-messages`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (filterTopicId !== undefined) {
                localVarQueryParameter['filter[topic_id]'] = filterTopicId;
            }

            if (filterSenderId !== undefined) {
                localVarQueryParameter['filter[sender_id]'] = filterSenderId;
            }

            if (filterIsUnread !== undefined) {
                localVarQueryParameter['filter[is_unread]'] = filterIsUnread;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all qa topic
         * @summary Show all qa topic.
         * @param {string} [filterId] 
         * @param {string} [filterSubject] 
         * @param {number} [filterCreatorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicIndex: async (filterId?: string, filterSubject?: string, filterCreatorId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterSubject !== undefined) {
                localVarQueryParameter['filter[subject]'] = filterSubject;
            }

            if (filterCreatorId !== undefined) {
                localVarQueryParameter['filter[creator_id]'] = filterCreatorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns qa topic by id
         * @summary Get qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicShow: async (qaTopic: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaTopic' is not null or undefined
            assertParamExists('qaTopicShow', 'qaTopic', qaTopic)
            const localVarPath = `/api/v1/qa-topics/{qa_topic}`
                .replace(`{${"qa_topic"}}`, encodeURIComponent(String(qaTopic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new qa topic
         * @summary Create new Qa topic
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject17} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicStore: async (accept?: string, contentType?: string, data?: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given qa topic
         * @summary Update a qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject18} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicUpdate: async (qaTopic: string, accept?: string, contentType?: string, data?: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaTopic' is not null or undefined
            assertParamExists('qaTopicUpdate', 'qaTopic', qaTopic)
            const localVarPath = `/api/v1/qa-topics/{qa_topic}`
                .replace(`{${"qa_topic"}}`, encodeURIComponent(String(qaTopic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QaTopicApi - functional programming interface
 * @export
 */
export const QaTopicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QaTopicApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete a qa topic by its id
         * @summary Delete Qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicDestroy(qaTopic: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicDestroy(qaTopic, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
         * @summary Get all Qa Messages of a Qa Topic
         * @param {number} topic 
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicGetQaMessages(topic: number, filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicGetQaMessages(topic, filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all qa topic
         * @summary Show all qa topic.
         * @param {string} [filterId] 
         * @param {string} [filterSubject] 
         * @param {number} [filterCreatorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicIndex(filterId?: string, filterSubject?: string, filterCreatorId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicIndex(filterId, filterSubject, filterCreatorId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns qa topic by id
         * @summary Get qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicShow(qaTopic: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicShow(qaTopic, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new qa topic
         * @summary Create new Qa topic
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject17} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicStore(accept?: string, contentType?: string, data?: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given qa topic
         * @summary Update a qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject18} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicUpdate(qaTopic: string, accept?: string, contentType?: string, data?: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicUpdate(qaTopic, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QaTopicApi - factory interface
 * @export
 */
export const QaTopicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QaTopicApiFp(configuration)
    return {
        /**
         * Delete a qa topic by its id
         * @summary Delete Qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicDestroy(qaTopic: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.qaTopicDestroy(qaTopic, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
         * @summary Get all Qa Messages of a Qa Topic
         * @param {number} topic 
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicGetQaMessages(topic: number, filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20040> {
            return localVarFp.qaTopicGetQaMessages(topic, filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all qa topic
         * @summary Show all qa topic.
         * @param {string} [filterId] 
         * @param {string} [filterSubject] 
         * @param {number} [filterCreatorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicIndex(filterId?: string, filterSubject?: string, filterCreatorId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20041> {
            return localVarFp.qaTopicIndex(filterId, filterSubject, filterCreatorId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns qa topic by id
         * @summary Get qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicShow(qaTopic: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20042> {
            return localVarFp.qaTopicShow(qaTopic, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new qa topic
         * @summary Create new Qa topic
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject17} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicStore(accept?: string, contentType?: string, data?: InlineObject17, options?: any): AxiosPromise<InlineResponse2015> {
            return localVarFp.qaTopicStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given qa topic
         * @summary Update a qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject18} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicUpdate(qaTopic: string, accept?: string, contentType?: string, data?: InlineObject18, options?: any): AxiosPromise<InlineResponse20042> {
            return localVarFp.qaTopicUpdate(qaTopic, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for qaTopicDestroy operation in QaTopicApi.
 * @export
 * @interface QaTopicApiQaTopicDestroyRequest
 */
export interface QaTopicApiQaTopicDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof QaTopicApiQaTopicDestroy
     */
    readonly qaTopic: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaTopicApiQaTopicDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaTopicApiQaTopicDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicGetQaMessages operation in QaTopicApi.
 * @export
 * @interface QaTopicApiQaTopicGetQaMessagesRequest
 */
export interface QaTopicApiQaTopicGetQaMessagesRequest {
    /**
     * 
     * @type {number}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly topic: number

    /**
     * 
     * @type {string}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly filterContent?: string

    /**
     * 
     * @type {string}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly filterTopicId?: string

    /**
     * 
     * @type {string}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly filterSenderId?: string

    /**
     * 
     * @type {boolean}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly filterIsUnread?: boolean

    /**
     * 
     * @type {number}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaTopicApiQaTopicGetQaMessages
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicIndex operation in QaTopicApi.
 * @export
 * @interface QaTopicApiQaTopicIndexRequest
 */
export interface QaTopicApiQaTopicIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof QaTopicApiQaTopicIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof QaTopicApiQaTopicIndex
     */
    readonly filterSubject?: string

    /**
     * 
     * @type {number}
     * @memberof QaTopicApiQaTopicIndex
     */
    readonly filterCreatorId?: number

    /**
     * 
     * @type {number}
     * @memberof QaTopicApiQaTopicIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof QaTopicApiQaTopicIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof QaTopicApiQaTopicIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaTopicApiQaTopicIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaTopicApiQaTopicIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicShow operation in QaTopicApi.
 * @export
 * @interface QaTopicApiQaTopicShowRequest
 */
export interface QaTopicApiQaTopicShowRequest {
    /**
     * 
     * @type {string}
     * @memberof QaTopicApiQaTopicShow
     */
    readonly qaTopic: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaTopicApiQaTopicShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaTopicApiQaTopicShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicStore operation in QaTopicApi.
 * @export
 * @interface QaTopicApiQaTopicStoreRequest
 */
export interface QaTopicApiQaTopicStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaTopicApiQaTopicStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaTopicApiQaTopicStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject17}
     * @memberof QaTopicApiQaTopicStore
     */
    readonly data?: InlineObject17
}

/**
 * Request parameters for qaTopicUpdate operation in QaTopicApi.
 * @export
 * @interface QaTopicApiQaTopicUpdateRequest
 */
export interface QaTopicApiQaTopicUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof QaTopicApiQaTopicUpdate
     */
    readonly qaTopic: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof QaTopicApiQaTopicUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof QaTopicApiQaTopicUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject18}
     * @memberof QaTopicApiQaTopicUpdate
     */
    readonly data?: InlineObject18
}

/**
 * QaTopicApi - object-oriented interface
 * @export
 * @class QaTopicApi
 * @extends {BaseAPI}
 */
export class QaTopicApi extends BaseAPI {
    /**
     * Delete a qa topic by its id
     * @summary Delete Qa topic
     * @param {QaTopicApiQaTopicDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaTopicApi
     */
    public qaTopicDestroy(requestParameters: QaTopicApiQaTopicDestroyRequest, options?: any) {
        return QaTopicApiFp(this.configuration).qaTopicDestroy(requestParameters.qaTopic, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
     * @summary Get all Qa Messages of a Qa Topic
     * @param {QaTopicApiQaTopicGetQaMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaTopicApi
     */
    public qaTopicGetQaMessages(requestParameters: QaTopicApiQaTopicGetQaMessagesRequest, options?: any) {
        return QaTopicApiFp(this.configuration).qaTopicGetQaMessages(requestParameters.topic, requestParameters.filterId, requestParameters.filterContent, requestParameters.filterTopicId, requestParameters.filterSenderId, requestParameters.filterIsUnread, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all qa topic
     * @summary Show all qa topic.
     * @param {QaTopicApiQaTopicIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaTopicApi
     */
    public qaTopicIndex(requestParameters: QaTopicApiQaTopicIndexRequest = {}, options?: any) {
        return QaTopicApiFp(this.configuration).qaTopicIndex(requestParameters.filterId, requestParameters.filterSubject, requestParameters.filterCreatorId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns qa topic by id
     * @summary Get qa topic
     * @param {QaTopicApiQaTopicShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaTopicApi
     */
    public qaTopicShow(requestParameters: QaTopicApiQaTopicShowRequest, options?: any) {
        return QaTopicApiFp(this.configuration).qaTopicShow(requestParameters.qaTopic, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new qa topic
     * @summary Create new Qa topic
     * @param {QaTopicApiQaTopicStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaTopicApi
     */
    public qaTopicStore(requestParameters: QaTopicApiQaTopicStoreRequest = {}, options?: any) {
        return QaTopicApiFp(this.configuration).qaTopicStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given qa topic
     * @summary Update a qa topic
     * @param {QaTopicApiQaTopicUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QaTopicApi
     */
    public qaTopicUpdate(requestParameters: QaTopicApiQaTopicUpdateRequest, options?: any) {
        return QaTopicApiFp(this.configuration).qaTopicUpdate(requestParameters.qaTopic, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportApi - axios parameter creator
 * @export
 */
export const ReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all report
         * @summary Show all report.
         * @param {string} [filterId] 
         * @param {string} [filterPeriodBefore] 
         * @param {string} [filterPeriodAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportIndex: async (filterId?: string, filterPeriodBefore?: string, filterPeriodAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterPeriodBefore !== undefined) {
                localVarQueryParameter['filter[period_before]'] = filterPeriodBefore;
            }

            if (filterPeriodAfter !== undefined) {
                localVarQueryParameter['filter[period_after]'] = filterPeriodAfter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns report by id
         * @summary Get report
         * @param {string} report 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportShow: async (report: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'report' is not null or undefined
            assertParamExists('reportShow', 'report', report)
            const localVarPath = `/api/v1/reports/{report}`
                .replace(`{${"report"}}`, encodeURIComponent(String(report)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all report
         * @summary Show all report.
         * @param {string} [filterId] 
         * @param {string} [filterPeriodBefore] 
         * @param {string} [filterPeriodAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportIndex(filterId?: string, filterPeriodBefore?: string, filterPeriodAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20056>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportIndex(filterId, filterPeriodBefore, filterPeriodAfter, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns report by id
         * @summary Get report
         * @param {string} report 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportShow(report: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20057>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportShow(report, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportApiFp(configuration)
    return {
        /**
         * Show all report
         * @summary Show all report.
         * @param {string} [filterId] 
         * @param {string} [filterPeriodBefore] 
         * @param {string} [filterPeriodAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportIndex(filterId?: string, filterPeriodBefore?: string, filterPeriodAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20056> {
            return localVarFp.reportIndex(filterId, filterPeriodBefore, filterPeriodAfter, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns report by id
         * @summary Get report
         * @param {string} report 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportShow(report: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20057> {
            return localVarFp.reportShow(report, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for reportIndex operation in ReportApi.
 * @export
 * @interface ReportApiReportIndexRequest
 */
export interface ReportApiReportIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ReportApiReportIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof ReportApiReportIndex
     */
    readonly filterPeriodBefore?: string

    /**
     * 
     * @type {string}
     * @memberof ReportApiReportIndex
     */
    readonly filterPeriodAfter?: string

    /**
     * 
     * @type {number}
     * @memberof ReportApiReportIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ReportApiReportIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof ReportApiReportIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ReportApiReportIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ReportApiReportIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for reportShow operation in ReportApi.
 * @export
 * @interface ReportApiReportShowRequest
 */
export interface ReportApiReportShowRequest {
    /**
     * 
     * @type {string}
     * @memberof ReportApiReportShow
     */
    readonly report: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof ReportApiReportShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof ReportApiReportShow
     */
    readonly contentType?: string
}

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
    /**
     * Show all report
     * @summary Show all report.
     * @param {ReportApiReportIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportIndex(requestParameters: ReportApiReportIndexRequest = {}, options?: any) {
        return ReportApiFp(this.configuration).reportIndex(requestParameters.filterId, requestParameters.filterPeriodBefore, requestParameters.filterPeriodAfter, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns report by id
     * @summary Get report
     * @param {ReportApiReportShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportShow(requestParameters: ReportApiReportShowRequest, options?: any) {
        return ReportApiFp(this.configuration).reportShow(requestParameters.report, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RuleApi - axios parameter creator
 * @export
 */
export const RuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show the validation rules for creating activityComment
         * @summary Get create ActivityComment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activity-comments/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing activityComment
         * @summary Show edit activityComment rules
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentEdit: async (activityComment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityComment' is not null or undefined
            assertParamExists('activityCommentEdit', 'activityComment', activityComment)
            const localVarPath = `/api/v1/activity-comments/{activity_comment}/edit`
                .replace(`{${"activity_comment"}}`, encodeURIComponent(String(activityComment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating activity
         * @summary Show create product activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activities/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing activity
         * @summary Show edit activity rules
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityEdit: async (activity: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityEdit', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}/edit`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating address
         * @summary Show create product address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/addresses/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing address
         * @summary Show edit address rules
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressEdit: async (address: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressEdit', 'address', address)
            const localVarPath = `/api/v1/addresses/{address}/edit`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating customer
         * @summary Show create customer rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing customer
         * @summary Show edit customer rules
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerEdit: async (customer: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerEdit', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}/edit`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating lead
         * @summary Show create product lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing lead
         * @summary Show edit lead rules
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadEdit: async (lead: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadEdit', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}/edit`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating payment
         * @summary Get create payment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing payment
         * @summary Show edit payment rules
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentEdit: async (payment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('paymentEdit', 'payment', payment)
            const localVarPath = `/api/v1/payments/{payment}/edit`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating qa message
         * @summary Get create qa message rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-messages/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing qa message
         * @summary Show edit qa message rules
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageEdit: async (qaMessage: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaMessage' is not null or undefined
            assertParamExists('qaMessageEdit', 'qaMessage', qaMessage)
            const localVarPath = `/api/v1/qa-messages/{qa_message}/edit`
                .replace(`{${"qa_message"}}`, encodeURIComponent(String(qaMessage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating qa topic
         * @summary Get create qa topic rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-topics/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing qa topic
         * @summary Show edit qa topic rules
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicEdit: async (qaTopic: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaTopic' is not null or undefined
            assertParamExists('qaTopicEdit', 'qaTopic', qaTopic)
            const localVarPath = `/api/v1/qa-topics/{qa_topic}/edit`
                .replace(`{${"qa_topic"}}`, encodeURIComponent(String(qaTopic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RuleApi - functional programming interface
 * @export
 */
export const RuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Show the validation rules for creating activityComment
         * @summary Get create ActivityComment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing activityComment
         * @summary Show edit activityComment rules
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentEdit(activityComment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentEdit(activityComment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating activity
         * @summary Show create product activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing activity
         * @summary Show edit activity rules
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityEdit(activity: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityEdit(activity, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating address
         * @summary Show create product address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing address
         * @summary Show edit address rules
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressEdit(address: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressEdit(address, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating customer
         * @summary Show create customer rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing customer
         * @summary Show edit customer rules
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerEdit(customer: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerEdit(customer, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating lead
         * @summary Show create product lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing lead
         * @summary Show edit lead rules
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadEdit(lead: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadEdit(lead, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating payment
         * @summary Get create payment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing payment
         * @summary Show edit payment rules
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentEdit(payment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentEdit(payment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating qa message
         * @summary Get create qa message rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing qa message
         * @summary Show edit qa message rules
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageEdit(qaMessage: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageEdit(qaMessage, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating qa topic
         * @summary Get create qa topic rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing qa topic
         * @summary Show edit qa topic rules
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicEdit(qaTopic: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicEdit(qaTopic, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RuleApi - factory interface
 * @export
 */
export const RuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RuleApiFp(configuration)
    return {
        /**
         * Show the validation rules for creating activityComment
         * @summary Get create ActivityComment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.activityCommentCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing activityComment
         * @summary Show edit activityComment rules
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentEdit(activityComment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.activityCommentEdit(activityComment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating activity
         * @summary Show create product activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.activityCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing activity
         * @summary Show edit activity rules
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityEdit(activity: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.activityEdit(activity, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating address
         * @summary Show create product address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.addressCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing address
         * @summary Show edit address rules
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressEdit(address: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.addressEdit(address, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating customer
         * @summary Show create customer rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.customerCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing customer
         * @summary Show edit customer rules
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerEdit(customer: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.customerEdit(customer, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating lead
         * @summary Show create product lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.leadCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing lead
         * @summary Show edit lead rules
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadEdit(lead: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.leadEdit(lead, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating payment
         * @summary Get create payment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.paymentCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing payment
         * @summary Show edit payment rules
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentEdit(payment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.paymentEdit(payment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating qa message
         * @summary Get create qa message rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.qaMessageCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing qa message
         * @summary Show edit qa message rules
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageEdit(qaMessage: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.qaMessageEdit(qaMessage, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating qa topic
         * @summary Get create qa topic rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.qaTopicCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing qa topic
         * @summary Show edit qa topic rules
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicEdit(qaTopic: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.qaTopicEdit(qaTopic, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activityCommentCreate operation in RuleApi.
 * @export
 * @interface RuleApiActivityCommentCreateRequest
 */
export interface RuleApiActivityCommentCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiActivityCommentCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiActivityCommentCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCommentEdit operation in RuleApi.
 * @export
 * @interface RuleApiActivityCommentEditRequest
 */
export interface RuleApiActivityCommentEditRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleApiActivityCommentEdit
     */
    readonly activityComment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiActivityCommentEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiActivityCommentEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCreate operation in RuleApi.
 * @export
 * @interface RuleApiActivityCreateRequest
 */
export interface RuleApiActivityCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiActivityCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiActivityCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityEdit operation in RuleApi.
 * @export
 * @interface RuleApiActivityEditRequest
 */
export interface RuleApiActivityEditRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleApiActivityEdit
     */
    readonly activity: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiActivityEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiActivityEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressCreate operation in RuleApi.
 * @export
 * @interface RuleApiAddressCreateRequest
 */
export interface RuleApiAddressCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiAddressCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiAddressCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressEdit operation in RuleApi.
 * @export
 * @interface RuleApiAddressEditRequest
 */
export interface RuleApiAddressEditRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleApiAddressEdit
     */
    readonly address: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiAddressEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiAddressEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerCreate operation in RuleApi.
 * @export
 * @interface RuleApiCustomerCreateRequest
 */
export interface RuleApiCustomerCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiCustomerCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiCustomerCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerEdit operation in RuleApi.
 * @export
 * @interface RuleApiCustomerEditRequest
 */
export interface RuleApiCustomerEditRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleApiCustomerEdit
     */
    readonly customer: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiCustomerEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiCustomerEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadCreate operation in RuleApi.
 * @export
 * @interface RuleApiLeadCreateRequest
 */
export interface RuleApiLeadCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiLeadCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiLeadCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadEdit operation in RuleApi.
 * @export
 * @interface RuleApiLeadEditRequest
 */
export interface RuleApiLeadEditRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleApiLeadEdit
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiLeadEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiLeadEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentCreate operation in RuleApi.
 * @export
 * @interface RuleApiPaymentCreateRequest
 */
export interface RuleApiPaymentCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiPaymentCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiPaymentCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentEdit operation in RuleApi.
 * @export
 * @interface RuleApiPaymentEditRequest
 */
export interface RuleApiPaymentEditRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleApiPaymentEdit
     */
    readonly payment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiPaymentEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiPaymentEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageCreate operation in RuleApi.
 * @export
 * @interface RuleApiQaMessageCreateRequest
 */
export interface RuleApiQaMessageCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiQaMessageCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiQaMessageCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageEdit operation in RuleApi.
 * @export
 * @interface RuleApiQaMessageEditRequest
 */
export interface RuleApiQaMessageEditRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleApiQaMessageEdit
     */
    readonly qaMessage: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiQaMessageEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiQaMessageEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicCreate operation in RuleApi.
 * @export
 * @interface RuleApiQaTopicCreateRequest
 */
export interface RuleApiQaTopicCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiQaTopicCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiQaTopicCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicEdit operation in RuleApi.
 * @export
 * @interface RuleApiQaTopicEditRequest
 */
export interface RuleApiQaTopicEditRequest {
    /**
     * 
     * @type {string}
     * @memberof RuleApiQaTopicEdit
     */
    readonly qaTopic: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof RuleApiQaTopicEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof RuleApiQaTopicEdit
     */
    readonly contentType?: string
}

/**
 * RuleApi - object-oriented interface
 * @export
 * @class RuleApi
 * @extends {BaseAPI}
 */
export class RuleApi extends BaseAPI {
    /**
     * Show the validation rules for creating activityComment
     * @summary Get create ActivityComment rule
     * @param {RuleApiActivityCommentCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public activityCommentCreate(requestParameters: RuleApiActivityCommentCreateRequest = {}, options?: any) {
        return RuleApiFp(this.configuration).activityCommentCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing activityComment
     * @summary Show edit activityComment rules
     * @param {RuleApiActivityCommentEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public activityCommentEdit(requestParameters: RuleApiActivityCommentEditRequest, options?: any) {
        return RuleApiFp(this.configuration).activityCommentEdit(requestParameters.activityComment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating activity
     * @summary Show create product activity
     * @param {RuleApiActivityCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public activityCreate(requestParameters: RuleApiActivityCreateRequest = {}, options?: any) {
        return RuleApiFp(this.configuration).activityCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing activity
     * @summary Show edit activity rules
     * @param {RuleApiActivityEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public activityEdit(requestParameters: RuleApiActivityEditRequest, options?: any) {
        return RuleApiFp(this.configuration).activityEdit(requestParameters.activity, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating address
     * @summary Show create product address
     * @param {RuleApiAddressCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public addressCreate(requestParameters: RuleApiAddressCreateRequest = {}, options?: any) {
        return RuleApiFp(this.configuration).addressCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing address
     * @summary Show edit address rules
     * @param {RuleApiAddressEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public addressEdit(requestParameters: RuleApiAddressEditRequest, options?: any) {
        return RuleApiFp(this.configuration).addressEdit(requestParameters.address, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating customer
     * @summary Show create customer rule
     * @param {RuleApiCustomerCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public customerCreate(requestParameters: RuleApiCustomerCreateRequest = {}, options?: any) {
        return RuleApiFp(this.configuration).customerCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing customer
     * @summary Show edit customer rules
     * @param {RuleApiCustomerEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public customerEdit(requestParameters: RuleApiCustomerEditRequest, options?: any) {
        return RuleApiFp(this.configuration).customerEdit(requestParameters.customer, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating lead
     * @summary Show create product lead
     * @param {RuleApiLeadCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public leadCreate(requestParameters: RuleApiLeadCreateRequest = {}, options?: any) {
        return RuleApiFp(this.configuration).leadCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing lead
     * @summary Show edit lead rules
     * @param {RuleApiLeadEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public leadEdit(requestParameters: RuleApiLeadEditRequest, options?: any) {
        return RuleApiFp(this.configuration).leadEdit(requestParameters.lead, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating payment
     * @summary Get create payment rule
     * @param {RuleApiPaymentCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public paymentCreate(requestParameters: RuleApiPaymentCreateRequest = {}, options?: any) {
        return RuleApiFp(this.configuration).paymentCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing payment
     * @summary Show edit payment rules
     * @param {RuleApiPaymentEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public paymentEdit(requestParameters: RuleApiPaymentEditRequest, options?: any) {
        return RuleApiFp(this.configuration).paymentEdit(requestParameters.payment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating qa message
     * @summary Get create qa message rule
     * @param {RuleApiQaMessageCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public qaMessageCreate(requestParameters: RuleApiQaMessageCreateRequest = {}, options?: any) {
        return RuleApiFp(this.configuration).qaMessageCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing qa message
     * @summary Show edit qa message rules
     * @param {RuleApiQaMessageEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public qaMessageEdit(requestParameters: RuleApiQaMessageEditRequest, options?: any) {
        return RuleApiFp(this.configuration).qaMessageEdit(requestParameters.qaMessage, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating qa topic
     * @summary Get create qa topic rule
     * @param {RuleApiQaTopicCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public qaTopicCreate(requestParameters: RuleApiQaTopicCreateRequest = {}, options?: any) {
        return RuleApiFp(this.configuration).qaTopicCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing qa topic
     * @summary Show edit qa topic rules
     * @param {RuleApiQaTopicEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RuleApi
     */
    public qaTopicEdit(requestParameters: RuleApiQaTopicEditRequest, options?: any) {
        return RuleApiFp(this.configuration).qaTopicEdit(requestParameters.qaTopic, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SmsChannelApi - axios parameter creator
 * @export
 */
export const SmsChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all SMS channels available for this user
         * @summary Show all SMS channels.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsChannelIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sms-channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns SMS channel by id
         * @summary Get SMS channel
         * @param {string} smsChannel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsChannelShow: async (smsChannel: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'smsChannel' is not null or undefined
            assertParamExists('smsChannelShow', 'smsChannel', smsChannel)
            const localVarPath = `/api/v1/sms-channels/{sms_channel}`
                .replace(`{${"sms_channel"}}`, encodeURIComponent(String(smsChannel)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SmsChannelApi - functional programming interface
 * @export
 */
export const SmsChannelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SmsChannelApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all SMS channels available for this user
         * @summary Show all SMS channels.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smsChannelIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smsChannelIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns SMS channel by id
         * @summary Get SMS channel
         * @param {string} smsChannel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smsChannelShow(smsChannel: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smsChannelShow(smsChannel, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SmsChannelApi - factory interface
 * @export
 */
export const SmsChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SmsChannelApiFp(configuration)
    return {
        /**
         * Show all SMS channels available for this user
         * @summary Show all SMS channels.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsChannelIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.smsChannelIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns SMS channel by id
         * @summary Get SMS channel
         * @param {string} smsChannel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsChannelShow(smsChannel: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.smsChannelShow(smsChannel, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for smsChannelIndex operation in SmsChannelApi.
 * @export
 * @interface SmsChannelApiSmsChannelIndexRequest
 */
export interface SmsChannelApiSmsChannelIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof SmsChannelApiSmsChannelIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof SmsChannelApiSmsChannelIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof SmsChannelApiSmsChannelIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof SmsChannelApiSmsChannelIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof SmsChannelApiSmsChannelIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof SmsChannelApiSmsChannelIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof SmsChannelApiSmsChannelIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for smsChannelShow operation in SmsChannelApi.
 * @export
 * @interface SmsChannelApiSmsChannelShowRequest
 */
export interface SmsChannelApiSmsChannelShowRequest {
    /**
     * 
     * @type {string}
     * @memberof SmsChannelApiSmsChannelShow
     */
    readonly smsChannel: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof SmsChannelApiSmsChannelShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof SmsChannelApiSmsChannelShow
     */
    readonly contentType?: string
}

/**
 * SmsChannelApi - object-oriented interface
 * @export
 * @class SmsChannelApi
 * @extends {BaseAPI}
 */
export class SmsChannelApi extends BaseAPI {
    /**
     * Show all SMS channels available for this user
     * @summary Show all SMS channels.
     * @param {SmsChannelApiSmsChannelIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmsChannelApi
     */
    public smsChannelIndex(requestParameters: SmsChannelApiSmsChannelIndexRequest = {}, options?: any) {
        return SmsChannelApiFp(this.configuration).smsChannelIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns SMS channel by id
     * @summary Get SMS channel
     * @param {SmsChannelApiSmsChannelShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmsChannelApi
     */
    public smsChannelShow(requestParameters: SmsChannelApiSmsChannelShowRequest, options?: any) {
        return SmsChannelApiFp(this.configuration).smsChannelShow(requestParameters.smsChannel, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockApi - axios parameter creator
 * @export
 */
export const StockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all stock
         * @summary Show all stock.
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockIndex: async (filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterProductUnitId !== undefined) {
                localVarQueryParameter['filter[product_unit_id]'] = filterProductUnitId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all stock with additional loaded properties.
         * @summary Show all stock (with extended data).
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockIndexExtended: async (filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/stocks/extended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterProductUnitId !== undefined) {
                localVarQueryParameter['filter[product_unit_id]'] = filterProductUnitId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns stock by id
         * @summary Get stock
         * @param {string} stock 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShow: async (stock: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stock' is not null or undefined
            assertParamExists('stockShow', 'stock', stock)
            const localVarPath = `/api/v1/stocks/{stock}`
                .replace(`{${"stock"}}`, encodeURIComponent(String(stock)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockApi - functional programming interface
 * @export
 */
export const StockApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all stock
         * @summary Show all stock.
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockIndex(filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20054>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockIndex(filterId, filterChannelId, filterProductUnitId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all stock with additional loaded properties.
         * @summary Show all stock (with extended data).
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockIndexExtended(filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20053>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockIndexExtended(filterId, filterChannelId, filterProductUnitId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns stock by id
         * @summary Get stock
         * @param {string} stock 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockShow(stock: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockShow(stock, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockApi - factory interface
 * @export
 */
export const StockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockApiFp(configuration)
    return {
        /**
         * Show all stock
         * @summary Show all stock.
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockIndex(filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20054> {
            return localVarFp.stockIndex(filterId, filterChannelId, filterProductUnitId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all stock with additional loaded properties.
         * @summary Show all stock (with extended data).
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockIndexExtended(filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20053> {
            return localVarFp.stockIndexExtended(filterId, filterChannelId, filterProductUnitId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns stock by id
         * @summary Get stock
         * @param {string} stock 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShow(stock: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20055> {
            return localVarFp.stockShow(stock, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for stockIndex operation in StockApi.
 * @export
 * @interface StockApiStockIndexRequest
 */
export interface StockApiStockIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof StockApiStockIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof StockApiStockIndex
     */
    readonly filterChannelId?: string

    /**
     * 
     * @type {string}
     * @memberof StockApiStockIndex
     */
    readonly filterProductUnitId?: string

    /**
     * 
     * @type {number}
     * @memberof StockApiStockIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof StockApiStockIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof StockApiStockIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof StockApiStockIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof StockApiStockIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for stockIndexExtended operation in StockApi.
 * @export
 * @interface StockApiStockIndexExtendedRequest
 */
export interface StockApiStockIndexExtendedRequest {
    /**
     * 
     * @type {string}
     * @memberof StockApiStockIndexExtended
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof StockApiStockIndexExtended
     */
    readonly filterChannelId?: string

    /**
     * 
     * @type {string}
     * @memberof StockApiStockIndexExtended
     */
    readonly filterProductUnitId?: string

    /**
     * 
     * @type {number}
     * @memberof StockApiStockIndexExtended
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof StockApiStockIndexExtended
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof StockApiStockIndexExtended
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof StockApiStockIndexExtended
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof StockApiStockIndexExtended
     */
    readonly contentType?: string
}

/**
 * Request parameters for stockShow operation in StockApi.
 * @export
 * @interface StockApiStockShowRequest
 */
export interface StockApiStockShowRequest {
    /**
     * 
     * @type {string}
     * @memberof StockApiStockShow
     */
    readonly stock: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof StockApiStockShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof StockApiStockShow
     */
    readonly contentType?: string
}

/**
 * StockApi - object-oriented interface
 * @export
 * @class StockApi
 * @extends {BaseAPI}
 */
export class StockApi extends BaseAPI {
    /**
     * Show all stock
     * @summary Show all stock.
     * @param {StockApiStockIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockIndex(requestParameters: StockApiStockIndexRequest = {}, options?: any) {
        return StockApiFp(this.configuration).stockIndex(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterProductUnitId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all stock with additional loaded properties.
     * @summary Show all stock (with extended data).
     * @param {StockApiStockIndexExtendedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockIndexExtended(requestParameters: StockApiStockIndexExtendedRequest = {}, options?: any) {
        return StockApiFp(this.configuration).stockIndexExtended(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterProductUnitId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns stock by id
     * @summary Get stock
     * @param {StockApiStockShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockShow(requestParameters: StockApiStockShowRequest, options?: any) {
        return StockApiFp(this.configuration).stockShow(requestParameters.stock, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TargetApi - axios parameter creator
 * @export
 */
export const TargetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show all target
         * @summary Show all target.
         * @param {string} [filterId] 
         * @param {number} [filterReportId] 
         * @param {number} [filterIsDashboard] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {'COMPANY' | 'CHANNEL' | 'USER'} [filterReportableType] 
         * @param {string} [filterReportableIds] 
         * @param {'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'} [filterType] 
         * @param {number} [filterSupervisorTypeLevel] 
         * @param {number} [filterCompanyId] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetIndex: async (filterId?: string, filterReportId?: number, filterIsDashboard?: number, filterStartAfter?: string, filterEndBefore?: string, filterReportableType?: 'COMPANY' | 'CHANNEL' | 'USER', filterReportableIds?: string, filterType?: 'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT', filterSupervisorTypeLevel?: number, filterCompanyId?: number, filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/targets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterReportId !== undefined) {
                localVarQueryParameter['filter[report_id]'] = filterReportId;
            }

            if (filterIsDashboard !== undefined) {
                localVarQueryParameter['filter[is_dashboard]'] = filterIsDashboard;
            }

            if (filterStartAfter !== undefined) {
                localVarQueryParameter['filter[start_after]'] = filterStartAfter;
            }

            if (filterEndBefore !== undefined) {
                localVarQueryParameter['filter[end_before]'] = filterEndBefore;
            }

            if (filterReportableType !== undefined) {
                localVarQueryParameter['filter[reportable_type]'] = filterReportableType;
            }

            if (filterReportableIds !== undefined) {
                localVarQueryParameter['filter[reportable_ids]'] = filterReportableIds;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterSupervisorTypeLevel !== undefined) {
                localVarQueryParameter['filter[supervisor_type_level]'] = filterSupervisorTypeLevel;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterDescendantOf !== undefined) {
                localVarQueryParameter['filter[descendant_of]'] = filterDescendantOf;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TargetApi - functional programming interface
 * @export
 */
export const TargetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TargetApiAxiosParamCreator(configuration)
    return {
        /**
         * Show all target
         * @summary Show all target.
         * @param {string} [filterId] 
         * @param {number} [filterReportId] 
         * @param {number} [filterIsDashboard] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {'COMPANY' | 'CHANNEL' | 'USER'} [filterReportableType] 
         * @param {string} [filterReportableIds] 
         * @param {'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'} [filterType] 
         * @param {number} [filterSupervisorTypeLevel] 
         * @param {number} [filterCompanyId] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async targetIndex(filterId?: string, filterReportId?: number, filterIsDashboard?: number, filterStartAfter?: string, filterEndBefore?: string, filterReportableType?: 'COMPANY' | 'CHANNEL' | 'USER', filterReportableIds?: string, filterType?: 'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT', filterSupervisorTypeLevel?: number, filterCompanyId?: number, filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20058>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.targetIndex(filterId, filterReportId, filterIsDashboard, filterStartAfter, filterEndBefore, filterReportableType, filterReportableIds, filterType, filterSupervisorTypeLevel, filterCompanyId, filterDescendantOf, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TargetApi - factory interface
 * @export
 */
export const TargetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TargetApiFp(configuration)
    return {
        /**
         * Show all target
         * @summary Show all target.
         * @param {string} [filterId] 
         * @param {number} [filterReportId] 
         * @param {number} [filterIsDashboard] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {'COMPANY' | 'CHANNEL' | 'USER'} [filterReportableType] 
         * @param {string} [filterReportableIds] 
         * @param {'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'} [filterType] 
         * @param {number} [filterSupervisorTypeLevel] 
         * @param {number} [filterCompanyId] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetIndex(filterId?: string, filterReportId?: number, filterIsDashboard?: number, filterStartAfter?: string, filterEndBefore?: string, filterReportableType?: 'COMPANY' | 'CHANNEL' | 'USER', filterReportableIds?: string, filterType?: 'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT', filterSupervisorTypeLevel?: number, filterCompanyId?: number, filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20058> {
            return localVarFp.targetIndex(filterId, filterReportId, filterIsDashboard, filterStartAfter, filterEndBefore, filterReportableType, filterReportableIds, filterType, filterSupervisorTypeLevel, filterCompanyId, filterDescendantOf, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for targetIndex operation in TargetApi.
 * @export
 * @interface TargetApiTargetIndexRequest
 */
export interface TargetApiTargetIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof TargetApiTargetIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof TargetApiTargetIndex
     */
    readonly filterReportId?: number

    /**
     * 
     * @type {number}
     * @memberof TargetApiTargetIndex
     */
    readonly filterIsDashboard?: number

    /**
     * 
     * @type {string}
     * @memberof TargetApiTargetIndex
     */
    readonly filterStartAfter?: string

    /**
     * 
     * @type {string}
     * @memberof TargetApiTargetIndex
     */
    readonly filterEndBefore?: string

    /**
     * 
     * @type {'COMPANY' | 'CHANNEL' | 'USER'}
     * @memberof TargetApiTargetIndex
     */
    readonly filterReportableType?: 'COMPANY' | 'CHANNEL' | 'USER'

    /**
     * 
     * @type {string}
     * @memberof TargetApiTargetIndex
     */
    readonly filterReportableIds?: string

    /**
     * 
     * @type {'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'}
     * @memberof TargetApiTargetIndex
     */
    readonly filterType?: 'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'

    /**
     * 
     * @type {number}
     * @memberof TargetApiTargetIndex
     */
    readonly filterSupervisorTypeLevel?: number

    /**
     * 
     * @type {number}
     * @memberof TargetApiTargetIndex
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {number}
     * @memberof TargetApiTargetIndex
     */
    readonly filterDescendantOf?: number

    /**
     * 
     * @type {number}
     * @memberof TargetApiTargetIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof TargetApiTargetIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof TargetApiTargetIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof TargetApiTargetIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof TargetApiTargetIndex
     */
    readonly contentType?: string
}

/**
 * TargetApi - object-oriented interface
 * @export
 * @class TargetApi
 * @extends {BaseAPI}
 */
export class TargetApi extends BaseAPI {
    /**
     * Show all target
     * @summary Show all target.
     * @param {TargetApiTargetIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TargetApi
     */
    public targetIndex(requestParameters: TargetApiTargetIndexRequest = {}, options?: any) {
        return TargetApiFp(this.configuration).targetIndex(requestParameters.filterId, requestParameters.filterReportId, requestParameters.filterIsDashboard, requestParameters.filterStartAfter, requestParameters.filterEndBefore, requestParameters.filterReportableType, requestParameters.filterReportableIds, requestParameters.filterType, requestParameters.filterSupervisorTypeLevel, requestParameters.filterCompanyId, requestParameters.filterDescendantOf, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approve order
         * @summary Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject25} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderApprove: async (order: string, accept?: string, contentType?: string, data?: InlineObject25, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderApprove', 'order', order)
            const localVarPath = `/api/v1/orders/approve/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change password of currently logged in user
         * @summary Change password
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePassword: async (accept?: string, contentType?: string, data?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all users registered in the system. This is currently unfiltered, but in the future we may filter to limit user visibility.
         * @summary Show all users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIndex: async (filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterSupervisorId !== undefined) {
                localVarQueryParameter['filter[supervisor_id]'] = filterSupervisorId;
            }

            if (filterSupervisorTypeId !== undefined) {
                localVarQueryParameter['filter[supervisor_type_id]'] = filterSupervisorTypeId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterDescendantOf !== undefined) {
                localVarQueryParameter['filter[descendant_of]'] = filterDescendantOf;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Front end should filter by company id
         * @summary Show list of available users to look into the report.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListForReport: async (filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/report-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterSupervisorId !== undefined) {
                localVarQueryParameter['filter[supervisor_id]'] = filterSupervisorId;
            }

            if (filterSupervisorTypeId !== undefined) {
                localVarQueryParameter['filter[supervisor_type_id]'] = filterSupervisorTypeId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterDescendantOf !== undefined) {
                localVarQueryParameter['filter[descendant_of]'] = filterDescendantOf;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user resource of the currently logged in user
         * @summary Get logged in user detail
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMe: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the default channel for this user. Default channel must be set before user can access tenanted resources.
         * @summary Set default channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetDefaultChannel: async (channel: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('userSetDefaultChannel', 'channel', channel)
            const localVarPath = `/api/v1/users/channel/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Currently allow access to all users on the system
         * @summary Get user detail
         * @param {string} user 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShow: async (user: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('userShow', 'user', user)
            const localVarPath = `/api/v1/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all users that is supervised by this user (all child and grandchild nodes). Does not include data of currently logged in user and data of supervisor.
         * @summary Show all supervised users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervised: async (filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/supervised`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterSupervisorId !== undefined) {
                localVarQueryParameter['filter[supervisor_id]'] = filterSupervisorId;
            }

            if (filterSupervisorTypeId !== undefined) {
                localVarQueryParameter['filter[supervisor_type_id]'] = filterSupervisorTypeId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterDescendantOf !== undefined) {
                localVarQueryParameter['filter[descendant_of]'] = filterDescendantOf;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the detail of logged in user\'s supervisor (direct parent)
         * @summary Get detail of supervisor
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervisor: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/supervisor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list supervisor types
         * @summary Get list supervisor types
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervisorTypes: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/supervisor-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Approve order
         * @summary Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject25} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderApprove(order: string, accept?: string, contentType?: string, data?: InlineObject25, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderApprove(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change password of currently logged in user
         * @summary Change password
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userChangePassword(accept?: string, contentType?: string, data?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userChangePassword(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all users registered in the system. This is currently unfiltered, but in the future we may filter to limit user visibility.
         * @summary Show all users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userIndex(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userIndex(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Front end should filter by company id
         * @summary Show list of available users to look into the report.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListForReport(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListForReport(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user resource of the currently logged in user
         * @summary Get logged in user detail
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMe(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMe(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the default channel for this user. Default channel must be set before user can access tenanted resources.
         * @summary Set default channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSetDefaultChannel(channel: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSetDefaultChannel(channel, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Currently allow access to all users on the system
         * @summary Get user detail
         * @param {string} user 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShow(user: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShow(user, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all users that is supervised by this user (all child and grandchild nodes). Does not include data of currently logged in user and data of supervisor.
         * @summary Show all supervised users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSupervised(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSupervised(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the detail of logged in user\'s supervisor (direct parent)
         * @summary Get detail of supervisor
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSupervisor(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSupervisor(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list supervisor types
         * @summary Get list supervisor types
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSupervisorTypes(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSupervisorTypes(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Approve order
         * @summary Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject25} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderApprove(order: string, accept?: string, contentType?: string, data?: InlineObject25, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderApprove(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Change password of currently logged in user
         * @summary Change password
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePassword(accept?: string, contentType?: string, data?: InlineObject, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.userChangePassword(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all users registered in the system. This is currently unfiltered, but in the future we may filter to limit user visibility.
         * @summary Show all users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIndex(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.userIndex(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Front end should filter by company id
         * @summary Show list of available users to look into the report.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListForReport(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.userListForReport(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user resource of the currently logged in user
         * @summary Get logged in user detail
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMe(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.userMe(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the default channel for this user. Default channel must be set before user can access tenanted resources.
         * @summary Set default channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetDefaultChannel(channel: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.userSetDefaultChannel(channel, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Currently allow access to all users on the system
         * @summary Get user detail
         * @param {string} user 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShow(user: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.userShow(user, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all users that is supervised by this user (all child and grandchild nodes). Does not include data of currently logged in user and data of supervisor.
         * @summary Show all supervised users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervised(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.userSupervised(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the detail of logged in user\'s supervisor (direct parent)
         * @summary Get detail of supervisor
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervisor(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.userSupervisor(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list supervisor types
         * @summary Get list supervisor types
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervisorTypes(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.userSupervisorTypes(accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for orderApprove operation in UserApi.
 * @export
 * @interface UserApiOrderApproveRequest
 */
export interface UserApiOrderApproveRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiOrderApprove
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiOrderApprove
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiOrderApprove
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject25}
     * @memberof UserApiOrderApprove
     */
    readonly data?: InlineObject25
}

/**
 * Request parameters for userChangePassword operation in UserApi.
 * @export
 * @interface UserApiUserChangePasswordRequest
 */
export interface UserApiUserChangePasswordRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiUserChangePassword
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiUserChangePassword
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject}
     * @memberof UserApiUserChangePassword
     */
    readonly data?: InlineObject
}

/**
 * Request parameters for userIndex operation in UserApi.
 * @export
 * @interface UserApiUserIndexRequest
 */
export interface UserApiUserIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUserIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiUserIndex
     */
    readonly filterChannelId?: number

    /**
     * 
     * @type {string}
     * @memberof UserApiUserIndex
     */
    readonly filterSupervisorId?: string

    /**
     * 
     * @type {string}
     * @memberof UserApiUserIndex
     */
    readonly filterSupervisorTypeId?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiUserIndex
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {string}
     * @memberof UserApiUserIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'}
     * @memberof UserApiUserIndex
     */
    readonly filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'

    /**
     * 
     * @type {number}
     * @memberof UserApiUserIndex
     */
    readonly filterDescendantOf?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiUserIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiUserIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof UserApiUserIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiUserIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiUserIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for userListForReport operation in UserApi.
 * @export
 * @interface UserApiUserListForReportRequest
 */
export interface UserApiUserListForReportRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUserListForReport
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiUserListForReport
     */
    readonly filterChannelId?: number

    /**
     * 
     * @type {string}
     * @memberof UserApiUserListForReport
     */
    readonly filterSupervisorId?: string

    /**
     * 
     * @type {string}
     * @memberof UserApiUserListForReport
     */
    readonly filterSupervisorTypeId?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiUserListForReport
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {string}
     * @memberof UserApiUserListForReport
     */
    readonly filterName?: string

    /**
     * 
     * @type {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'}
     * @memberof UserApiUserListForReport
     */
    readonly filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'

    /**
     * 
     * @type {number}
     * @memberof UserApiUserListForReport
     */
    readonly filterDescendantOf?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiUserListForReport
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiUserListForReport
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof UserApiUserListForReport
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiUserListForReport
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiUserListForReport
     */
    readonly contentType?: string
}

/**
 * Request parameters for userMe operation in UserApi.
 * @export
 * @interface UserApiUserMeRequest
 */
export interface UserApiUserMeRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiUserMe
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiUserMe
     */
    readonly contentType?: string
}

/**
 * Request parameters for userSetDefaultChannel operation in UserApi.
 * @export
 * @interface UserApiUserSetDefaultChannelRequest
 */
export interface UserApiUserSetDefaultChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUserSetDefaultChannel
     */
    readonly channel: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiUserSetDefaultChannel
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiUserSetDefaultChannel
     */
    readonly contentType?: string
}

/**
 * Request parameters for userShow operation in UserApi.
 * @export
 * @interface UserApiUserShowRequest
 */
export interface UserApiUserShowRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUserShow
     */
    readonly user: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiUserShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiUserShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for userSupervised operation in UserApi.
 * @export
 * @interface UserApiUserSupervisedRequest
 */
export interface UserApiUserSupervisedRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUserSupervised
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiUserSupervised
     */
    readonly filterChannelId?: number

    /**
     * 
     * @type {string}
     * @memberof UserApiUserSupervised
     */
    readonly filterSupervisorId?: string

    /**
     * 
     * @type {string}
     * @memberof UserApiUserSupervised
     */
    readonly filterSupervisorTypeId?: string

    /**
     * 
     * @type {number}
     * @memberof UserApiUserSupervised
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {string}
     * @memberof UserApiUserSupervised
     */
    readonly filterName?: string

    /**
     * 
     * @type {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'}
     * @memberof UserApiUserSupervised
     */
    readonly filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'

    /**
     * 
     * @type {number}
     * @memberof UserApiUserSupervised
     */
    readonly filterDescendantOf?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiUserSupervised
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof UserApiUserSupervised
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof UserApiUserSupervised
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiUserSupervised
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiUserSupervised
     */
    readonly contentType?: string
}

/**
 * Request parameters for userSupervisor operation in UserApi.
 * @export
 * @interface UserApiUserSupervisorRequest
 */
export interface UserApiUserSupervisorRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiUserSupervisor
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiUserSupervisor
     */
    readonly contentType?: string
}

/**
 * Request parameters for userSupervisorTypes operation in UserApi.
 * @export
 * @interface UserApiUserSupervisorTypesRequest
 */
export interface UserApiUserSupervisorTypesRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof UserApiUserSupervisorTypes
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof UserApiUserSupervisorTypes
     */
    readonly contentType?: string
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Approve order
     * @summary Approve order
     * @param {UserApiOrderApproveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public orderApprove(requestParameters: UserApiOrderApproveRequest, options?: any) {
        return UserApiFp(this.configuration).orderApprove(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change password of currently logged in user
     * @summary Change password
     * @param {UserApiUserChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userChangePassword(requestParameters: UserApiUserChangePasswordRequest = {}, options?: any) {
        return UserApiFp(this.configuration).userChangePassword(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all users registered in the system. This is currently unfiltered, but in the future we may filter to limit user visibility.
     * @summary Show all users.
     * @param {UserApiUserIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userIndex(requestParameters: UserApiUserIndexRequest = {}, options?: any) {
        return UserApiFp(this.configuration).userIndex(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterSupervisorId, requestParameters.filterSupervisorTypeId, requestParameters.filterCompanyId, requestParameters.filterName, requestParameters.filterType, requestParameters.filterDescendantOf, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Front end should filter by company id
     * @summary Show list of available users to look into the report.
     * @param {UserApiUserListForReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListForReport(requestParameters: UserApiUserListForReportRequest = {}, options?: any) {
        return UserApiFp(this.configuration).userListForReport(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterSupervisorId, requestParameters.filterSupervisorTypeId, requestParameters.filterCompanyId, requestParameters.filterName, requestParameters.filterType, requestParameters.filterDescendantOf, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user resource of the currently logged in user
     * @summary Get logged in user detail
     * @param {UserApiUserMeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userMe(requestParameters: UserApiUserMeRequest = {}, options?: any) {
        return UserApiFp(this.configuration).userMe(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the default channel for this user. Default channel must be set before user can access tenanted resources.
     * @summary Set default channel
     * @param {UserApiUserSetDefaultChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSetDefaultChannel(requestParameters: UserApiUserSetDefaultChannelRequest, options?: any) {
        return UserApiFp(this.configuration).userSetDefaultChannel(requestParameters.channel, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Currently allow access to all users on the system
     * @summary Get user detail
     * @param {UserApiUserShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userShow(requestParameters: UserApiUserShowRequest, options?: any) {
        return UserApiFp(this.configuration).userShow(requestParameters.user, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all users that is supervised by this user (all child and grandchild nodes). Does not include data of currently logged in user and data of supervisor.
     * @summary Show all supervised users.
     * @param {UserApiUserSupervisedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSupervised(requestParameters: UserApiUserSupervisedRequest = {}, options?: any) {
        return UserApiFp(this.configuration).userSupervised(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterSupervisorId, requestParameters.filterSupervisorTypeId, requestParameters.filterCompanyId, requestParameters.filterName, requestParameters.filterType, requestParameters.filterDescendantOf, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the detail of logged in user\'s supervisor (direct parent)
     * @summary Get detail of supervisor
     * @param {UserApiUserSupervisorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSupervisor(requestParameters: UserApiUserSupervisorRequest = {}, options?: any) {
        return UserApiFp(this.configuration).userSupervisor(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list supervisor types
     * @summary Get list supervisor types
     * @param {UserApiUserSupervisorTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSupervisorTypes(requestParameters: UserApiUserSupervisorTypesRequest = {}, options?: any) {
        return UserApiFp(this.configuration).userSupervisorTypes(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1Api - axios parameter creator
 * @export
 */
export const V1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show the validation rules for creating activityComment
         * @summary Get create ActivityComment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activity-comments/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a activityComment by its id
         * @summary Delete ActivityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentDestroy: async (activityComment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityComment' is not null or undefined
            assertParamExists('activityCommentDestroy', 'activityComment', activityComment)
            const localVarPath = `/api/v1/activity-comments/{activity_comment}`
                .replace(`{${"activity_comment"}}`, encodeURIComponent(String(activityComment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing activityComment
         * @summary Show edit activityComment rules
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentEdit: async (activityComment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityComment' is not null or undefined
            assertParamExists('activityCommentEdit', 'activityComment', activityComment)
            const localVarPath = `/api/v1/activity-comments/{activity_comment}/edit`
                .replace(`{${"activity_comment"}}`, encodeURIComponent(String(activityComment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all activity comments posted by this user
         * @summary Show user\'s activity comment.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentIndex: async (filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activity-comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterActivityId !== undefined) {
                localVarQueryParameter['filter[activity_id]'] = filterActivityId;
            }

            if (filterActivityCommentId !== undefined) {
                localVarQueryParameter['filter[activity_comment_id]'] = filterActivityCommentId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns activityComment by id
         * @summary Get activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentShow: async (activityComment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityComment' is not null or undefined
            assertParamExists('activityCommentShow', 'activityComment', activityComment)
            const localVarPath = `/api/v1/activity-comments/{activity_comment}`
                .replace(`{${"activity_comment"}}`, encodeURIComponent(String(activityComment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new activityComment
         * @summary Create new ActivityComment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject14} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentStore: async (accept?: string, contentType?: string, data?: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activity-comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given activityComment
         * @summary Update a activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject15} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentUpdate: async (activityComment: string, accept?: string, contentType?: string, data?: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityComment' is not null or undefined
            assertParamExists('activityCommentUpdate', 'activityComment', activityComment)
            const localVarPath = `/api/v1/activity-comments/{activity_comment}`
                .replace(`{${"activity_comment"}}`, encodeURIComponent(String(activityComment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating activity
         * @summary Show create product activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activities/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a activity by its id
         * @summary Delete Activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityDestroy: async (activity: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityDestroy', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing activity
         * @summary Show edit activity rules
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityEdit: async (activity: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityEdit', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}/edit`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all activity comments for a given activity.
         * @summary Show all activity comments of an activity.
         * @param {number} activity 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityGetComments: async (activity: number, filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityGetComments', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}/comments`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterActivityId !== undefined) {
                localVarQueryParameter['filter[activity_id]'] = filterActivityId;
            }

            if (filterActivityCommentId !== undefined) {
                localVarQueryParameter['filter[activity_comment_id]'] = filterActivityCommentId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sales will get all activities directly created by him. Supervisor will get all activities created by its supervised sales. Director will get all activities scoped to its active channel setting.
         * @summary Show all activity posted by user
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityIndex: async (filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterOrderId !== undefined) {
                localVarQueryParameter['filter[order_id]'] = filterOrderId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterCustomerId !== undefined) {
                localVarQueryParameter['filter[customer_id]'] = filterCustomerId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterFollowUpMethod !== undefined) {
                localVarQueryParameter['filter[follow_up_method]'] = filterFollowUpMethod;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterFeedback !== undefined) {
                localVarQueryParameter['filter[feedback]'] = filterFeedback;
            }

            if (filterTargetId !== undefined) {
                localVarQueryParameter['filter[target_id]'] = filterTargetId;
            }

            if (filterFollowUpDatetimeBefore !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_before]'] = filterFollowUpDatetimeBefore;
            }

            if (filterFollowUpDatetimeAfter !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_after]'] = filterFollowUpDatetimeAfter;
            }

            if (filterHasPayment !== undefined) {
                localVarQueryParameter['filter[has_payment]'] = filterHasPayment;
            }

            if (filterHasAnyBrands !== undefined) {
                localVarQueryParameter['filter[has_any_brands]'] = filterHasAnyBrands;
            }

            if (filterCreatedBefore !== undefined) {
                localVarQueryParameter['filter[created_before]'] = filterCreatedBefore;
            }

            if (filterCreatedAfter !== undefined) {
                localVarQueryParameter['filter[created_after]'] = filterCreatedAfter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @summary Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @param {string} userId 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityReport: async (userId: string, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('activityReport', 'userId', userId)
            const localVarPath = `/api/v1/activities/report/detail/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns activity by id
         * @summary Get activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityShow: async (activity: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityShow', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new activity
         * @summary Create new Activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject12} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityStore: async (accept?: string, contentType?: string, data?: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given activity
         * @summary Update a activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject13} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityUpdate: async (activity: string, accept?: string, contentType?: string, data?: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'activity' is not null or undefined
            assertParamExists('activityUpdate', 'activity', activity)
            const localVarPath = `/api/v1/activities/{activity}`
                .replace(`{${"activity"}}`, encodeURIComponent(String(activity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating address
         * @summary Show create product address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/addresses/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a address by its id
         * @summary Delete Address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy: async (address: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressDestroy', 'address', address)
            const localVarPath = `/api/v1/addresses/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing address
         * @summary Show edit address rules
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressEdit: async (address: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressEdit', 'address', address)
            const localVarPath = `/api/v1/addresses/{address}/edit`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all address
         * @summary Show all address.
         * @param {string} [filterId] 
         * @param {number} [filterCustomerId] 
         * @param {string} [filterAddressLine1] 
         * @param {string} [filterAddressLine2] 
         * @param {string} [filterCity] 
         * @param {string} [filterCountry] 
         * @param {string} [filterProvince] 
         * @param {string} [filterPhone] 
         * @param {'ADDRESS' | 'DELIVERY' | 'BILLING'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex: async (filterId?: string, filterCustomerId?: number, filterAddressLine1?: string, filterAddressLine2?: string, filterCity?: string, filterCountry?: string, filterProvince?: string, filterPhone?: string, filterType?: 'ADDRESS' | 'DELIVERY' | 'BILLING', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterCustomerId !== undefined) {
                localVarQueryParameter['filter[customer_id]'] = filterCustomerId;
            }

            if (filterAddressLine1 !== undefined) {
                localVarQueryParameter['filter[address_line_1]'] = filterAddressLine1;
            }

            if (filterAddressLine2 !== undefined) {
                localVarQueryParameter['filter[address_line_2]'] = filterAddressLine2;
            }

            if (filterCity !== undefined) {
                localVarQueryParameter['filter[city]'] = filterCity;
            }

            if (filterCountry !== undefined) {
                localVarQueryParameter['filter[country]'] = filterCountry;
            }

            if (filterProvince !== undefined) {
                localVarQueryParameter['filter[province]'] = filterProvince;
            }

            if (filterPhone !== undefined) {
                localVarQueryParameter['filter[phone]'] = filterPhone;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns address by id
         * @summary Get address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow: async (address: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressShow', 'address', address)
            const localVarPath = `/api/v1/addresses/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating address
         * @summary Create new Address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject4} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore: async (accept?: string, contentType?: string, data?: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given address
         * @summary Update a address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject5} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate: async (address: string, accept?: string, contentType?: string, data?: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('addressUpdate', 'address', address)
            const localVarPath = `/api/v1/addresses/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user token
         * @summary Get Token
         * @param {InlineObject32} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authToken: async (data?: InlineObject32, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a cart demand by its id
         * @summary Delete cart demand
         * @param {string} cartDemand 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandDestroy: async (cartDemand: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartDemand' is not null or undefined
            assertParamExists('cartDemandDestroy', 'cartDemand', cartDemand)
            const localVarPath = `/api/v1/cart-demands/{cart_demand}`
                .replace(`{${"cart_demand"}}`, encodeURIComponent(String(cartDemand)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show cart demand of logged in user
         * @summary Show user cart demand.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandIndex: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cart-demands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync user cart demand content
         * @summary Sync cart demand
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject22} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandSync: async (accept?: string, contentType?: string, data?: InlineObject22, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/cart-demands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} cartDemand 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody1} [imageRequestBody1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandUploadImage: async (cartDemand: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody1?: ImageRequestBody1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartDemand' is not null or undefined
            assertParamExists('cartDemandUploadImage', 'cartDemand', cartDemand)
            const localVarPath = `/api/v1/cart-demands/{cartDemand}/upload`
                .replace(`{${"cartDemand"}}`, encodeURIComponent(String(cartDemand)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequestBody1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show cart of logged in user
         * @summary Show user cart.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartIndex: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/carts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync user cart content
         * @summary Sync cart
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject21} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartSync: async (accept?: string, contentType?: string, data?: InlineObject21, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/carts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the default channel of authenticated user
         * @summary Get default channel
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefault: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/channels/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all channels available for this user
         * @summary Show all channels.
         * @param {string} [filterId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {string} [filterSupervisorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelIndex: async (filterId?: string, filterCompanyId?: number, filterName?: string, filterSupervisorId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterSupervisorId !== undefined) {
                localVarQueryParameter['filter[supervisor_id]'] = filterSupervisorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns channel by id
         * @summary Get channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelShow: async (channel: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('channelShow', 'channel', channel)
            const localVarPath = `/api/v1/channels/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show companies
         * @summary Get all company account
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAccountIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/company-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show companies
         * @summary Get all Companies
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns company by id
         * @summary Get Company
         * @param {string} company 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyShow: async (company: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'company' is not null or undefined
            assertParamExists('companyShow', 'company', company)
            const localVarPath = `/api/v1/companies/{company}`
                .replace(`{${"company"}}`, encodeURIComponent(String(company)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating customer
         * @summary Show create customer rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating customer with address
         * @summary Show create customer with address rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreateWithAddress: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers/addresses/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a customer by its id
         * @summary Delete Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDelete: async (customer: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerDelete', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new CustomerDeposit
         * @summary Create new CustomerDeposit
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject16} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDepositStore: async (accept?: string, contentType?: string, data?: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customer-deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing customer
         * @summary Show edit customer rules
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerEdit: async (customer: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerEdit', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}/edit`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all activities of a given customer
         * @summary Show all activities of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetActivities: async (customer: number, filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerGetActivities', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}/activities`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterOrderId !== undefined) {
                localVarQueryParameter['filter[order_id]'] = filterOrderId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterCustomerId !== undefined) {
                localVarQueryParameter['filter[customer_id]'] = filterCustomerId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterFollowUpMethod !== undefined) {
                localVarQueryParameter['filter[follow_up_method]'] = filterFollowUpMethod;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterFeedback !== undefined) {
                localVarQueryParameter['filter[feedback]'] = filterFeedback;
            }

            if (filterTargetId !== undefined) {
                localVarQueryParameter['filter[target_id]'] = filterTargetId;
            }

            if (filterFollowUpDatetimeBefore !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_before]'] = filterFollowUpDatetimeBefore;
            }

            if (filterFollowUpDatetimeAfter !== undefined) {
                localVarQueryParameter['filter[follow_up_datetime_after]'] = filterFollowUpDatetimeAfter;
            }

            if (filterHasPayment !== undefined) {
                localVarQueryParameter['filter[has_payment]'] = filterHasPayment;
            }

            if (filterHasAnyBrands !== undefined) {
                localVarQueryParameter['filter[has_any_brands]'] = filterHasAnyBrands;
            }

            if (filterCreatedBefore !== undefined) {
                localVarQueryParameter['filter[created_before]'] = filterCreatedBefore;
            }

            if (filterCreatedAfter !== undefined) {
                localVarQueryParameter['filter[created_after]'] = filterCreatedAfter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all leads of a given customer
         * @summary Show all leads of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetLeads: async (customer: number, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerGetLeads', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}/leads`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all Customer stored globally in the application.
         * @summary Show all customer.
         * @param {string} [filterId] 
         * @param {string} [filterFirstName] 
         * @param {string} [filterLastName] 
         * @param {string} [filterEmail] 
         * @param {string} [filterPhone] 
         * @param {string} [filterSearch] 
         * @param {boolean} [filterHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerIndex: async (filterId?: string, filterFirstName?: string, filterLastName?: string, filterEmail?: string, filterPhone?: string, filterSearch?: string, filterHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterFirstName !== undefined) {
                localVarQueryParameter['filter[first_name]'] = filterFirstName;
            }

            if (filterLastName !== undefined) {
                localVarQueryParameter['filter[last_name]'] = filterLastName;
            }

            if (filterEmail !== undefined) {
                localVarQueryParameter['filter[email]'] = filterEmail;
            }

            if (filterPhone !== undefined) {
                localVarQueryParameter['filter[phone]'] = filterPhone;
            }

            if (filterSearch !== undefined) {
                localVarQueryParameter['filter[search]'] = filterSearch;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns customer by id
         * @summary Get Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerShow: async (customer: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerShow', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating customer
         * @summary Create new Customer
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject2} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerStore: async (accept?: string, contentType?: string, data?: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new customer with address. This will assign the address as the customer\'s default address id as well
         * @summary Create new customer with address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject1} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerStoreWithAddress: async (accept?: string, contentType?: string, data?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given customer
         * @summary Update a customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject3} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate: async (customer: string, accept?: string, contentType?: string, data?: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            assertParamExists('customerUpdate', 'customer', customer)
            const localVarPath = `/api/v1/customers/{customer}`
                .replace(`{${"customer"}}`, encodeURIComponent(String(customer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns order deals by lead id
         * @summary Get order deals
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsleadSms: async (id: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dealsleadSms', 'id', id)
            const localVarPath = `/api/v1/leads/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get discount that match the given discount code.
         * @summary Get discount by code
         * @param {string} code The discount activation code
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountGetByCode: async (code: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('discountGetByCode', 'code', code)
            const localVarPath = `/api/v1/discounts/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all public discounts.
         * @summary Get discounts
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterActivationCode] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountIndex: async (filterId?: string, filterName?: string, filterActivationCode?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/discounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterActivationCode !== undefined) {
                localVarQueryParameter['filter[activation_code]'] = filterActivationCode;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all InteriorDesigns available for this user
         * @summary Show all InteriorDesigns.
         * @param {string} [filterId] 
         * @param {number} [filterReligionId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interiorDesignIndex: async (filterId?: string, filterReligionId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/interior-designs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterReligionId !== undefined) {
                localVarQueryParameter['filter[religion_id]'] = filterReligionId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns InteriorDesign by id
         * @summary Get InteriorDesign
         * @param {string} interiorDesign 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interiorDesignShow: async (interiorDesign: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'interiorDesign' is not null or undefined
            assertParamExists('interiorDesignShow', 'interiorDesign', interiorDesign)
            const localVarPath = `/api/v1/interior-designs/{interior_design}`
                .replace(`{${"interior_design"}}`, encodeURIComponent(String(interiorDesign)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign an unhandled lead
         * @summary Assign an unhandled lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject9} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadAssign: async (lead: string, accept?: string, contentType?: string, data?: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadAssign', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}/assign`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all lead categories.
         * @summary Show all lead categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadCategories: async (filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating lead
         * @summary Show create product lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a lead by its id
         * @summary Delete Lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadDestroy: async (lead: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadDestroy', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing lead
         * @summary Show edit lead rules
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadEdit: async (lead: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadEdit', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}/edit`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadIndex: async (filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns lead by id
         * @summary Get lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadShow: async (lead: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadShow', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all sms user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadSms: async (filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/sms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Lead. Currently only sales are allowed to perform this action. This is because lead must be related to a sales. If we want to allow supervisor to add a new lead, they must pick which sales to assign this sales to (which is not supported yet).
         * @summary Create new Lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject10} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadStore: async (accept?: string, contentType?: string, data?: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Lead SMS. Currently only sales are allowed to perform this action. This is because lead must be related to a sales.
         * @summary Create new Lead SMS
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject7} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadStoreSms: async (accept?: string, contentType?: string, data?: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint only returns unhandled leads that the authenticated user is able to assign to. (i.e., sales will not be able to see any unhandled leads)
         * @summary Show all unhandled leads.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUnhandledIndex: async (filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/leads/unhandled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterUserId !== undefined) {
                localVarQueryParameter['filter[user_id]'] = filterUserId;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterLabel !== undefined) {
                localVarQueryParameter['filter[label]'] = filterLabel;
            }

            if (filterLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[lead_category_id]'] = filterLeadCategoryId;
            }

            if (filterSubLeadCategoryId !== undefined) {
                localVarQueryParameter['filter[sub_lead_category_id]'] = filterSubLeadCategoryId;
            }

            if (filterCustomerName !== undefined) {
                localVarQueryParameter['filter[customer_name]'] = filterCustomerName;
            }

            if (filterCustomerSearch !== undefined) {
                localVarQueryParameter['filter[customer_search]'] = filterCustomerSearch;
            }

            if (filterChannelName !== undefined) {
                localVarQueryParameter['filter[channel_name]'] = filterChannelName;
            }

            if (filterSmsChannelName !== undefined) {
                localVarQueryParameter['filter[sms_channel_name]'] = filterSmsChannelName;
            }

            if (filterIsNewCustomer !== undefined) {
                localVarQueryParameter['filter[is_new_customer]'] = filterIsNewCustomer;
            }

            if (filterHasActivity !== undefined) {
                localVarQueryParameter['filter[has_activity]'] = filterHasActivity;
            }

            if (filterCustomerHasActivity !== undefined) {
                localVarQueryParameter['filter[customer_has_activity]'] = filterCustomerHasActivity;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given lead
         * @summary Update a lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject11} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUpdate: async (lead: string, accept?: string, contentType?: string, data?: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lead' is not null or undefined
            assertParamExists('leadUpdate', 'lead', lead)
            const localVarPath = `/api/v1/leads/{lead}`
                .replace(`{${"lead"}}`, encodeURIComponent(String(lead)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given lead SMS
         * @summary Update a lead SMS
         * @param {number} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject8} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUpdateSms: async (id: number, accept?: string, contentType?: string, data?: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('leadUpdateSms', 'id', id)
            const localVarPath = `/api/v1/leads/update/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Approve order
         * @summary Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject25} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderApprove: async (order: string, accept?: string, contentType?: string, data?: InlineObject25, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderApprove', 'order', order)
            const localVarPath = `/api/v1/orders/approve/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will cancel an order.
         * @summary Cancel an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCancel: async (order: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderCancel', 'order', order)
            const localVarPath = `/api/v1/orders/cancel/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will clone and cancel a given order. Newly cloned order will be returned as response.
         * @summary Clone an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject27} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClone: async (order: string, accept?: string, contentType?: string, data?: InlineObject27, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderClone', 'order', order)
            const localVarPath = `/api/v1/orders/clone/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} orderDetail 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody2} [imageRequestBody2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetail: async (orderDetail: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody2?: ImageRequestBody2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderDetail' is not null or undefined
            assertParamExists('orderDetail', 'orderDetail', orderDetail)
            const localVarPath = `/api/v1/order-details/{orderDetail}/upload`
                .replace(`{${"orderDetail"}}`, encodeURIComponent(String(orderDetail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequestBody2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns orderDetail by id
         * @summary Get orderDetail
         * @param {string} orderDetail 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailShow: async (orderDetail: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderDetail' is not null or undefined
            assertParamExists('orderDetailShow', 'orderDetail', orderDetail)
            const localVarPath = `/api/v1/order-details/{order_detail}`
                .replace(`{${"order_detail"}}`, encodeURIComponent(String(orderDetail)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all order
         * @summary Show all order.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIndex: async (filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterSearch !== undefined) {
                localVarQueryParameter['filter[search]'] = filterSearch;
            }

            if (filterInvoiceNumber !== undefined) {
                localVarQueryParameter['filter[invoice_number]'] = filterInvoiceNumber;
            }

            if (filterApprovalStatus !== undefined) {
                localVarQueryParameter['filter[approval_status]'] = filterApprovalStatus;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint only return orders that can be approved by the authenticated user.
         * @summary Show all orders waiting for approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIndexWaitingApproval: async (filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/waiting-approval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterSearch !== undefined) {
                localVarQueryParameter['filter[search]'] = filterSearch;
            }

            if (filterInvoiceNumber !== undefined) {
                localVarQueryParameter['filter[invoice_number]'] = filterInvoiceNumber;
            }

            if (filterApprovalStatus !== undefined) {
                localVarQueryParameter['filter[approval_status]'] = filterApprovalStatus;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint return approval discount orders that related with the authenticated user.
         * @summary Show all orders approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderListApproval: async (filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/list-approval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterSearch !== undefined) {
                localVarQueryParameter['filter[search]'] = filterSearch;
            }

            if (filterInvoiceNumber !== undefined) {
                localVarQueryParameter['filter[invoice_number]'] = filterInvoiceNumber;
            }

            if (filterApprovalStatus !== undefined) {
                localVarQueryParameter['filter[approval_status]'] = filterApprovalStatus;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a dummy order for preview purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject23} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPreview: async (accept?: string, contentType?: string, data?: InlineObject23, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a dummy order for preview update purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview update
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject24} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPreviewUpdate: async (order: string, accept?: string, contentType?: string, data?: InlineObject24, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderPreviewUpdate', 'order', order)
            const localVarPath = `/api/v1/orders/preview-update/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request Approve order
         * @summary Request Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject26} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRequestApprove: async (order: string, accept?: string, contentType?: string, data?: InlineObject26, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderRequestApprove', 'order', order)
            const localVarPath = `/api/v1/orders/request-approval/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns order by id
         * @summary Get order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShow: async (order: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderShow', 'order', order)
            const localVarPath = `/api/v1/orders/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new order
         * @summary Create new Order
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject28} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderStore: async (accept?: string, contentType?: string, data?: InlineObject28, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an order
         * @summary Update an Order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject29} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderUpdate: async (order: string, accept?: string, contentType?: string, data?: InlineObject29, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('orderUpdate', 'order', order)
            const localVarPath = `/api/v1/orders/{order}`
                .replace(`{${"order"}}`, encodeURIComponent(String(order)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all payment category
         * @summary Show all payment category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCategoryIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payment-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating payment
         * @summary Get create payment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing payment
         * @summary Show edit payment rules
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentEdit: async (payment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('paymentEdit', 'payment', payment)
            const localVarPath = `/api/v1/payments/{payment}/edit`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all payment
         * @summary Show all payment.
         * @param {string} [filterId] 
         * @param {number} [filterAmount] 
         * @param {string} [filterReference] 
         * @param {'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'} [filterStatus] 
         * @param {string} [filterPaymentTypeId] 
         * @param {string} [filterAddedById] 
         * @param {string} [filterApprovedById] 
         * @param {string} [filterOrderId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIndex: async (filterId?: string, filterAmount?: number, filterReference?: string, filterStatus?: 'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT', filterPaymentTypeId?: string, filterAddedById?: string, filterApprovedById?: string, filterOrderId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterAmount !== undefined) {
                localVarQueryParameter['filter[amount]'] = filterAmount;
            }

            if (filterReference !== undefined) {
                localVarQueryParameter['filter[reference]'] = filterReference;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter[status]'] = filterStatus;
            }

            if (filterPaymentTypeId !== undefined) {
                localVarQueryParameter['filter[payment_type_id]'] = filterPaymentTypeId;
            }

            if (filterAddedById !== undefined) {
                localVarQueryParameter['filter[added_by_id]'] = filterAddedById;
            }

            if (filterApprovedById !== undefined) {
                localVarQueryParameter['filter[approved_by_id]'] = filterApprovedById;
            }

            if (filterOrderId !== undefined) {
                localVarQueryParameter['filter[order_id]'] = filterOrderId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload proof of payment
         * @summary Upload proof of payment
         * @param {string} payment 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody3} [imageRequestBody3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentProofUpload: async (payment: string, filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody3?: ImageRequestBody3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('paymentProofUpload', 'payment', payment)
            const localVarPath = `/api/v1/payments/{payment}/proof`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequestBody3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns payment by id
         * @summary Get payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentShow: async (payment: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('paymentShow', 'payment', payment)
            const localVarPath = `/api/v1/payments/{payment}`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new payment
         * @summary Create new Payment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject30} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentStore: async (accept?: string, contentType?: string, data?: InlineObject30, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all payment types
         * @summary Show all payment types.
         * @param {string} [filterId] 
         * @param {string} [filterPaymentCategoryId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypeIndex: async (filterId?: string, filterPaymentCategoryId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/payment-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterPaymentCategoryId !== undefined) {
                localVarQueryParameter['filter[payment_category_id]'] = filterPaymentCategoryId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given payment
         * @summary Update a payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject31} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUpdate: async (payment: string, accept?: string, contentType?: string, data?: InlineObject31, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'payment' is not null or undefined
            assertParamExists('paymentUpdate', 'payment', payment)
            const localVarPath = `/api/v1/payments/{payment}`
                .replace(`{${"payment"}}`, encodeURIComponent(String(payment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productBrand: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/brands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryCodes: async (filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/category-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterProductModelId !== undefined) {
                localVarQueryParameter['filter[product_model_id]'] = filterProductModelId;
            }

            if (filterProductVersionId !== undefined) {
                localVarQueryParameter['filter[product_version_id]'] = filterProductVersionId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product category
         * @summary Show all product category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'} [filterType] 
         * @param {number} [filterParentId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryIndex: async (filterId?: string, filterName?: string, filterDescription?: string, filterType?: 'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY', filterParentId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterParentId !== undefined) {
                localVarQueryParameter['filter[parent_id]'] = filterParentId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns product category by id
         * @summary Get product category
         * @param {string} productCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryShow: async (productCategory: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productCategory' is not null or undefined
            assertParamExists('productCategoryShow', 'productCategory', productCategory)
            const localVarPath = `/api/v1/product-categories/{product_category}`
                .replace(`{${"product_category"}}`, encodeURIComponent(String(productCategory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product
         * @summary Show all product.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {string} [filterProductCategoryCodeId] 
         * @param {string} [filterName] 
         * @param {string} [filterTags] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIndex: async (filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, filterProductCategoryCodeId?: string, filterName?: string, filterTags?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterProductModelId !== undefined) {
                localVarQueryParameter['filter[product_model_id]'] = filterProductModelId;
            }

            if (filterProductVersionId !== undefined) {
                localVarQueryParameter['filter[product_version_id]'] = filterProductVersionId;
            }

            if (filterProductCategoryCodeId !== undefined) {
                localVarQueryParameter['filter[product_category_code_id]'] = filterProductCategoryCodeId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterTags !== undefined) {
                localVarQueryParameter['filter[tags]'] = filterTags;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product model available.
         * @summary Show all product model.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productModel: async (filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get product model for a given id.
         * @summary Get product model by id.
         * @param {string} model 
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productModelById: async (model: string, filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('productModelById', 'model', model)
            const localVarPath = `/api/v1/models/{model}`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns product by id
         * @summary Get product
         * @param {string} product 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productShow: async (product: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'product' is not null or undefined
            assertParamExists('productShow', 'product', product)
            const localVarPath = `/api/v1/products/{product}`
                .replace(`{${"product"}}`, encodeURIComponent(String(product)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product tag
         * @summary Show all product tag.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterSlug] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagIndex: async (filterId?: string, filterName?: string, filterSlug?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/product-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterSlug !== undefined) {
                localVarQueryParameter['filter[slug]'] = filterSlug;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns product tag by id
         * @summary Get product tag
         * @param {string} productTag 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagShow: async (productTag: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productTag' is not null or undefined
            assertParamExists('productTagShow', 'productTag', productTag)
            const localVarPath = `/api/v1/product-tags/{product_tag}`
                .replace(`{${"product_tag"}}`, encodeURIComponent(String(productTag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product unit colours
         * @summary Show all product unit colours.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [filterProductId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitColours: async (filterId?: string, filterName?: string, filterDescription?: string, filterProductId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/colours`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (filterProductId !== undefined) {
                localVarQueryParameter['filter[product_id]'] = filterProductId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product unit coverings
         * @summary Show all product unit coverings.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {string} [filterName] 
         * @param {string} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitCoverings: async (filterId?: string, filterProductId?: number, filterName?: string, filterType?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/coverings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductId !== undefined) {
                localVarQueryParameter['filter[product_id]'] = filterProductId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product unit
         * @summary Show all product unit.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitIndex: async (filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/product-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductId !== undefined) {
                localVarQueryParameter['filter[product_id]'] = filterProductId;
            }

            if (filterColourId !== undefined) {
                localVarQueryParameter['filter[colour_id]'] = filterColourId;
            }

            if (filterCoveringId !== undefined) {
                localVarQueryParameter['filter[covering_id]'] = filterCoveringId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns product unit by id
         * @summary Get product unit
         * @param {string} productUnit 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitShow: async (productUnit: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productUnit' is not null or undefined
            assertParamExists('productUnitShow', 'productUnit', productUnit)
            const localVarPath = `/api/v1/product-units/{product_unit}`
                .replace(`{${"product_unit"}}`, encodeURIComponent(String(productUnit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload product unit image
         * @summary Upload product unit image
         * @param {string} productUnit 
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody} [imageRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitUpload: async (productUnit: string, filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody?: ImageRequestBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productUnit' is not null or undefined
            assertParamExists('productUnitUpload', 'productUnit', productUnit)
            const localVarPath = `/api/v1/product-units/{productUnit}/upload`
                .replace(`{${"productUnit"}}`, encodeURIComponent(String(productUnit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductId !== undefined) {
                localVarQueryParameter['filter[product_id]'] = filterProductId;
            }

            if (filterColourId !== undefined) {
                localVarQueryParameter['filter[colour_id]'] = filterColourId;
            }

            if (filterCoveringId !== undefined) {
                localVarQueryParameter['filter[covering_id]'] = filterCoveringId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVersion: async (filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterProductBrandId !== undefined) {
                localVarQueryParameter['filter[product_brand_id]'] = filterProductBrandId;
            }

            if (filterProductModelId !== undefined) {
                localVarQueryParameter['filter[product_model_id]'] = filterProductModelId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all promo categories.
         * @summary Show all promo categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoCategoryIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/promo-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns promo category by id
         * @summary Get promo category
         * @param {string} promoCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoCategoryShow: async (promoCategory: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'promoCategory' is not null or undefined
            assertParamExists('promoCategoryShow', 'promoCategory', promoCategory)
            const localVarPath = `/api/v1/promo-categories/{promo_category}`
                .replace(`{${"promo_category"}}`, encodeURIComponent(String(promoCategory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all promo
         * @summary Show all promo.
         * @param {string} [filterId] 
         * @param {number} [filterPromoCategoryId] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoIndex: async (filterId?: string, filterPromoCategoryId?: number, filterStartAfter?: string, filterEndBefore?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/promos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterPromoCategoryId !== undefined) {
                localVarQueryParameter['filter[promo_category_id]'] = filterPromoCategoryId;
            }

            if (filterStartAfter !== undefined) {
                localVarQueryParameter['filter[start_after]'] = filterStartAfter;
            }

            if (filterEndBefore !== undefined) {
                localVarQueryParameter['filter[end_before]'] = filterEndBefore;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns promo by id
         * @summary Get promo
         * @param {string} promo 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoShow: async (promo: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'promo' is not null or undefined
            assertParamExists('promoShow', 'promo', promo)
            const localVarPath = `/api/v1/promos/{promo}`
                .replace(`{${"promo"}}`, encodeURIComponent(String(promo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set all current user notification as read
         * @summary Clear all notifications
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationClear: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all notifications
         * @summary Show all notifications
         * @param {'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationIndex: async (filterType?: 'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribe device code to push notification
         * @summary Subscribe device code to push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationSubscribe: async (code: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('pushNotificationSubscribe', 'code', code)
            const localVarPath = `/api/v1/notifications/{code}/subscribe`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a test notification
         * @summary Send a test notification
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject6} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationTest: async (accept?: string, contentType?: string, data?: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsubscribe device code from push notification
         * @summary Unsubscribe device code from push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationUnsubscribe: async (code: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('pushNotificationUnsubscribe', 'code', code)
            const localVarPath = `/api/v1/notifications/{code}/unsubscribe`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating qa message
         * @summary Get create qa message rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-messages/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a qa message by its id
         * @summary Delete Qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageDestroy: async (qaMessage: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaMessage' is not null or undefined
            assertParamExists('qaMessageDestroy', 'qaMessage', qaMessage)
            const localVarPath = `/api/v1/qa-messages/{qa_message}`
                .replace(`{${"qa_message"}}`, encodeURIComponent(String(qaMessage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing qa message
         * @summary Show edit qa message rules
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageEdit: async (qaMessage: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaMessage' is not null or undefined
            assertParamExists('qaMessageEdit', 'qaMessage', qaMessage)
            const localVarPath = `/api/v1/qa-messages/{qa_message}/edit`
                .replace(`{${"qa_message"}}`, encodeURIComponent(String(qaMessage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all qa message
         * @summary Show all qa message.
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageIndex: async (filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (filterTopicId !== undefined) {
                localVarQueryParameter['filter[topic_id]'] = filterTopicId;
            }

            if (filterSenderId !== undefined) {
                localVarQueryParameter['filter[sender_id]'] = filterSenderId;
            }

            if (filterIsUnread !== undefined) {
                localVarQueryParameter['filter[is_unread]'] = filterIsUnread;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns qa message by id
         * @summary Get qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageShow: async (qaMessage: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaMessage' is not null or undefined
            assertParamExists('qaMessageShow', 'qaMessage', qaMessage)
            const localVarPath = `/api/v1/qa-messages/{qa_message}`
                .replace(`{${"qa_message"}}`, encodeURIComponent(String(qaMessage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new qa message
         * @summary Create new Qa message
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject19} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageStore: async (accept?: string, contentType?: string, data?: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given qa message
         * @summary Update a qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject20} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageUpdate: async (qaMessage: string, accept?: string, contentType?: string, data?: InlineObject20, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaMessage' is not null or undefined
            assertParamExists('qaMessageUpdate', 'qaMessage', qaMessage)
            const localVarPath = `/api/v1/qa-messages/{qa_message}`
                .replace(`{${"qa_message"}}`, encodeURIComponent(String(qaMessage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for creating qa topic
         * @summary Get create qa topic rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicCreate: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-topics/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a qa topic by its id
         * @summary Delete Qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicDestroy: async (qaTopic: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaTopic' is not null or undefined
            assertParamExists('qaTopicDestroy', 'qaTopic', qaTopic)
            const localVarPath = `/api/v1/qa-topics/{qa_topic}`
                .replace(`{${"qa_topic"}}`, encodeURIComponent(String(qaTopic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the validation rules for editing qa topic
         * @summary Show edit qa topic rules
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicEdit: async (qaTopic: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaTopic' is not null or undefined
            assertParamExists('qaTopicEdit', 'qaTopic', qaTopic)
            const localVarPath = `/api/v1/qa-topics/{qa_topic}/edit`
                .replace(`{${"qa_topic"}}`, encodeURIComponent(String(qaTopic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
         * @summary Get all Qa Messages of a Qa Topic
         * @param {number} topic 
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicGetQaMessages: async (topic: number, filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('qaTopicGetQaMessages', 'topic', topic)
            const localVarPath = `/api/v1/qa-topics/{topic}/qa-messages`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterContent !== undefined) {
                localVarQueryParameter['filter[content]'] = filterContent;
            }

            if (filterTopicId !== undefined) {
                localVarQueryParameter['filter[topic_id]'] = filterTopicId;
            }

            if (filterSenderId !== undefined) {
                localVarQueryParameter['filter[sender_id]'] = filterSenderId;
            }

            if (filterIsUnread !== undefined) {
                localVarQueryParameter['filter[is_unread]'] = filterIsUnread;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all qa topic
         * @summary Show all qa topic.
         * @param {string} [filterId] 
         * @param {string} [filterSubject] 
         * @param {number} [filterCreatorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicIndex: async (filterId?: string, filterSubject?: string, filterCreatorId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterSubject !== undefined) {
                localVarQueryParameter['filter[subject]'] = filterSubject;
            }

            if (filterCreatorId !== undefined) {
                localVarQueryParameter['filter[creator_id]'] = filterCreatorId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns qa topic by id
         * @summary Get qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicShow: async (qaTopic: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaTopic' is not null or undefined
            assertParamExists('qaTopicShow', 'qaTopic', qaTopic)
            const localVarPath = `/api/v1/qa-topics/{qa_topic}`
                .replace(`{${"qa_topic"}}`, encodeURIComponent(String(qaTopic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new qa topic
         * @summary Create new Qa topic
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject17} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicStore: async (accept?: string, contentType?: string, data?: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/qa-topics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a given qa topic
         * @summary Update a qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject18} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicUpdate: async (qaTopic: string, accept?: string, contentType?: string, data?: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'qaTopic' is not null or undefined
            assertParamExists('qaTopicUpdate', 'qaTopic', qaTopic)
            const localVarPath = `/api/v1/qa-topics/{qa_topic}`
                .replace(`{${"qa_topic"}}`, encodeURIComponent(String(qaTopic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register sales SMS
         * @summary Register sales SMS
         * @param {InlineObject33} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (data?: InlineObject33, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all report
         * @summary Show all report.
         * @param {string} [filterId] 
         * @param {string} [filterPeriodBefore] 
         * @param {string} [filterPeriodAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportIndex: async (filterId?: string, filterPeriodBefore?: string, filterPeriodAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterPeriodBefore !== undefined) {
                localVarQueryParameter['filter[period_before]'] = filterPeriodBefore;
            }

            if (filterPeriodAfter !== undefined) {
                localVarQueryParameter['filter[period_after]'] = filterPeriodAfter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns report by id
         * @summary Get report
         * @param {string} report 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportShow: async (report: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'report' is not null or undefined
            assertParamExists('reportShow', 'report', report)
            const localVarPath = `/api/v1/reports/{report}`
                .replace(`{${"report"}}`, encodeURIComponent(String(report)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns lead sms by id
         * @summary Get lead sms
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showleadSms: async (id: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showleadSms', 'id', id)
            const localVarPath = `/api/v1/leads/sms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all SMS channels available for this user
         * @summary Show all SMS channels.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsChannelIndex: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sms-channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns SMS channel by id
         * @summary Get SMS channel
         * @param {string} smsChannel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsChannelShow: async (smsChannel: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'smsChannel' is not null or undefined
            assertParamExists('smsChannelShow', 'smsChannel', smsChannel)
            const localVarPath = `/api/v1/sms-channels/{sms_channel}`
                .replace(`{${"sms_channel"}}`, encodeURIComponent(String(smsChannel)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsProductBrand: async (filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/sms-brands`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all stock
         * @summary Show all stock.
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockIndex: async (filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterProductUnitId !== undefined) {
                localVarQueryParameter['filter[product_unit_id]'] = filterProductUnitId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all stock with additional loaded properties.
         * @summary Show all stock (with extended data).
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockIndexExtended: async (filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/stocks/extended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterProductUnitId !== undefined) {
                localVarQueryParameter['filter[product_unit_id]'] = filterProductUnitId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns stock by id
         * @summary Get stock
         * @param {string} stock 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShow: async (stock: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stock' is not null or undefined
            assertParamExists('stockShow', 'stock', stock)
            const localVarPath = `/api/v1/stocks/{stock}`
                .replace(`{${"stock"}}`, encodeURIComponent(String(stock)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sub lead categories.
         * @summary Get sub lead categories.
         * @param {string} leadCategory 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subLeadCategories: async (leadCategory: string, filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'leadCategory' is not null or undefined
            assertParamExists('subLeadCategories', 'leadCategory', leadCategory)
            const localVarPath = `/api/v1/leads/sub-categories/{leadCategory}`
                .replace(`{${"leadCategory"}}`, encodeURIComponent(String(leadCategory)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterDescription !== undefined) {
                localVarQueryParameter['filter[description]'] = filterDescription;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all target
         * @summary Show all target.
         * @param {string} [filterId] 
         * @param {number} [filterReportId] 
         * @param {number} [filterIsDashboard] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {'COMPANY' | 'CHANNEL' | 'USER'} [filterReportableType] 
         * @param {string} [filterReportableIds] 
         * @param {'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'} [filterType] 
         * @param {number} [filterSupervisorTypeLevel] 
         * @param {number} [filterCompanyId] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetIndex: async (filterId?: string, filterReportId?: number, filterIsDashboard?: number, filterStartAfter?: string, filterEndBefore?: string, filterReportableType?: 'COMPANY' | 'CHANNEL' | 'USER', filterReportableIds?: string, filterType?: 'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT', filterSupervisorTypeLevel?: number, filterCompanyId?: number, filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/targets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterReportId !== undefined) {
                localVarQueryParameter['filter[report_id]'] = filterReportId;
            }

            if (filterIsDashboard !== undefined) {
                localVarQueryParameter['filter[is_dashboard]'] = filterIsDashboard;
            }

            if (filterStartAfter !== undefined) {
                localVarQueryParameter['filter[start_after]'] = filterStartAfter;
            }

            if (filterEndBefore !== undefined) {
                localVarQueryParameter['filter[end_before]'] = filterEndBefore;
            }

            if (filterReportableType !== undefined) {
                localVarQueryParameter['filter[reportable_type]'] = filterReportableType;
            }

            if (filterReportableIds !== undefined) {
                localVarQueryParameter['filter[reportable_ids]'] = filterReportableIds;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterSupervisorTypeLevel !== undefined) {
                localVarQueryParameter['filter[supervisor_type_level]'] = filterSupervisorTypeLevel;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterDescendantOf !== undefined) {
                localVarQueryParameter['filter[descendant_of]'] = filterDescendantOf;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change password of currently logged in user
         * @summary Change password
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePassword: async (accept?: string, contentType?: string, data?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all users registered in the system. This is currently unfiltered, but in the future we may filter to limit user visibility.
         * @summary Show all users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIndex: async (filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterSupervisorId !== undefined) {
                localVarQueryParameter['filter[supervisor_id]'] = filterSupervisorId;
            }

            if (filterSupervisorTypeId !== undefined) {
                localVarQueryParameter['filter[supervisor_type_id]'] = filterSupervisorTypeId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterDescendantOf !== undefined) {
                localVarQueryParameter['filter[descendant_of]'] = filterDescendantOf;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Front end should filter by company id
         * @summary Show list of available users to look into the report.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListForReport: async (filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/report-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterSupervisorId !== undefined) {
                localVarQueryParameter['filter[supervisor_id]'] = filterSupervisorId;
            }

            if (filterSupervisorTypeId !== undefined) {
                localVarQueryParameter['filter[supervisor_type_id]'] = filterSupervisorTypeId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterDescendantOf !== undefined) {
                localVarQueryParameter['filter[descendant_of]'] = filterDescendantOf;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user resource of the currently logged in user
         * @summary Get logged in user detail
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMe: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the default channel for this user. Default channel must be set before user can access tenanted resources.
         * @summary Set default channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetDefaultChannel: async (channel: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channel' is not null or undefined
            assertParamExists('userSetDefaultChannel', 'channel', channel)
            const localVarPath = `/api/v1/users/channel/{channel}`
                .replace(`{${"channel"}}`, encodeURIComponent(String(channel)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Currently allow access to all users on the system
         * @summary Get user detail
         * @param {string} user 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShow: async (user: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('userShow', 'user', user)
            const localVarPath = `/api/v1/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all users that is supervised by this user (all child and grandchild nodes). Does not include data of currently logged in user and data of supervisor.
         * @summary Show all supervised users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervised: async (filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/supervised`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (filterId !== undefined) {
                localVarQueryParameter['filter[id]'] = filterId;
            }

            if (filterChannelId !== undefined) {
                localVarQueryParameter['filter[channel_id]'] = filterChannelId;
            }

            if (filterSupervisorId !== undefined) {
                localVarQueryParameter['filter[supervisor_id]'] = filterSupervisorId;
            }

            if (filterSupervisorTypeId !== undefined) {
                localVarQueryParameter['filter[supervisor_type_id]'] = filterSupervisorTypeId;
            }

            if (filterCompanyId !== undefined) {
                localVarQueryParameter['filter[company_id]'] = filterCompanyId;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter[name]'] = filterName;
            }

            if (filterType !== undefined) {
                localVarQueryParameter['filter[type]'] = filterType;
            }

            if (filterDescendantOf !== undefined) {
                localVarQueryParameter['filter[descendant_of]'] = filterDescendantOf;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the detail of logged in user\'s supervisor (direct parent)
         * @summary Get detail of supervisor
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervisor: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/supervisor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list supervisor types
         * @summary Get list supervisor types
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervisorTypes: async (accept?: string, contentType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/supervisor-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1Api - functional programming interface
 * @export
 */
export const V1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1ApiAxiosParamCreator(configuration)
    return {
        /**
         * Show the validation rules for creating activityComment
         * @summary Get create ActivityComment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a activityComment by its id
         * @summary Delete ActivityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentDestroy(activityComment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentDestroy(activityComment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing activityComment
         * @summary Show edit activityComment rules
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentEdit(activityComment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentEdit(activityComment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all activity comments posted by this user
         * @summary Show user\'s activity comment.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentIndex(filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentIndex(filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns activityComment by id
         * @summary Get activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentShow(activityComment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentShow(activityComment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new activityComment
         * @summary Create new ActivityComment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject14} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentStore(accept?: string, contentType?: string, data?: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given activityComment
         * @summary Update a activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject15} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCommentUpdate(activityComment: string, accept?: string, contentType?: string, data?: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCommentUpdate(activityComment, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating activity
         * @summary Show create product activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a activity by its id
         * @summary Delete Activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityDestroy(activity: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityDestroy(activity, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing activity
         * @summary Show edit activity rules
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityEdit(activity: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityEdit(activity, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all activity comments for a given activity.
         * @summary Show all activity comments of an activity.
         * @param {number} activity 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityGetComments(activity: number, filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityGetComments(activity, filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sales will get all activities directly created by him. Supervisor will get all activities created by its supervised sales. Director will get all activities scoped to its active channel setting.
         * @summary Show all activity posted by user
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityIndex(filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityIndex(filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @summary Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @param {string} userId 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityReport(userId: string, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityReport(userId, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns activity by id
         * @summary Get activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityShow(activity: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityShow(activity, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new activity
         * @summary Create new Activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject12} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityStore(accept?: string, contentType?: string, data?: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given activity
         * @summary Update a activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject13} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activityUpdate(activity: string, accept?: string, contentType?: string, data?: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activityUpdate(activity, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating address
         * @summary Show create product address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a address by its id
         * @summary Delete Address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressDestroy(address: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressDestroy(address, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing address
         * @summary Show edit address rules
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressEdit(address: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressEdit(address, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all address
         * @summary Show all address.
         * @param {string} [filterId] 
         * @param {number} [filterCustomerId] 
         * @param {string} [filterAddressLine1] 
         * @param {string} [filterAddressLine2] 
         * @param {string} [filterCity] 
         * @param {string} [filterCountry] 
         * @param {string} [filterProvince] 
         * @param {string} [filterPhone] 
         * @param {'ADDRESS' | 'DELIVERY' | 'BILLING'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressIndex(filterId?: string, filterCustomerId?: number, filterAddressLine1?: string, filterAddressLine2?: string, filterCity?: string, filterCountry?: string, filterProvince?: string, filterPhone?: string, filterType?: 'ADDRESS' | 'DELIVERY' | 'BILLING', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressIndex(filterId, filterCustomerId, filterAddressLine1, filterAddressLine2, filterCity, filterCountry, filterProvince, filterPhone, filterType, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns address by id
         * @summary Get address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressShow(address: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressShow(address, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating address
         * @summary Create new Address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject4} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressStore(accept?: string, contentType?: string, data?: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given address
         * @summary Update a address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject5} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressUpdate(address: string, accept?: string, contentType?: string, data?: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressUpdate(address, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a user token
         * @summary Get Token
         * @param {InlineObject32} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authToken(data?: InlineObject32, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20063>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authToken(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a cart demand by its id
         * @summary Delete cart demand
         * @param {string} cartDemand 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartDemandDestroy(cartDemand: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartDemandDestroy(cartDemand, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show cart demand of logged in user
         * @summary Show user cart demand.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartDemandIndex(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartDemandIndex(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sync user cart demand content
         * @summary Sync cart demand
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject22} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartDemandSync(accept?: string, contentType?: string, data?: InlineObject22, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartDemandSync(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} cartDemand 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody1} [imageRequestBody1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartDemandUploadImage(cartDemand: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody1?: ImageRequestBody1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartDemandUploadImage(cartDemand, filterId, page, perPage, sort, accept, contentType, imageRequestBody1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show cart of logged in user
         * @summary Show user cart.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartIndex(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartIndex(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sync user cart content
         * @summary Sync cart
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject21} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cartSync(accept?: string, contentType?: string, data?: InlineObject21, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cartSync(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the default channel of authenticated user
         * @summary Get default channel
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelDefault(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelDefault(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all channels available for this user
         * @summary Show all channels.
         * @param {string} [filterId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {string} [filterSupervisorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelIndex(filterId?: string, filterCompanyId?: number, filterName?: string, filterSupervisorId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelIndex(filterId, filterCompanyId, filterName, filterSupervisorId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns channel by id
         * @summary Get channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelShow(channel: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.channelShow(channel, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show companies
         * @summary Get all company account
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyAccountIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyAccountIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show companies
         * @summary Get all Companies
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns company by id
         * @summary Get Company
         * @param {string} company 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyShow(company: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyShow(company, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating customer
         * @summary Show create customer rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating customer with address
         * @summary Show create customer with address rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerCreateWithAddress(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreateWithAddress(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a customer by its id
         * @summary Delete Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDelete(customer: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDelete(customer, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new CustomerDeposit
         * @summary Create new CustomerDeposit
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject16} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDepositStore(accept?: string, contentType?: string, data?: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDepositStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing customer
         * @summary Show edit customer rules
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerEdit(customer: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerEdit(customer, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all activities of a given customer
         * @summary Show all activities of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGetActivities(customer: number, filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGetActivities(customer, filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all leads of a given customer
         * @summary Show all leads of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGetLeads(customer: number, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGetLeads(customer, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all Customer stored globally in the application.
         * @summary Show all customer.
         * @param {string} [filterId] 
         * @param {string} [filterFirstName] 
         * @param {string} [filterLastName] 
         * @param {string} [filterEmail] 
         * @param {string} [filterPhone] 
         * @param {string} [filterSearch] 
         * @param {boolean} [filterHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerIndex(filterId?: string, filterFirstName?: string, filterLastName?: string, filterEmail?: string, filterPhone?: string, filterSearch?: string, filterHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerIndex(filterId, filterFirstName, filterLastName, filterEmail, filterPhone, filterSearch, filterHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns customer by id
         * @summary Get Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerShow(customer: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerShow(customer, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating customer
         * @summary Create new Customer
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject2} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerStore(accept?: string, contentType?: string, data?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new customer with address. This will assign the address as the customer\'s default address id as well
         * @summary Create new customer with address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject1} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerStoreWithAddress(accept?: string, contentType?: string, data?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerStoreWithAddress(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given customer
         * @summary Update a customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject3} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerUpdate(customer: string, accept?: string, contentType?: string, data?: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerUpdate(customer, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns order deals by lead id
         * @summary Get order deals
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dealsleadSms(id: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dealsleadSms(id, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get discount that match the given discount code.
         * @summary Get discount by code
         * @param {string} code The discount activation code
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountGetByCode(code: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20046>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountGetByCode(code, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all public discounts.
         * @summary Get discounts
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterActivationCode] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discountIndex(filterId?: string, filterName?: string, filterActivationCode?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20045>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discountIndex(filterId, filterName, filterActivationCode, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all InteriorDesigns available for this user
         * @summary Show all InteriorDesigns.
         * @param {string} [filterId] 
         * @param {number} [filterReligionId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interiorDesignIndex(filterId?: string, filterReligionId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interiorDesignIndex(filterId, filterReligionId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns InteriorDesign by id
         * @summary Get InteriorDesign
         * @param {string} interiorDesign 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interiorDesignShow(interiorDesign: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interiorDesignShow(interiorDesign, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assign an unhandled lead
         * @summary Assign an unhandled lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject9} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadAssign(lead: string, accept?: string, contentType?: string, data?: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadAssign(lead, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all lead categories.
         * @summary Show all lead categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadCategories(filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadCategories(filterId, filterName, filterDescription, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating lead
         * @summary Show create product lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a lead by its id
         * @summary Delete Lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadDestroy(lead: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadDestroy(lead, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing lead
         * @summary Show edit lead rules
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadEdit(lead: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadEdit(lead, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadIndex(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadIndex(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns lead by id
         * @summary Get lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadShow(lead: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadShow(lead, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all sms user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadSms(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadSms(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Lead. Currently only sales are allowed to perform this action. This is because lead must be related to a sales. If we want to allow supervisor to add a new lead, they must pick which sales to assign this sales to (which is not supported yet).
         * @summary Create new Lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject10} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadStore(accept?: string, contentType?: string, data?: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Lead SMS. Currently only sales are allowed to perform this action. This is because lead must be related to a sales.
         * @summary Create new Lead SMS
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject7} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadStoreSms(accept?: string, contentType?: string, data?: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadStoreSms(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint only returns unhandled leads that the authenticated user is able to assign to. (i.e., sales will not be able to see any unhandled leads)
         * @summary Show all unhandled leads.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadUnhandledIndex(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadUnhandledIndex(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given lead
         * @summary Update a lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject11} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadUpdate(lead: string, accept?: string, contentType?: string, data?: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadUpdate(lead, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given lead SMS
         * @summary Update a lead SMS
         * @param {number} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject8} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadUpdateSms(id: number, accept?: string, contentType?: string, data?: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadUpdateSms(id, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Approve order
         * @summary Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject25} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderApprove(order: string, accept?: string, contentType?: string, data?: InlineObject25, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderApprove(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will cancel an order.
         * @summary Cancel an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderCancel(order: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderCancel(order, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This will clone and cancel a given order. Newly cloned order will be returned as response.
         * @summary Clone an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject27} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderClone(order: string, accept?: string, contentType?: string, data?: InlineObject27, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderClone(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} orderDetail 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody2} [imageRequestBody2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDetail(orderDetail: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody2?: ImageRequestBody2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDetail(orderDetail, filterId, page, perPage, sort, accept, contentType, imageRequestBody2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns orderDetail by id
         * @summary Get orderDetail
         * @param {string} orderDetail 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderDetailShow(orderDetail: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20049>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderDetailShow(orderDetail, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all order
         * @summary Show all order.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderIndex(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderIndex(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint only return orders that can be approved by the authenticated user.
         * @summary Show all orders waiting for approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderIndexWaitingApproval(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderIndexWaitingApproval(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint return approval discount orders that related with the authenticated user.
         * @summary Show all orders approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderListApproval(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderListApproval(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a dummy order for preview purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject23} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderPreview(accept?: string, contentType?: string, data?: InlineObject23, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderPreview(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a dummy order for preview update purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview update
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject24} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderPreviewUpdate(order: string, accept?: string, contentType?: string, data?: InlineObject24, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderPreviewUpdate(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request Approve order
         * @summary Request Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject26} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderRequestApprove(order: string, accept?: string, contentType?: string, data?: InlineObject26, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderRequestApprove(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns order by id
         * @summary Get order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderShow(order: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderShow(order, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new order
         * @summary Create new Order
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject28} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderStore(accept?: string, contentType?: string, data?: InlineObject28, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an order
         * @summary Update an Order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject29} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderUpdate(order: string, accept?: string, contentType?: string, data?: InlineObject29, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderUpdate(order, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all payment category
         * @summary Show all payment category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentCategoryIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20050>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentCategoryIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating payment
         * @summary Get create payment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing payment
         * @summary Show edit payment rules
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentEdit(payment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentEdit(payment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all payment
         * @summary Show all payment.
         * @param {string} [filterId] 
         * @param {number} [filterAmount] 
         * @param {string} [filterReference] 
         * @param {'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'} [filterStatus] 
         * @param {string} [filterPaymentTypeId] 
         * @param {string} [filterAddedById] 
         * @param {string} [filterApprovedById] 
         * @param {string} [filterOrderId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentIndex(filterId?: string, filterAmount?: number, filterReference?: string, filterStatus?: 'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT', filterPaymentTypeId?: string, filterAddedById?: string, filterApprovedById?: string, filterOrderId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20052>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentIndex(filterId, filterAmount, filterReference, filterStatus, filterPaymentTypeId, filterAddedById, filterApprovedById, filterOrderId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload proof of payment
         * @summary Upload proof of payment
         * @param {string} payment 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody3} [imageRequestBody3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentProofUpload(payment: string, filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody3?: ImageRequestBody3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentProofUpload(payment, filterId, filterName, page, perPage, sort, accept, contentType, imageRequestBody3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns payment by id
         * @summary Get payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentShow(payment: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentShow(payment, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new payment
         * @summary Create new Payment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject30} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentStore(accept?: string, contentType?: string, data?: InlineObject30, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all payment types
         * @summary Show all payment types.
         * @param {string} [filterId] 
         * @param {string} [filterPaymentCategoryId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentTypeIndex(filterId?: string, filterPaymentCategoryId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentTypeIndex(filterId, filterPaymentCategoryId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given payment
         * @summary Update a payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject31} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentUpdate(payment: string, accept?: string, contentType?: string, data?: InlineObject31, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentUpdate(payment, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productBrand(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productBrand(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryCodes(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryCodes(filterId, filterProductBrandId, filterProductModelId, filterProductVersionId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product category
         * @summary Show all product category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'} [filterType] 
         * @param {number} [filterParentId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryIndex(filterId?: string, filterName?: string, filterDescription?: string, filterType?: 'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY', filterParentId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20038>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryIndex(filterId, filterName, filterDescription, filterType, filterParentId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns product category by id
         * @summary Get product category
         * @param {string} productCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategoryShow(productCategory: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20039>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategoryShow(productCategory, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product
         * @summary Show all product.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {string} [filterProductCategoryCodeId] 
         * @param {string} [filterName] 
         * @param {string} [filterTags] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productIndex(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, filterProductCategoryCodeId?: string, filterName?: string, filterTags?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productIndex(filterId, filterProductBrandId, filterProductModelId, filterProductVersionId, filterProductCategoryCodeId, filterName, filterTags, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product model available.
         * @summary Show all product model.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productModel(filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productModel(filterId, filterProductBrandId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get product model for a given id.
         * @summary Get product model by id.
         * @param {string} model 
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productModelById(model: string, filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productModelById(model, filterId, filterProductBrandId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns product by id
         * @summary Get product
         * @param {string} product 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productShow(product: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productShow(product, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product tag
         * @summary Show all product tag.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterSlug] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productTagIndex(filterId?: string, filterName?: string, filterSlug?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productTagIndex(filterId, filterName, filterSlug, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns product tag by id
         * @summary Get product tag
         * @param {string} productTag 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productTagShow(productTag: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productTagShow(productTag, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product unit colours
         * @summary Show all product unit colours.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [filterProductId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitColours(filterId?: string, filterName?: string, filterDescription?: string, filterProductId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitColours(filterId, filterName, filterDescription, filterProductId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product unit coverings
         * @summary Show all product unit coverings.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {string} [filterName] 
         * @param {string} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitCoverings(filterId?: string, filterProductId?: number, filterName?: string, filterType?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitCoverings(filterId, filterProductId, filterName, filterType, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product unit
         * @summary Show all product unit.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitIndex(filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitIndex(filterId, filterProductId, filterColourId, filterCoveringId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns product unit by id
         * @summary Get product unit
         * @param {string} productUnit 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitShow(productUnit: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitShow(productUnit, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upload product unit image
         * @summary Upload product unit image
         * @param {string} productUnit 
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody} [imageRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUnitUpload(productUnit: string, filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody?: ImageRequestBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUnitUpload(productUnit, filterId, filterProductId, filterColourId, filterCoveringId, filterName, page, perPage, sort, accept, contentType, imageRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productVersion(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productVersion(filterId, filterProductBrandId, filterProductModelId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all promo categories.
         * @summary Show all promo categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoCategoryIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20059>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoCategoryIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns promo category by id
         * @summary Get promo category
         * @param {string} promoCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoCategoryShow(promoCategory: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20060>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoCategoryShow(promoCategory, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all promo
         * @summary Show all promo.
         * @param {string} [filterId] 
         * @param {number} [filterPromoCategoryId] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoIndex(filterId?: string, filterPromoCategoryId?: number, filterStartAfter?: string, filterEndBefore?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20061>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoIndex(filterId, filterPromoCategoryId, filterStartAfter, filterEndBefore, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns promo by id
         * @summary Get promo
         * @param {string} promo 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoShow(promo: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20062>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoShow(promo, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set all current user notification as read
         * @summary Clear all notifications
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationClear(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationClear(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all notifications
         * @summary Show all notifications
         * @param {'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationIndex(filterType?: 'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationIndex(filterType, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Subscribe device code to push notification
         * @summary Subscribe device code to push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationSubscribe(code: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationSubscribe(code, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a test notification
         * @summary Send a test notification
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject6} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationTest(accept?: string, contentType?: string, data?: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationTest(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unsubscribe device code from push notification
         * @summary Unsubscribe device code from push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationUnsubscribe(code: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationUnsubscribe(code, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating qa message
         * @summary Get create qa message rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a qa message by its id
         * @summary Delete Qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageDestroy(qaMessage: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageDestroy(qaMessage, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing qa message
         * @summary Show edit qa message rules
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageEdit(qaMessage: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageEdit(qaMessage, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all qa message
         * @summary Show all qa message.
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageIndex(filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageIndex(filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns qa message by id
         * @summary Get qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageShow(qaMessage: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageShow(qaMessage, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new qa message
         * @summary Create new Qa message
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject19} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageStore(accept?: string, contentType?: string, data?: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given qa message
         * @summary Update a qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject20} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaMessageUpdate(qaMessage: string, accept?: string, contentType?: string, data?: InlineObject20, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaMessageUpdate(qaMessage, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for creating qa topic
         * @summary Get create qa topic rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicCreate(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicCreate(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a qa topic by its id
         * @summary Delete Qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicDestroy(qaTopic: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicDestroy(qaTopic, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show the validation rules for editing qa topic
         * @summary Show edit qa topic rules
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicEdit(qaTopic: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicEdit(qaTopic, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
         * @summary Get all Qa Messages of a Qa Topic
         * @param {number} topic 
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicGetQaMessages(topic: number, filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicGetQaMessages(topic, filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all qa topic
         * @summary Show all qa topic.
         * @param {string} [filterId] 
         * @param {string} [filterSubject] 
         * @param {number} [filterCreatorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicIndex(filterId?: string, filterSubject?: string, filterCreatorId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicIndex(filterId, filterSubject, filterCreatorId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns qa topic by id
         * @summary Get qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicShow(qaTopic: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicShow(qaTopic, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new qa topic
         * @summary Create new Qa topic
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject17} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicStore(accept?: string, contentType?: string, data?: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicStore(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a given qa topic
         * @summary Update a qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject18} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qaTopicUpdate(qaTopic: string, accept?: string, contentType?: string, data?: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qaTopicUpdate(qaTopic, accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register sales SMS
         * @summary Register sales SMS
         * @param {InlineObject33} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(data?: InlineObject33, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all report
         * @summary Show all report.
         * @param {string} [filterId] 
         * @param {string} [filterPeriodBefore] 
         * @param {string} [filterPeriodAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportIndex(filterId?: string, filterPeriodBefore?: string, filterPeriodAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20056>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportIndex(filterId, filterPeriodBefore, filterPeriodAfter, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns report by id
         * @summary Get report
         * @param {string} report 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportShow(report: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20057>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportShow(report, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns lead sms by id
         * @summary Get lead sms
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showleadSms(id: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showleadSms(id, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all SMS channels available for this user
         * @summary Show all SMS channels.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smsChannelIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smsChannelIndex(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns SMS channel by id
         * @summary Get SMS channel
         * @param {string} smsChannel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smsChannelShow(smsChannel: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smsChannelShow(smsChannel, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smsProductBrand(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smsProductBrand(filterId, filterName, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all stock
         * @summary Show all stock.
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockIndex(filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20054>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockIndex(filterId, filterChannelId, filterProductUnitId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all stock with additional loaded properties.
         * @summary Show all stock (with extended data).
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockIndexExtended(filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20053>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockIndexExtended(filterId, filterChannelId, filterProductUnitId, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns stock by id
         * @summary Get stock
         * @param {string} stock 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockShow(stock: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockShow(stock, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sub lead categories.
         * @summary Get sub lead categories.
         * @param {string} leadCategory 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subLeadCategories(leadCategory: string, filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subLeadCategories(leadCategory, filterId, filterName, filterDescription, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all target
         * @summary Show all target.
         * @param {string} [filterId] 
         * @param {number} [filterReportId] 
         * @param {number} [filterIsDashboard] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {'COMPANY' | 'CHANNEL' | 'USER'} [filterReportableType] 
         * @param {string} [filterReportableIds] 
         * @param {'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'} [filterType] 
         * @param {number} [filterSupervisorTypeLevel] 
         * @param {number} [filterCompanyId] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async targetIndex(filterId?: string, filterReportId?: number, filterIsDashboard?: number, filterStartAfter?: string, filterEndBefore?: string, filterReportableType?: 'COMPANY' | 'CHANNEL' | 'USER', filterReportableIds?: string, filterType?: 'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT', filterSupervisorTypeLevel?: number, filterCompanyId?: number, filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20058>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.targetIndex(filterId, filterReportId, filterIsDashboard, filterStartAfter, filterEndBefore, filterReportableType, filterReportableIds, filterType, filterSupervisorTypeLevel, filterCompanyId, filterDescendantOf, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change password of currently logged in user
         * @summary Change password
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userChangePassword(accept?: string, contentType?: string, data?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userChangePassword(accept, contentType, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all users registered in the system. This is currently unfiltered, but in the future we may filter to limit user visibility.
         * @summary Show all users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userIndex(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userIndex(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Front end should filter by company id
         * @summary Show list of available users to look into the report.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListForReport(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListForReport(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user resource of the currently logged in user
         * @summary Get logged in user detail
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMe(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMe(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the default channel for this user. Default channel must be set before user can access tenanted resources.
         * @summary Set default channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSetDefaultChannel(channel: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSetDefaultChannel(channel, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Currently allow access to all users on the system
         * @summary Get user detail
         * @param {string} user 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShow(user: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShow(user, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Show all users that is supervised by this user (all child and grandchild nodes). Does not include data of currently logged in user and data of supervisor.
         * @summary Show all supervised users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSupervised(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSupervised(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the detail of logged in user\'s supervisor (direct parent)
         * @summary Get detail of supervisor
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSupervisor(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSupervisor(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get list supervisor types
         * @summary Get list supervisor types
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSupervisorTypes(accept?: string, contentType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSupervisorTypes(accept, contentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1Api - factory interface
 * @export
 */
export const V1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1ApiFp(configuration)
    return {
        /**
         * Show the validation rules for creating activityComment
         * @summary Get create ActivityComment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.activityCommentCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a activityComment by its id
         * @summary Delete ActivityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentDestroy(activityComment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.activityCommentDestroy(activityComment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing activityComment
         * @summary Show edit activityComment rules
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentEdit(activityComment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.activityCommentEdit(activityComment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all activity comments posted by this user
         * @summary Show user\'s activity comment.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentIndex(filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.activityCommentIndex(filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns activityComment by id
         * @summary Get activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentShow(activityComment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2013> {
            return localVarFp.activityCommentShow(activityComment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new activityComment
         * @summary Create new ActivityComment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject14} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentStore(accept?: string, contentType?: string, data?: InlineObject14, options?: any): AxiosPromise<InlineResponse2013> {
            return localVarFp.activityCommentStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given activityComment
         * @summary Update a activityComment
         * @param {string} activityComment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject15} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCommentUpdate(activityComment: string, accept?: string, contentType?: string, data?: InlineObject15, options?: any): AxiosPromise<InlineResponse2013> {
            return localVarFp.activityCommentUpdate(activityComment, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating activity
         * @summary Show create product activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.activityCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a activity by its id
         * @summary Delete Activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityDestroy(activity: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.activityDestroy(activity, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing activity
         * @summary Show edit activity rules
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityEdit(activity: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.activityEdit(activity, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all activity comments for a given activity.
         * @summary Show all activity comments of an activity.
         * @param {number} activity 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {number} [filterActivityId] 
         * @param {number} [filterActivityCommentId] 
         * @param {string} [filterContent] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityGetComments(activity: number, filterId?: string, filterUserId?: number, filterActivityId?: number, filterActivityCommentId?: number, filterContent?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.activityGetComments(activity, filterId, filterUserId, filterActivityId, filterActivityCommentId, filterContent, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Sales will get all activities directly created by him. Supervisor will get all activities created by its supervised sales. Director will get all activities scoped to its active channel setting.
         * @summary Show all activity posted by user
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityIndex(filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.activityIndex(filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @summary Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
         * @param {string} userId 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityReport(userId: string, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.activityReport(userId, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns activity by id
         * @summary Get activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityShow(activity: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.activityShow(activity, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new activity
         * @summary Create new Activity
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject12} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityStore(accept?: string, contentType?: string, data?: InlineObject12, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.activityStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given activity
         * @summary Update a activity
         * @param {string} activity 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject13} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activityUpdate(activity: string, accept?: string, contentType?: string, data?: InlineObject13, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.activityUpdate(activity, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating address
         * @summary Show create product address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.addressCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a address by its id
         * @summary Delete Address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressDestroy(address: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.addressDestroy(address, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing address
         * @summary Show edit address rules
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressEdit(address: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.addressEdit(address, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all address
         * @summary Show all address.
         * @param {string} [filterId] 
         * @param {number} [filterCustomerId] 
         * @param {string} [filterAddressLine1] 
         * @param {string} [filterAddressLine2] 
         * @param {string} [filterCity] 
         * @param {string} [filterCountry] 
         * @param {string} [filterProvince] 
         * @param {string} [filterPhone] 
         * @param {'ADDRESS' | 'DELIVERY' | 'BILLING'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressIndex(filterId?: string, filterCustomerId?: number, filterAddressLine1?: string, filterAddressLine2?: string, filterCity?: string, filterCountry?: string, filterProvince?: string, filterPhone?: string, filterType?: 'ADDRESS' | 'DELIVERY' | 'BILLING', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.addressIndex(filterId, filterCustomerId, filterAddressLine1, filterAddressLine2, filterCity, filterCountry, filterProvince, filterPhone, filterType, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns address by id
         * @summary Get address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressShow(address: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.addressShow(address, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating address
         * @summary Create new Address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject4} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressStore(accept?: string, contentType?: string, data?: InlineObject4, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.addressStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given address
         * @summary Update a address
         * @param {string} address 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject5} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressUpdate(address: string, accept?: string, contentType?: string, data?: InlineObject5, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.addressUpdate(address, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user token
         * @summary Get Token
         * @param {InlineObject32} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authToken(data?: InlineObject32, options?: any): AxiosPromise<InlineResponse20063> {
            return localVarFp.authToken(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a cart demand by its id
         * @summary Delete cart demand
         * @param {string} cartDemand 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandDestroy(cartDemand: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.cartDemandDestroy(cartDemand, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show cart demand of logged in user
         * @summary Show user cart demand.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandIndex(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20044> {
            return localVarFp.cartDemandIndex(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync user cart demand content
         * @summary Sync cart demand
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject22} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandSync(accept?: string, contentType?: string, data?: InlineObject22, options?: any): AxiosPromise<InlineResponse20044> {
            return localVarFp.cartDemandSync(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} cartDemand 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody1} [imageRequestBody1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartDemandUploadImage(cartDemand: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody1?: ImageRequestBody1, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.cartDemandUploadImage(cartDemand, filterId, page, perPage, sort, accept, contentType, imageRequestBody1, options).then((request) => request(axios, basePath));
        },
        /**
         * Show cart of logged in user
         * @summary Show user cart.
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartIndex(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20043> {
            return localVarFp.cartIndex(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync user cart content
         * @summary Sync cart
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject21} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cartSync(accept?: string, contentType?: string, data?: InlineObject21, options?: any): AxiosPromise<InlineResponse20043> {
            return localVarFp.cartSync(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the default channel of authenticated user
         * @summary Get default channel
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDefault(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.channelDefault(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all channels available for this user
         * @summary Show all channels.
         * @param {string} [filterId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {string} [filterSupervisorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelIndex(filterId?: string, filterCompanyId?: number, filterName?: string, filterSupervisorId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.channelIndex(filterId, filterCompanyId, filterName, filterSupervisorId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns channel by id
         * @summary Get channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelShow(channel: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.channelShow(channel, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show companies
         * @summary Get all company account
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyAccountIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.companyAccountIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show companies
         * @summary Get all Companies
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.companyIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns company by id
         * @summary Get Company
         * @param {string} company 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyShow(company: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.companyShow(company, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating customer
         * @summary Show create customer rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.customerCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating customer with address
         * @summary Show create customer with address rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreateWithAddress(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.customerCreateWithAddress(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a customer by its id
         * @summary Delete Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDelete(customer: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.customerDelete(customer, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new CustomerDeposit
         * @summary Create new CustomerDeposit
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject16} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDepositStore(accept?: string, contentType?: string, data?: InlineObject16, options?: any): AxiosPromise<InlineResponse2014> {
            return localVarFp.customerDepositStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing customer
         * @summary Show edit customer rules
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerEdit(customer: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.customerEdit(customer, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all activities of a given customer
         * @summary Show all activities of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterOrderId] 
         * @param {string} [filterUserId] 
         * @param {string} [filterCustomerId] 
         * @param {string} [filterChannelId] 
         * @param {number} [filterCompanyId] 
         * @param {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'} [filterFollowUpMethod] 
         * @param {'HOT' | 'WARM' | 'COLD' | 'DROP'} [filterStatus] 
         * @param {string} [filterFeedback] 
         * @param {number} [filterTargetId] 
         * @param {string} [filterFollowUpDatetimeBefore] 
         * @param {string} [filterFollowUpDatetimeAfter] 
         * @param {boolean} [filterHasPayment] 
         * @param {string} [filterHasAnyBrands] 
         * @param {string} [filterCreatedBefore] 
         * @param {string} [filterCreatedAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetActivities(customer: number, filterId?: string, filterOrderId?: number, filterUserId?: string, filterCustomerId?: string, filterChannelId?: string, filterCompanyId?: number, filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER', filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP', filterFeedback?: string, filterTargetId?: number, filterFollowUpDatetimeBefore?: string, filterFollowUpDatetimeAfter?: string, filterHasPayment?: boolean, filterHasAnyBrands?: string, filterCreatedBefore?: string, filterCreatedAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.customerGetActivities(customer, filterId, filterOrderId, filterUserId, filterCustomerId, filterChannelId, filterCompanyId, filterFollowUpMethod, filterStatus, filterFeedback, filterTargetId, filterFollowUpDatetimeBefore, filterFollowUpDatetimeAfter, filterHasPayment, filterHasAnyBrands, filterCreatedBefore, filterCreatedAfter, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all leads of a given customer
         * @summary Show all leads of a customer.
         * @param {number} customer 
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGetLeads(customer: number, filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.customerGetLeads(customer, filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all Customer stored globally in the application.
         * @summary Show all customer.
         * @param {string} [filterId] 
         * @param {string} [filterFirstName] 
         * @param {string} [filterLastName] 
         * @param {string} [filterEmail] 
         * @param {string} [filterPhone] 
         * @param {string} [filterSearch] 
         * @param {boolean} [filterHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerIndex(filterId?: string, filterFirstName?: string, filterLastName?: string, filterEmail?: string, filterPhone?: string, filterSearch?: string, filterHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.customerIndex(filterId, filterFirstName, filterLastName, filterEmail, filterPhone, filterSearch, filterHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns customer by id
         * @summary Get Customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerShow(customer: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.customerShow(customer, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating customer
         * @summary Create new Customer
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject2} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerStore(accept?: string, contentType?: string, data?: InlineObject2, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.customerStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new customer with address. This will assign the address as the customer\'s default address id as well
         * @summary Create new customer with address
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject1} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerStoreWithAddress(accept?: string, contentType?: string, data?: InlineObject1, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.customerStoreWithAddress(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given customer
         * @summary Update a customer
         * @param {string} customer 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject3} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate(customer: string, accept?: string, contentType?: string, data?: InlineObject3, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.customerUpdate(customer, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns order deals by lead id
         * @summary Get order deals
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dealsleadSms(id: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.dealsleadSms(id, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get discount that match the given discount code.
         * @summary Get discount by code
         * @param {string} code The discount activation code
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountGetByCode(code: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20046> {
            return localVarFp.discountGetByCode(code, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all public discounts.
         * @summary Get discounts
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterActivationCode] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountIndex(filterId?: string, filterName?: string, filterActivationCode?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20045> {
            return localVarFp.discountIndex(filterId, filterName, filterActivationCode, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all InteriorDesigns available for this user
         * @summary Show all InteriorDesigns.
         * @param {string} [filterId] 
         * @param {number} [filterReligionId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interiorDesignIndex(filterId?: string, filterReligionId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.interiorDesignIndex(filterId, filterReligionId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns InteriorDesign by id
         * @summary Get InteriorDesign
         * @param {string} interiorDesign 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interiorDesignShow(interiorDesign: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.interiorDesignShow(interiorDesign, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign an unhandled lead
         * @summary Assign an unhandled lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject9} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadAssign(lead: string, accept?: string, contentType?: string, data?: InlineObject9, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.leadAssign(lead, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all lead categories.
         * @summary Show all lead categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadCategories(filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.leadCategories(filterId, filterName, filterDescription, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating lead
         * @summary Show create product lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.leadCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a lead by its id
         * @summary Delete Lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadDestroy(lead: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.leadDestroy(lead, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing lead
         * @summary Show edit lead rules
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadEdit(lead: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.leadEdit(lead, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadIndex(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.leadIndex(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns lead by id
         * @summary Get lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadShow(lead: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.leadShow(lead, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
         * @summary Show all sms user\'s lead.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadSms(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.leadSms(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Lead. Currently only sales are allowed to perform this action. This is because lead must be related to a sales. If we want to allow supervisor to add a new lead, they must pick which sales to assign this sales to (which is not supported yet).
         * @summary Create new Lead
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject10} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadStore(accept?: string, contentType?: string, data?: InlineObject10, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.leadStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Lead SMS. Currently only sales are allowed to perform this action. This is because lead must be related to a sales.
         * @summary Create new Lead SMS
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject7} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadStoreSms(accept?: string, contentType?: string, data?: InlineObject7, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.leadStoreSms(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint only returns unhandled leads that the authenticated user is able to assign to. (i.e., sales will not be able to see any unhandled leads)
         * @summary Show all unhandled leads.
         * @param {string} [filterId] 
         * @param {number} [filterUserId] 
         * @param {'PROSPECT' | 'DROP' | 'LEADS'} [filterType] 
         * @param {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'} [filterStatus] 
         * @param {string} [filterLabel] 
         * @param {number} [filterLeadCategoryId] 
         * @param {number} [filterSubLeadCategoryId] 
         * @param {string} [filterCustomerName] 
         * @param {string} [filterCustomerSearch] 
         * @param {string} [filterChannelName] 
         * @param {string} [filterSmsChannelName] 
         * @param {boolean} [filterIsNewCustomer] 
         * @param {boolean} [filterHasActivity] 
         * @param {boolean} [filterCustomerHasActivity] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUnhandledIndex(filterId?: string, filterUserId?: number, filterType?: 'PROSPECT' | 'DROP' | 'LEADS', filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES', filterLabel?: string, filterLeadCategoryId?: number, filterSubLeadCategoryId?: number, filterCustomerName?: string, filterCustomerSearch?: string, filterChannelName?: string, filterSmsChannelName?: string, filterIsNewCustomer?: boolean, filterHasActivity?: boolean, filterCustomerHasActivity?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.leadUnhandledIndex(filterId, filterUserId, filterType, filterStatus, filterLabel, filterLeadCategoryId, filterSubLeadCategoryId, filterCustomerName, filterCustomerSearch, filterChannelName, filterSmsChannelName, filterIsNewCustomer, filterHasActivity, filterCustomerHasActivity, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given lead
         * @summary Update a lead
         * @param {string} lead 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject11} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUpdate(lead: string, accept?: string, contentType?: string, data?: InlineObject11, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.leadUpdate(lead, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given lead SMS
         * @summary Update a lead SMS
         * @param {number} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject8} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadUpdateSms(id: number, accept?: string, contentType?: string, data?: InlineObject8, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.leadUpdateSms(id, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Approve order
         * @summary Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject25} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderApprove(order: string, accept?: string, contentType?: string, data?: InlineObject25, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderApprove(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * This will cancel an order.
         * @summary Cancel an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCancel(order: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderCancel(order, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * This will clone and cancel a given order. Newly cloned order will be returned as response.
         * @summary Clone an order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject27} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderClone(order: string, accept?: string, contentType?: string, data?: InlineObject27, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderClone(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload order detail product unit image
         * @summary Upload order detail product unit image
         * @param {string} orderDetail 
         * @param {string} [filterId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody2} [imageRequestBody2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetail(orderDetail: string, filterId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody2?: ImageRequestBody2, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.orderDetail(orderDetail, filterId, page, perPage, sort, accept, contentType, imageRequestBody2, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns orderDetail by id
         * @summary Get orderDetail
         * @param {string} orderDetail 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderDetailShow(orderDetail: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20049> {
            return localVarFp.orderDetailShow(orderDetail, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all order
         * @summary Show all order.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIndex(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20048> {
            return localVarFp.orderIndex(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint only return orders that can be approved by the authenticated user.
         * @summary Show all orders waiting for approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderIndexWaitingApproval(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20048> {
            return localVarFp.orderIndexWaitingApproval(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint return approval discount orders that related with the authenticated user.
         * @summary Show all orders approval
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterSearch] 
         * @param {string} [filterInvoiceNumber] 
         * @param {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'} [filterApprovalStatus] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderListApproval(filterId?: string, filterProductBrandId?: string, filterSearch?: string, filterInvoiceNumber?: string, filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20048> {
            return localVarFp.orderListApproval(filterId, filterProductBrandId, filterSearch, filterInvoiceNumber, filterApprovalStatus, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a dummy order for preview purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject23} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPreview(accept?: string, contentType?: string, data?: InlineObject23, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderPreview(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a dummy order for preview update purposes. Use this endpoint to check how the order will look like with the discount applied.
         * @summary Order preview update
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject24} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPreviewUpdate(order: string, accept?: string, contentType?: string, data?: InlineObject24, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderPreviewUpdate(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Request Approve order
         * @summary Request Approve order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject26} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRequestApprove(order: string, accept?: string, contentType?: string, data?: InlineObject26, options?: any): AxiosPromise<void> {
            return localVarFp.orderRequestApprove(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns order by id
         * @summary Get order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShow(order: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderShow(order, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new order
         * @summary Create new Order
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject28} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderStore(accept?: string, contentType?: string, data?: InlineObject28, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an order
         * @summary Update an Order
         * @param {string} order 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject29} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderUpdate(order: string, accept?: string, contentType?: string, data?: InlineObject29, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.orderUpdate(order, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all payment category
         * @summary Show all payment category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCategoryIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20050> {
            return localVarFp.paymentCategoryIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating payment
         * @summary Get create payment rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.paymentCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing payment
         * @summary Show edit payment rules
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentEdit(payment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.paymentEdit(payment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all payment
         * @summary Show all payment.
         * @param {string} [filterId] 
         * @param {number} [filterAmount] 
         * @param {string} [filterReference] 
         * @param {'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'} [filterStatus] 
         * @param {string} [filterPaymentTypeId] 
         * @param {string} [filterAddedById] 
         * @param {string} [filterApprovedById] 
         * @param {string} [filterOrderId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIndex(filterId?: string, filterAmount?: number, filterReference?: string, filterStatus?: 'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT', filterPaymentTypeId?: string, filterAddedById?: string, filterApprovedById?: string, filterOrderId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20052> {
            return localVarFp.paymentIndex(filterId, filterAmount, filterReference, filterStatus, filterPaymentTypeId, filterAddedById, filterApprovedById, filterOrderId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload proof of payment
         * @summary Upload proof of payment
         * @param {string} payment 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody3} [imageRequestBody3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentProofUpload(payment: string, filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody3?: ImageRequestBody3, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.paymentProofUpload(payment, filterId, filterName, page, perPage, sort, accept, contentType, imageRequestBody3, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns payment by id
         * @summary Get payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentShow(payment: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.paymentShow(payment, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new payment
         * @summary Create new Payment
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject30} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentStore(accept?: string, contentType?: string, data?: InlineObject30, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.paymentStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all payment types
         * @summary Show all payment types.
         * @param {string} [filterId] 
         * @param {string} [filterPaymentCategoryId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentTypeIndex(filterId?: string, filterPaymentCategoryId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20051> {
            return localVarFp.paymentTypeIndex(filterId, filterPaymentCategoryId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given payment
         * @summary Update a payment
         * @param {string} payment 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject31} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUpdate(payment: string, accept?: string, contentType?: string, data?: InlineObject31, options?: any): AxiosPromise<InlineResponse2017> {
            return localVarFp.paymentUpdate(payment, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productBrand(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.productBrand(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryCodes(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20029> {
            return localVarFp.productCategoryCodes(filterId, filterProductBrandId, filterProductModelId, filterProductVersionId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product category
         * @summary Show all product category.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'} [filterType] 
         * @param {number} [filterParentId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryIndex(filterId?: string, filterName?: string, filterDescription?: string, filterType?: 'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY', filterParentId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20038> {
            return localVarFp.productCategoryIndex(filterId, filterName, filterDescription, filterType, filterParentId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns product category by id
         * @summary Get product category
         * @param {string} productCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategoryShow(productCategory: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20039> {
            return localVarFp.productCategoryShow(productCategory, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product
         * @summary Show all product.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {string} [filterProductVersionId] 
         * @param {string} [filterProductCategoryCodeId] 
         * @param {string} [filterName] 
         * @param {string} [filterTags] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productIndex(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, filterProductVersionId?: string, filterProductCategoryCodeId?: string, filterName?: string, filterTags?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20030> {
            return localVarFp.productIndex(filterId, filterProductBrandId, filterProductModelId, filterProductVersionId, filterProductCategoryCodeId, filterName, filterTags, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product model available.
         * @summary Show all product model.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productModel(filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20026> {
            return localVarFp.productModel(filterId, filterProductBrandId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get product model for a given id.
         * @summary Get product model by id.
         * @param {string} model 
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productModelById(model: string, filterId?: string, filterProductBrandId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20027> {
            return localVarFp.productModelById(model, filterId, filterProductBrandId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns product by id
         * @summary Get product
         * @param {string} product 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productShow(product: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20031> {
            return localVarFp.productShow(product, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product tag
         * @summary Show all product tag.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterSlug] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagIndex(filterId?: string, filterName?: string, filterSlug?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20036> {
            return localVarFp.productTagIndex(filterId, filterName, filterSlug, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns product tag by id
         * @summary Get product tag
         * @param {string} productTag 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productTagShow(productTag: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20037> {
            return localVarFp.productTagShow(productTag, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product unit colours
         * @summary Show all product unit colours.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [filterProductId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitColours(filterId?: string, filterName?: string, filterDescription?: string, filterProductId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20032> {
            return localVarFp.productUnitColours(filterId, filterName, filterDescription, filterProductId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product unit coverings
         * @summary Show all product unit coverings.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {string} [filterName] 
         * @param {string} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitCoverings(filterId?: string, filterProductId?: number, filterName?: string, filterType?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20033> {
            return localVarFp.productUnitCoverings(filterId, filterProductId, filterName, filterType, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product unit
         * @summary Show all product unit.
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitIndex(filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20034> {
            return localVarFp.productUnitIndex(filterId, filterProductId, filterColourId, filterCoveringId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns product unit by id
         * @summary Get product unit
         * @param {string} productUnit 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitShow(productUnit: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20035> {
            return localVarFp.productUnitShow(productUnit, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload product unit image
         * @summary Upload product unit image
         * @param {string} productUnit 
         * @param {string} [filterId] 
         * @param {number} [filterProductId] 
         * @param {number} [filterColourId] 
         * @param {number} [filterCoveringId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {ImageRequestBody} [imageRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUnitUpload(productUnit: string, filterId?: string, filterProductId?: number, filterColourId?: number, filterCoveringId?: number, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, imageRequestBody?: ImageRequestBody, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.productUnitUpload(productUnit, filterId, filterProductId, filterColourId, filterCoveringId, filterName, page, perPage, sort, accept, contentType, imageRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product version available.
         * @summary Show all product version.
         * @param {string} [filterId] 
         * @param {string} [filterProductBrandId] 
         * @param {string} [filterProductModelId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productVersion(filterId?: string, filterProductBrandId?: string, filterProductModelId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20028> {
            return localVarFp.productVersion(filterId, filterProductBrandId, filterProductModelId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all promo categories.
         * @summary Show all promo categories.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoCategoryIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20059> {
            return localVarFp.promoCategoryIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns promo category by id
         * @summary Get promo category
         * @param {string} promoCategory 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoCategoryShow(promoCategory: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20060> {
            return localVarFp.promoCategoryShow(promoCategory, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all promo
         * @summary Show all promo.
         * @param {string} [filterId] 
         * @param {number} [filterPromoCategoryId] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoIndex(filterId?: string, filterPromoCategoryId?: number, filterStartAfter?: string, filterEndBefore?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20061> {
            return localVarFp.promoIndex(filterId, filterPromoCategoryId, filterStartAfter, filterEndBefore, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns promo by id
         * @summary Get promo
         * @param {string} promo 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoShow(promo: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20062> {
            return localVarFp.promoShow(promo, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Set all current user notification as read
         * @summary Clear all notifications
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationClear(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.pushNotificationClear(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all notifications
         * @summary Show all notifications
         * @param {'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'} [filterType] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationIndex(filterType?: 'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval', page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.pushNotificationIndex(filterType, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscribe device code to push notification
         * @summary Subscribe device code to push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationSubscribe(code: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.pushNotificationSubscribe(code, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a test notification
         * @summary Send a test notification
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject6} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationTest(accept?: string, contentType?: string, data?: InlineObject6, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.pushNotificationTest(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsubscribe device code from push notification
         * @summary Unsubscribe device code from push notification
         * @param {string} code 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationUnsubscribe(code: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.pushNotificationUnsubscribe(code, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating qa message
         * @summary Get create qa message rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.qaMessageCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a qa message by its id
         * @summary Delete Qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageDestroy(qaMessage: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.qaMessageDestroy(qaMessage, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing qa message
         * @summary Show edit qa message rules
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageEdit(qaMessage: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.qaMessageEdit(qaMessage, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all qa message
         * @summary Show all qa message.
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageIndex(filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20040> {
            return localVarFp.qaMessageIndex(filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns qa message by id
         * @summary Get qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageShow(qaMessage: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2016> {
            return localVarFp.qaMessageShow(qaMessage, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new qa message
         * @summary Create new Qa message
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject19} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageStore(accept?: string, contentType?: string, data?: InlineObject19, options?: any): AxiosPromise<InlineResponse2016> {
            return localVarFp.qaMessageStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given qa message
         * @summary Update a qa message
         * @param {string} qaMessage 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject20} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaMessageUpdate(qaMessage: string, accept?: string, contentType?: string, data?: InlineObject20, options?: any): AxiosPromise<InlineResponse2016> {
            return localVarFp.qaMessageUpdate(qaMessage, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for creating qa topic
         * @summary Get create qa topic rule
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicCreate(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.qaTopicCreate(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a qa topic by its id
         * @summary Delete Qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicDestroy(qaTopic: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.qaTopicDestroy(qaTopic, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the validation rules for editing qa topic
         * @summary Show edit qa topic rules
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicEdit(qaTopic: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.qaTopicEdit(qaTopic, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
         * @summary Get all Qa Messages of a Qa Topic
         * @param {number} topic 
         * @param {string} [filterId] 
         * @param {string} [filterContent] 
         * @param {string} [filterTopicId] 
         * @param {string} [filterSenderId] 
         * @param {boolean} [filterIsUnread] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicGetQaMessages(topic: number, filterId?: string, filterContent?: string, filterTopicId?: string, filterSenderId?: string, filterIsUnread?: boolean, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20040> {
            return localVarFp.qaTopicGetQaMessages(topic, filterId, filterContent, filterTopicId, filterSenderId, filterIsUnread, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all qa topic
         * @summary Show all qa topic.
         * @param {string} [filterId] 
         * @param {string} [filterSubject] 
         * @param {number} [filterCreatorId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicIndex(filterId?: string, filterSubject?: string, filterCreatorId?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20041> {
            return localVarFp.qaTopicIndex(filterId, filterSubject, filterCreatorId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns qa topic by id
         * @summary Get qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicShow(qaTopic: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20042> {
            return localVarFp.qaTopicShow(qaTopic, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new qa topic
         * @summary Create new Qa topic
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject17} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicStore(accept?: string, contentType?: string, data?: InlineObject17, options?: any): AxiosPromise<InlineResponse2015> {
            return localVarFp.qaTopicStore(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a given qa topic
         * @summary Update a qa topic
         * @param {string} qaTopic 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject18} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qaTopicUpdate(qaTopic: string, accept?: string, contentType?: string, data?: InlineObject18, options?: any): AxiosPromise<InlineResponse20042> {
            return localVarFp.qaTopicUpdate(qaTopic, accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Register sales SMS
         * @summary Register sales SMS
         * @param {InlineObject33} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(data?: InlineObject33, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.register(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all report
         * @summary Show all report.
         * @param {string} [filterId] 
         * @param {string} [filterPeriodBefore] 
         * @param {string} [filterPeriodAfter] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportIndex(filterId?: string, filterPeriodBefore?: string, filterPeriodAfter?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20056> {
            return localVarFp.reportIndex(filterId, filterPeriodBefore, filterPeriodAfter, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns report by id
         * @summary Get report
         * @param {string} report 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportShow(report: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20057> {
            return localVarFp.reportShow(report, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns lead sms by id
         * @summary Get lead sms
         * @param {string} id 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showleadSms(id: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.showleadSms(id, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all SMS channels available for this user
         * @summary Show all SMS channels.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsChannelIndex(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.smsChannelIndex(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns SMS channel by id
         * @summary Get SMS channel
         * @param {string} smsChannel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsChannelShow(smsChannel: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.smsChannelShow(smsChannel, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all product brands available for the active company
         * @summary Show all brands.
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smsProductBrand(filterId?: string, filterName?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.smsProductBrand(filterId, filterName, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all stock
         * @summary Show all stock.
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockIndex(filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20054> {
            return localVarFp.stockIndex(filterId, filterChannelId, filterProductUnitId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all stock with additional loaded properties.
         * @summary Show all stock (with extended data).
         * @param {string} [filterId] 
         * @param {string} [filterChannelId] 
         * @param {string} [filterProductUnitId] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockIndexExtended(filterId?: string, filterChannelId?: string, filterProductUnitId?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20053> {
            return localVarFp.stockIndexExtended(filterId, filterChannelId, filterProductUnitId, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns stock by id
         * @summary Get stock
         * @param {string} stock 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShow(stock: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20055> {
            return localVarFp.stockShow(stock, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sub lead categories.
         * @summary Get sub lead categories.
         * @param {string} leadCategory 
         * @param {string} [filterId] 
         * @param {string} [filterName] 
         * @param {string} [filterDescription] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subLeadCategories(leadCategory: string, filterId?: string, filterName?: string, filterDescription?: string, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20023> {
            return localVarFp.subLeadCategories(leadCategory, filterId, filterName, filterDescription, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all target
         * @summary Show all target.
         * @param {string} [filterId] 
         * @param {number} [filterReportId] 
         * @param {number} [filterIsDashboard] 
         * @param {string} [filterStartAfter] 
         * @param {string} [filterEndBefore] 
         * @param {'COMPANY' | 'CHANNEL' | 'USER'} [filterReportableType] 
         * @param {string} [filterReportableIds] 
         * @param {'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'} [filterType] 
         * @param {number} [filterSupervisorTypeLevel] 
         * @param {number} [filterCompanyId] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetIndex(filterId?: string, filterReportId?: number, filterIsDashboard?: number, filterStartAfter?: string, filterEndBefore?: string, filterReportableType?: 'COMPANY' | 'CHANNEL' | 'USER', filterReportableIds?: string, filterType?: 'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT', filterSupervisorTypeLevel?: number, filterCompanyId?: number, filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse20058> {
            return localVarFp.targetIndex(filterId, filterReportId, filterIsDashboard, filterStartAfter, filterEndBefore, filterReportableType, filterReportableIds, filterType, filterSupervisorTypeLevel, filterCompanyId, filterDescendantOf, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Change password of currently logged in user
         * @summary Change password
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {InlineObject} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userChangePassword(accept?: string, contentType?: string, data?: InlineObject, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.userChangePassword(accept, contentType, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all users registered in the system. This is currently unfiltered, but in the future we may filter to limit user visibility.
         * @summary Show all users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIndex(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.userIndex(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Front end should filter by company id
         * @summary Show list of available users to look into the report.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListForReport(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.userListForReport(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user resource of the currently logged in user
         * @summary Get logged in user detail
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMe(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.userMe(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the default channel for this user. Default channel must be set before user can access tenanted resources.
         * @summary Set default channel
         * @param {string} channel 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetDefaultChannel(channel: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.userSetDefaultChannel(channel, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Currently allow access to all users on the system
         * @summary Get user detail
         * @param {string} user 
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShow(user: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.userShow(user, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all users that is supervised by this user (all child and grandchild nodes). Does not include data of currently logged in user and data of supervisor.
         * @summary Show all supervised users.
         * @param {string} [filterId] 
         * @param {number} [filterChannelId] 
         * @param {string} [filterSupervisorId] 
         * @param {string} [filterSupervisorTypeId] 
         * @param {number} [filterCompanyId] 
         * @param {string} [filterName] 
         * @param {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'} [filterType] 
         * @param {number} [filterDescendantOf] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [sort] Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervised(filterId?: string, filterChannelId?: number, filterSupervisorId?: string, filterSupervisorTypeId?: string, filterCompanyId?: number, filterName?: string, filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS', filterDescendantOf?: number, page?: number, perPage?: number, sort?: string, accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.userSupervised(filterId, filterChannelId, filterSupervisorId, filterSupervisorTypeId, filterCompanyId, filterName, filterType, filterDescendantOf, page, perPage, sort, accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the detail of logged in user\'s supervisor (direct parent)
         * @summary Get detail of supervisor
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervisor(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.userSupervisor(accept, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list supervisor types
         * @summary Get list supervisor types
         * @param {string} [accept] API call should request for json response
         * @param {string} [contentType] API call should be json data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSupervisorTypes(accept?: string, contentType?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.userSupervisorTypes(accept, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activityCommentCreate operation in V1Api.
 * @export
 * @interface V1ApiActivityCommentCreateRequest
 */
export interface V1ApiActivityCommentCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityCommentCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityCommentCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCommentDestroy operation in V1Api.
 * @export
 * @interface V1ApiActivityCommentDestroyRequest
 */
export interface V1ApiActivityCommentDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityCommentDestroy
     */
    readonly activityComment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityCommentDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityCommentDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCommentEdit operation in V1Api.
 * @export
 * @interface V1ApiActivityCommentEditRequest
 */
export interface V1ApiActivityCommentEditRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityCommentEdit
     */
    readonly activityComment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityCommentEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityCommentEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCommentIndex operation in V1Api.
 * @export
 * @interface V1ApiActivityCommentIndexRequest
 */
export interface V1ApiActivityCommentIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly filterActivityId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly filterActivityCommentId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly filterContent?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityCommentIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCommentShow operation in V1Api.
 * @export
 * @interface V1ApiActivityCommentShowRequest
 */
export interface V1ApiActivityCommentShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityCommentShow
     */
    readonly activityComment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityCommentShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityCommentShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityCommentStore operation in V1Api.
 * @export
 * @interface V1ApiActivityCommentStoreRequest
 */
export interface V1ApiActivityCommentStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityCommentStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityCommentStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject14}
     * @memberof V1ApiActivityCommentStore
     */
    readonly data?: InlineObject14
}

/**
 * Request parameters for activityCommentUpdate operation in V1Api.
 * @export
 * @interface V1ApiActivityCommentUpdateRequest
 */
export interface V1ApiActivityCommentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityCommentUpdate
     */
    readonly activityComment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityCommentUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityCommentUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject15}
     * @memberof V1ApiActivityCommentUpdate
     */
    readonly data?: InlineObject15
}

/**
 * Request parameters for activityCreate operation in V1Api.
 * @export
 * @interface V1ApiActivityCreateRequest
 */
export interface V1ApiActivityCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityDestroy operation in V1Api.
 * @export
 * @interface V1ApiActivityDestroyRequest
 */
export interface V1ApiActivityDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityDestroy
     */
    readonly activity: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityEdit operation in V1Api.
 * @export
 * @interface V1ApiActivityEditRequest
 */
export interface V1ApiActivityEditRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityEdit
     */
    readonly activity: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityGetComments operation in V1Api.
 * @export
 * @interface V1ApiActivityGetCommentsRequest
 */
export interface V1ApiActivityGetCommentsRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityGetComments
     */
    readonly activity: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityGetComments
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityGetComments
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityGetComments
     */
    readonly filterActivityId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityGetComments
     */
    readonly filterActivityCommentId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityGetComments
     */
    readonly filterContent?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityGetComments
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityGetComments
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiActivityGetComments
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityGetComments
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityGetComments
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityIndex operation in V1Api.
 * @export
 * @interface V1ApiActivityIndexRequest
 */
export interface V1ApiActivityIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityIndex
     */
    readonly filterOrderId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterUserId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterCustomerId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterChannelId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityIndex
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'}
     * @memberof V1ApiActivityIndex
     */
    readonly filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'

    /**
     * 
     * @type {'HOT' | 'WARM' | 'COLD' | 'DROP'}
     * @memberof V1ApiActivityIndex
     */
    readonly filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP'

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterFeedback?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityIndex
     */
    readonly filterTargetId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterFollowUpDatetimeBefore?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterFollowUpDatetimeAfter?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiActivityIndex
     */
    readonly filterHasPayment?: boolean

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterHasAnyBrands?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterCreatedBefore?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly filterCreatedAfter?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityReport operation in V1Api.
 * @export
 * @interface V1ApiActivityReportRequest
 */
export interface V1ApiActivityReportRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityReport
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof V1ApiActivityReport
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof V1ApiActivityReport
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityReport
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityReport
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiActivityReport
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiActivityReport
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiActivityReport
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityReport
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiActivityReport
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityReport
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityShow operation in V1Api.
 * @export
 * @interface V1ApiActivityShowRequest
 */
export interface V1ApiActivityShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityShow
     */
    readonly activity: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for activityStore operation in V1Api.
 * @export
 * @interface V1ApiActivityStoreRequest
 */
export interface V1ApiActivityStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject12}
     * @memberof V1ApiActivityStore
     */
    readonly data?: InlineObject12
}

/**
 * Request parameters for activityUpdate operation in V1Api.
 * @export
 * @interface V1ApiActivityUpdateRequest
 */
export interface V1ApiActivityUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiActivityUpdate
     */
    readonly activity: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiActivityUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiActivityUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject13}
     * @memberof V1ApiActivityUpdate
     */
    readonly data?: InlineObject13
}

/**
 * Request parameters for addressCreate operation in V1Api.
 * @export
 * @interface V1ApiAddressCreateRequest
 */
export interface V1ApiAddressCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiAddressCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiAddressCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressDestroy operation in V1Api.
 * @export
 * @interface V1ApiAddressDestroyRequest
 */
export interface V1ApiAddressDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressDestroy
     */
    readonly address: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiAddressDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiAddressDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressEdit operation in V1Api.
 * @export
 * @interface V1ApiAddressEditRequest
 */
export interface V1ApiAddressEditRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressEdit
     */
    readonly address: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiAddressEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiAddressEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressIndex operation in V1Api.
 * @export
 * @interface V1ApiAddressIndexRequest
 */
export interface V1ApiAddressIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiAddressIndex
     */
    readonly filterCustomerId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly filterAddressLine1?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly filterAddressLine2?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly filterCity?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly filterCountry?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly filterProvince?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly filterPhone?: string

    /**
     * 
     * @type {'ADDRESS' | 'DELIVERY' | 'BILLING'}
     * @memberof V1ApiAddressIndex
     */
    readonly filterType?: 'ADDRESS' | 'DELIVERY' | 'BILLING'

    /**
     * 
     * @type {number}
     * @memberof V1ApiAddressIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiAddressIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiAddressIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressShow operation in V1Api.
 * @export
 * @interface V1ApiAddressShowRequest
 */
export interface V1ApiAddressShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressShow
     */
    readonly address: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiAddressShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiAddressShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for addressStore operation in V1Api.
 * @export
 * @interface V1ApiAddressStoreRequest
 */
export interface V1ApiAddressStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiAddressStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiAddressStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject4}
     * @memberof V1ApiAddressStore
     */
    readonly data?: InlineObject4
}

/**
 * Request parameters for addressUpdate operation in V1Api.
 * @export
 * @interface V1ApiAddressUpdateRequest
 */
export interface V1ApiAddressUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiAddressUpdate
     */
    readonly address: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiAddressUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiAddressUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject5}
     * @memberof V1ApiAddressUpdate
     */
    readonly data?: InlineObject5
}

/**
 * Request parameters for authToken operation in V1Api.
 * @export
 * @interface V1ApiAuthTokenRequest
 */
export interface V1ApiAuthTokenRequest {
    /**
     * 
     * @type {InlineObject32}
     * @memberof V1ApiAuthToken
     */
    readonly data?: InlineObject32
}

/**
 * Request parameters for cartDemandDestroy operation in V1Api.
 * @export
 * @interface V1ApiCartDemandDestroyRequest
 */
export interface V1ApiCartDemandDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCartDemandDestroy
     */
    readonly cartDemand: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCartDemandDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCartDemandDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for cartDemandIndex operation in V1Api.
 * @export
 * @interface V1ApiCartDemandIndexRequest
 */
export interface V1ApiCartDemandIndexRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCartDemandIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCartDemandIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for cartDemandSync operation in V1Api.
 * @export
 * @interface V1ApiCartDemandSyncRequest
 */
export interface V1ApiCartDemandSyncRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCartDemandSync
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCartDemandSync
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject22}
     * @memberof V1ApiCartDemandSync
     */
    readonly data?: InlineObject22
}

/**
 * Request parameters for cartDemandUploadImage operation in V1Api.
 * @export
 * @interface V1ApiCartDemandUploadImageRequest
 */
export interface V1ApiCartDemandUploadImageRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCartDemandUploadImage
     */
    readonly cartDemand: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCartDemandUploadImage
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiCartDemandUploadImage
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiCartDemandUploadImage
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiCartDemandUploadImage
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCartDemandUploadImage
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCartDemandUploadImage
     */
    readonly contentType?: string

    /**
     * 
     * @type {ImageRequestBody1}
     * @memberof V1ApiCartDemandUploadImage
     */
    readonly imageRequestBody1?: ImageRequestBody1
}

/**
 * Request parameters for cartIndex operation in V1Api.
 * @export
 * @interface V1ApiCartIndexRequest
 */
export interface V1ApiCartIndexRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCartIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCartIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for cartSync operation in V1Api.
 * @export
 * @interface V1ApiCartSyncRequest
 */
export interface V1ApiCartSyncRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCartSync
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCartSync
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject21}
     * @memberof V1ApiCartSync
     */
    readonly data?: InlineObject21
}

/**
 * Request parameters for channelDefault operation in V1Api.
 * @export
 * @interface V1ApiChannelDefaultRequest
 */
export interface V1ApiChannelDefaultRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiChannelDefault
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiChannelDefault
     */
    readonly contentType?: string
}

/**
 * Request parameters for channelIndex operation in V1Api.
 * @export
 * @interface V1ApiChannelIndexRequest
 */
export interface V1ApiChannelIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiChannelIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiChannelIndex
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiChannelIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiChannelIndex
     */
    readonly filterSupervisorId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiChannelIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiChannelIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiChannelIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiChannelIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiChannelIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for channelShow operation in V1Api.
 * @export
 * @interface V1ApiChannelShowRequest
 */
export interface V1ApiChannelShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiChannelShow
     */
    readonly channel: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiChannelShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiChannelShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for companyAccountIndex operation in V1Api.
 * @export
 * @interface V1ApiCompanyAccountIndexRequest
 */
export interface V1ApiCompanyAccountIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCompanyAccountIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCompanyAccountIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiCompanyAccountIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiCompanyAccountIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiCompanyAccountIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCompanyAccountIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCompanyAccountIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for companyIndex operation in V1Api.
 * @export
 * @interface V1ApiCompanyIndexRequest
 */
export interface V1ApiCompanyIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCompanyIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCompanyIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiCompanyIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiCompanyIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiCompanyIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCompanyIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCompanyIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for companyShow operation in V1Api.
 * @export
 * @interface V1ApiCompanyShowRequest
 */
export interface V1ApiCompanyShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCompanyShow
     */
    readonly company: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCompanyShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCompanyShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerCreate operation in V1Api.
 * @export
 * @interface V1ApiCustomerCreateRequest
 */
export interface V1ApiCustomerCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerCreateWithAddress operation in V1Api.
 * @export
 * @interface V1ApiCustomerCreateWithAddressRequest
 */
export interface V1ApiCustomerCreateWithAddressRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerCreateWithAddress
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerCreateWithAddress
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerDelete operation in V1Api.
 * @export
 * @interface V1ApiCustomerDeleteRequest
 */
export interface V1ApiCustomerDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerDelete
     */
    readonly customer: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerDelete
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerDelete
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerDepositStore operation in V1Api.
 * @export
 * @interface V1ApiCustomerDepositStoreRequest
 */
export interface V1ApiCustomerDepositStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerDepositStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerDepositStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject16}
     * @memberof V1ApiCustomerDepositStore
     */
    readonly data?: InlineObject16
}

/**
 * Request parameters for customerEdit operation in V1Api.
 * @export
 * @interface V1ApiCustomerEditRequest
 */
export interface V1ApiCustomerEditRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerEdit
     */
    readonly customer: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerGetActivities operation in V1Api.
 * @export
 * @interface V1ApiCustomerGetActivitiesRequest
 */
export interface V1ApiCustomerGetActivitiesRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly customer: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterOrderId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterUserId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterCustomerId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterChannelId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterFollowUpMethod?: 'PHONE' | 'WHATSAPP' | 'MEETING' | 'OTHERS' | 'WALK_IN_CUSTOMER' | 'NEW_ORDER'

    /**
     * 
     * @type {'HOT' | 'WARM' | 'COLD' | 'DROP'}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterStatus?: 'HOT' | 'WARM' | 'COLD' | 'DROP'

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterFeedback?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterTargetId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterFollowUpDatetimeBefore?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterFollowUpDatetimeAfter?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterHasPayment?: boolean

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterHasAnyBrands?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterCreatedBefore?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly filterCreatedAfter?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerGetActivities
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerGetLeads operation in V1Api.
 * @export
 * @interface V1ApiCustomerGetLeadsRequest
 */
export interface V1ApiCustomerGetLeadsRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly customer: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerGetLeads
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerIndex operation in V1Api.
 * @export
 * @interface V1ApiCustomerIndexRequest
 */
export interface V1ApiCustomerIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerIndex
     */
    readonly filterFirstName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerIndex
     */
    readonly filterLastName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerIndex
     */
    readonly filterEmail?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerIndex
     */
    readonly filterPhone?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerIndex
     */
    readonly filterSearch?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiCustomerIndex
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiCustomerIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiCustomerIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerShow operation in V1Api.
 * @export
 * @interface V1ApiCustomerShowRequest
 */
export interface V1ApiCustomerShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerShow
     */
    readonly customer: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for customerStore operation in V1Api.
 * @export
 * @interface V1ApiCustomerStoreRequest
 */
export interface V1ApiCustomerStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject2}
     * @memberof V1ApiCustomerStore
     */
    readonly data?: InlineObject2
}

/**
 * Request parameters for customerStoreWithAddress operation in V1Api.
 * @export
 * @interface V1ApiCustomerStoreWithAddressRequest
 */
export interface V1ApiCustomerStoreWithAddressRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerStoreWithAddress
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerStoreWithAddress
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject1}
     * @memberof V1ApiCustomerStoreWithAddress
     */
    readonly data?: InlineObject1
}

/**
 * Request parameters for customerUpdate operation in V1Api.
 * @export
 * @interface V1ApiCustomerUpdateRequest
 */
export interface V1ApiCustomerUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiCustomerUpdate
     */
    readonly customer: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiCustomerUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiCustomerUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject3}
     * @memberof V1ApiCustomerUpdate
     */
    readonly data?: InlineObject3
}

/**
 * Request parameters for dealsleadSms operation in V1Api.
 * @export
 * @interface V1ApiDealsleadSmsRequest
 */
export interface V1ApiDealsleadSmsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiDealsleadSms
     */
    readonly id: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiDealsleadSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiDealsleadSms
     */
    readonly contentType?: string
}

/**
 * Request parameters for discountGetByCode operation in V1Api.
 * @export
 * @interface V1ApiDiscountGetByCodeRequest
 */
export interface V1ApiDiscountGetByCodeRequest {
    /**
     * The discount activation code
     * @type {string}
     * @memberof V1ApiDiscountGetByCode
     */
    readonly code: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiDiscountGetByCode
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiDiscountGetByCode
     */
    readonly contentType?: string
}

/**
 * Request parameters for discountIndex operation in V1Api.
 * @export
 * @interface V1ApiDiscountIndexRequest
 */
export interface V1ApiDiscountIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiDiscountIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiDiscountIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiDiscountIndex
     */
    readonly filterActivationCode?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiDiscountIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiDiscountIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiDiscountIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiDiscountIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiDiscountIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for interiorDesignIndex operation in V1Api.
 * @export
 * @interface V1ApiInteriorDesignIndexRequest
 */
export interface V1ApiInteriorDesignIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiInteriorDesignIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiInteriorDesignIndex
     */
    readonly filterReligionId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiInteriorDesignIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiInteriorDesignIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiInteriorDesignIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiInteriorDesignIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiInteriorDesignIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiInteriorDesignIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for interiorDesignShow operation in V1Api.
 * @export
 * @interface V1ApiInteriorDesignShowRequest
 */
export interface V1ApiInteriorDesignShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiInteriorDesignShow
     */
    readonly interiorDesign: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiInteriorDesignShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiInteriorDesignShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadAssign operation in V1Api.
 * @export
 * @interface V1ApiLeadAssignRequest
 */
export interface V1ApiLeadAssignRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadAssign
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadAssign
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadAssign
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject9}
     * @memberof V1ApiLeadAssign
     */
    readonly data?: InlineObject9
}

/**
 * Request parameters for leadCategories operation in V1Api.
 * @export
 * @interface V1ApiLeadCategoriesRequest
 */
export interface V1ApiLeadCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadCategories
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadCategories
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadCategories
     */
    readonly filterDescription?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadCategories
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadCategories
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiLeadCategories
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadCategories
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadCategories
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadCreate operation in V1Api.
 * @export
 * @interface V1ApiLeadCreateRequest
 */
export interface V1ApiLeadCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadDestroy operation in V1Api.
 * @export
 * @interface V1ApiLeadDestroyRequest
 */
export interface V1ApiLeadDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadDestroy
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadEdit operation in V1Api.
 * @export
 * @interface V1ApiLeadEditRequest
 */
export interface V1ApiLeadEditRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadEdit
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadIndex operation in V1Api.
 * @export
 * @interface V1ApiLeadIndexRequest
 */
export interface V1ApiLeadIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadIndex
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof V1ApiLeadIndex
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS' | 'DEAL'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof V1ApiLeadIndex
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadIndex
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadIndex
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadIndex
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadIndex
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadIndex
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadIndex
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadIndex
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiLeadIndex
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiLeadIndex
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiLeadIndex
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiLeadIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadShow operation in V1Api.
 * @export
 * @interface V1ApiLeadShowRequest
 */
export interface V1ApiLeadShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadShow
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadSms operation in V1Api.
 * @export
 * @interface V1ApiLeadSmsRequest
 */
export interface V1ApiLeadSmsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadSms
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadSms
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof V1ApiLeadSms
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof V1ApiLeadSms
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadSms
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadSms
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadSms
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadSms
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadSms
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadSms
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadSms
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiLeadSms
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiLeadSms
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiLeadSms
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadSms
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadSms
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiLeadSms
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadSms
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadStore operation in V1Api.
 * @export
 * @interface V1ApiLeadStoreRequest
 */
export interface V1ApiLeadStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject10}
     * @memberof V1ApiLeadStore
     */
    readonly data?: InlineObject10
}

/**
 * Request parameters for leadStoreSms operation in V1Api.
 * @export
 * @interface V1ApiLeadStoreSmsRequest
 */
export interface V1ApiLeadStoreSmsRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadStoreSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadStoreSms
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject7}
     * @memberof V1ApiLeadStoreSms
     */
    readonly data?: InlineObject7
}

/**
 * Request parameters for leadUnhandledIndex operation in V1Api.
 * @export
 * @interface V1ApiLeadUnhandledIndexRequest
 */
export interface V1ApiLeadUnhandledIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterUserId?: number

    /**
     * 
     * @type {'PROSPECT' | 'DROP' | 'LEADS'}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterType?: 'PROSPECT' | 'DROP' | 'LEADS'

    /**
     * 
     * @type {'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterStatus?: 'GREEN' | 'YELLOW' | 'RED' | 'EXPIRED' | 'SALES' | 'OTHER_SALES'

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterLabel?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterLeadCategoryId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterSubLeadCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterCustomerName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterCustomerSearch?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterChannelName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterSmsChannelName?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterIsNewCustomer?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterHasActivity?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly filterCustomerHasActivity?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadUnhandledIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for leadUpdate operation in V1Api.
 * @export
 * @interface V1ApiLeadUpdateRequest
 */
export interface V1ApiLeadUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiLeadUpdate
     */
    readonly lead: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject11}
     * @memberof V1ApiLeadUpdate
     */
    readonly data?: InlineObject11
}

/**
 * Request parameters for leadUpdateSms operation in V1Api.
 * @export
 * @interface V1ApiLeadUpdateSmsRequest
 */
export interface V1ApiLeadUpdateSmsRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiLeadUpdateSms
     */
    readonly id: number

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiLeadUpdateSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiLeadUpdateSms
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject8}
     * @memberof V1ApiLeadUpdateSms
     */
    readonly data?: InlineObject8
}

/**
 * Request parameters for orderApprove operation in V1Api.
 * @export
 * @interface V1ApiOrderApproveRequest
 */
export interface V1ApiOrderApproveRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderApprove
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderApprove
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderApprove
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject25}
     * @memberof V1ApiOrderApprove
     */
    readonly data?: InlineObject25
}

/**
 * Request parameters for orderCancel operation in V1Api.
 * @export
 * @interface V1ApiOrderCancelRequest
 */
export interface V1ApiOrderCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderCancel
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderCancel
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderCancel
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderClone operation in V1Api.
 * @export
 * @interface V1ApiOrderCloneRequest
 */
export interface V1ApiOrderCloneRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderClone
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderClone
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderClone
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject27}
     * @memberof V1ApiOrderClone
     */
    readonly data?: InlineObject27
}

/**
 * Request parameters for orderDetail operation in V1Api.
 * @export
 * @interface V1ApiOrderDetailRequest
 */
export interface V1ApiOrderDetailRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderDetail
     */
    readonly orderDetail: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderDetail
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiOrderDetail
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiOrderDetail
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiOrderDetail
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderDetail
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderDetail
     */
    readonly contentType?: string

    /**
     * 
     * @type {ImageRequestBody2}
     * @memberof V1ApiOrderDetail
     */
    readonly imageRequestBody2?: ImageRequestBody2
}

/**
 * Request parameters for orderDetailShow operation in V1Api.
 * @export
 * @interface V1ApiOrderDetailShowRequest
 */
export interface V1ApiOrderDetailShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderDetailShow
     */
    readonly orderDetail: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderDetailShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderDetailShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderIndex operation in V1Api.
 * @export
 * @interface V1ApiOrderIndexRequest
 */
export interface V1ApiOrderIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderIndex
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderIndex
     */
    readonly filterSearch?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderIndex
     */
    readonly filterInvoiceNumber?: string

    /**
     * 
     * @type {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'}
     * @memberof V1ApiOrderIndex
     */
    readonly filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'

    /**
     * 
     * @type {number}
     * @memberof V1ApiOrderIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiOrderIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiOrderIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderIndexWaitingApproval operation in V1Api.
 * @export
 * @interface V1ApiOrderIndexWaitingApprovalRequest
 */
export interface V1ApiOrderIndexWaitingApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly filterSearch?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly filterInvoiceNumber?: string

    /**
     * 
     * @type {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'

    /**
     * 
     * @type {number}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderIndexWaitingApproval
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderListApproval operation in V1Api.
 * @export
 * @interface V1ApiOrderListApprovalRequest
 */
export interface V1ApiOrderListApprovalRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderListApproval
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderListApproval
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderListApproval
     */
    readonly filterSearch?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderListApproval
     */
    readonly filterInvoiceNumber?: string

    /**
     * 
     * @type {'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'}
     * @memberof V1ApiOrderListApproval
     */
    readonly filterApprovalStatus?: 'NOT_REQUIRED' | 'WAITING_APPROVAL' | 'APPROVED' | 'REJECTED'

    /**
     * 
     * @type {number}
     * @memberof V1ApiOrderListApproval
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiOrderListApproval
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiOrderListApproval
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderListApproval
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderListApproval
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderPreview operation in V1Api.
 * @export
 * @interface V1ApiOrderPreviewRequest
 */
export interface V1ApiOrderPreviewRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderPreview
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderPreview
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject23}
     * @memberof V1ApiOrderPreview
     */
    readonly data?: InlineObject23
}

/**
 * Request parameters for orderPreviewUpdate operation in V1Api.
 * @export
 * @interface V1ApiOrderPreviewUpdateRequest
 */
export interface V1ApiOrderPreviewUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderPreviewUpdate
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderPreviewUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderPreviewUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject24}
     * @memberof V1ApiOrderPreviewUpdate
     */
    readonly data?: InlineObject24
}

/**
 * Request parameters for orderRequestApprove operation in V1Api.
 * @export
 * @interface V1ApiOrderRequestApproveRequest
 */
export interface V1ApiOrderRequestApproveRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderRequestApprove
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderRequestApprove
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderRequestApprove
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject26}
     * @memberof V1ApiOrderRequestApprove
     */
    readonly data?: InlineObject26
}

/**
 * Request parameters for orderShow operation in V1Api.
 * @export
 * @interface V1ApiOrderShowRequest
 */
export interface V1ApiOrderShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderShow
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for orderStore operation in V1Api.
 * @export
 * @interface V1ApiOrderStoreRequest
 */
export interface V1ApiOrderStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject28}
     * @memberof V1ApiOrderStore
     */
    readonly data?: InlineObject28
}

/**
 * Request parameters for orderUpdate operation in V1Api.
 * @export
 * @interface V1ApiOrderUpdateRequest
 */
export interface V1ApiOrderUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiOrderUpdate
     */
    readonly order: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiOrderUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiOrderUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject29}
     * @memberof V1ApiOrderUpdate
     */
    readonly data?: InlineObject29
}

/**
 * Request parameters for paymentCategoryIndex operation in V1Api.
 * @export
 * @interface V1ApiPaymentCategoryIndexRequest
 */
export interface V1ApiPaymentCategoryIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentCategoryIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentCategoryIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiPaymentCategoryIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiPaymentCategoryIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiPaymentCategoryIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPaymentCategoryIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPaymentCategoryIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentCreate operation in V1Api.
 * @export
 * @interface V1ApiPaymentCreateRequest
 */
export interface V1ApiPaymentCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPaymentCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPaymentCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentEdit operation in V1Api.
 * @export
 * @interface V1ApiPaymentEditRequest
 */
export interface V1ApiPaymentEditRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentEdit
     */
    readonly payment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPaymentEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPaymentEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentIndex operation in V1Api.
 * @export
 * @interface V1ApiPaymentIndexRequest
 */
export interface V1ApiPaymentIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiPaymentIndex
     */
    readonly filterAmount?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentIndex
     */
    readonly filterReference?: string

    /**
     * 
     * @type {'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'}
     * @memberof V1ApiPaymentIndex
     */
    readonly filterStatus?: 'NONE' | 'PARTIAL' | 'SETTLEMENT' | 'OVERPAYMENT' | 'REFUNDED' | 'DOWN_PAYMENT'

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentIndex
     */
    readonly filterPaymentTypeId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentIndex
     */
    readonly filterAddedById?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentIndex
     */
    readonly filterApprovedById?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentIndex
     */
    readonly filterOrderId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiPaymentIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiPaymentIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiPaymentIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPaymentIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPaymentIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentProofUpload operation in V1Api.
 * @export
 * @interface V1ApiPaymentProofUploadRequest
 */
export interface V1ApiPaymentProofUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentProofUpload
     */
    readonly payment: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentProofUpload
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentProofUpload
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiPaymentProofUpload
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiPaymentProofUpload
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiPaymentProofUpload
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPaymentProofUpload
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPaymentProofUpload
     */
    readonly contentType?: string

    /**
     * 
     * @type {ImageRequestBody3}
     * @memberof V1ApiPaymentProofUpload
     */
    readonly imageRequestBody3?: ImageRequestBody3
}

/**
 * Request parameters for paymentShow operation in V1Api.
 * @export
 * @interface V1ApiPaymentShowRequest
 */
export interface V1ApiPaymentShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentShow
     */
    readonly payment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPaymentShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPaymentShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentStore operation in V1Api.
 * @export
 * @interface V1ApiPaymentStoreRequest
 */
export interface V1ApiPaymentStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPaymentStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPaymentStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject30}
     * @memberof V1ApiPaymentStore
     */
    readonly data?: InlineObject30
}

/**
 * Request parameters for paymentTypeIndex operation in V1Api.
 * @export
 * @interface V1ApiPaymentTypeIndexRequest
 */
export interface V1ApiPaymentTypeIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentTypeIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentTypeIndex
     */
    readonly filterPaymentCategoryId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentTypeIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiPaymentTypeIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiPaymentTypeIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiPaymentTypeIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPaymentTypeIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPaymentTypeIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for paymentUpdate operation in V1Api.
 * @export
 * @interface V1ApiPaymentUpdateRequest
 */
export interface V1ApiPaymentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPaymentUpdate
     */
    readonly payment: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPaymentUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPaymentUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject31}
     * @memberof V1ApiPaymentUpdate
     */
    readonly data?: InlineObject31
}

/**
 * Request parameters for productBrand operation in V1Api.
 * @export
 * @interface V1ApiProductBrandRequest
 */
export interface V1ApiProductBrandRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductBrand
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductBrand
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductBrand
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductBrand
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductBrand
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductBrand
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductBrand
     */
    readonly contentType?: string
}

/**
 * Request parameters for productCategoryCodes operation in V1Api.
 * @export
 * @interface V1ApiProductCategoryCodesRequest
 */
export interface V1ApiProductCategoryCodesRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductCategoryCodes
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductCategoryCodes
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductCategoryCodes
     */
    readonly filterProductModelId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductCategoryCodes
     */
    readonly filterProductVersionId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductCategoryCodes
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductCategoryCodes
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductCategoryCodes
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductCategoryCodes
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductCategoryCodes
     */
    readonly contentType?: string
}

/**
 * Request parameters for productCategoryIndex operation in V1Api.
 * @export
 * @interface V1ApiProductCategoryIndexRequest
 */
export interface V1ApiProductCategoryIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly filterDescription?: string

    /**
     * 
     * @type {'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly filterType?: 'COLLECTION' | 'SUB_COLLECTION' | 'BRAND_TYPE' | 'BRAND' | 'CATEGORY'

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly filterParentId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductCategoryIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for productCategoryShow operation in V1Api.
 * @export
 * @interface V1ApiProductCategoryShowRequest
 */
export interface V1ApiProductCategoryShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductCategoryShow
     */
    readonly productCategory: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductCategoryShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductCategoryShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for productIndex operation in V1Api.
 * @export
 * @interface V1ApiProductIndexRequest
 */
export interface V1ApiProductIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly filterProductModelId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly filterProductVersionId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly filterProductCategoryCodeId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly filterTags?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for productModel operation in V1Api.
 * @export
 * @interface V1ApiProductModelRequest
 */
export interface V1ApiProductModelRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductModel
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductModel
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductModel
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductModel
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductModel
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductModel
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductModel
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductModel
     */
    readonly contentType?: string
}

/**
 * Request parameters for productModelById operation in V1Api.
 * @export
 * @interface V1ApiProductModelByIdRequest
 */
export interface V1ApiProductModelByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductModelById
     */
    readonly model: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductModelById
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductModelById
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductModelById
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductModelById
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductModelById
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductModelById
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductModelById
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductModelById
     */
    readonly contentType?: string
}

/**
 * Request parameters for productShow operation in V1Api.
 * @export
 * @interface V1ApiProductShowRequest
 */
export interface V1ApiProductShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductShow
     */
    readonly product: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for productTagIndex operation in V1Api.
 * @export
 * @interface V1ApiProductTagIndexRequest
 */
export interface V1ApiProductTagIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductTagIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductTagIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductTagIndex
     */
    readonly filterSlug?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductTagIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductTagIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductTagIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductTagIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductTagIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for productTagShow operation in V1Api.
 * @export
 * @interface V1ApiProductTagShowRequest
 */
export interface V1ApiProductTagShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductTagShow
     */
    readonly productTag: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductTagShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductTagShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for productUnitColours operation in V1Api.
 * @export
 * @interface V1ApiProductUnitColoursRequest
 */
export interface V1ApiProductUnitColoursRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitColours
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitColours
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitColours
     */
    readonly filterDescription?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitColours
     */
    readonly filterProductId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitColours
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitColours
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductUnitColours
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductUnitColours
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductUnitColours
     */
    readonly contentType?: string
}

/**
 * Request parameters for productUnitCoverings operation in V1Api.
 * @export
 * @interface V1ApiProductUnitCoveringsRequest
 */
export interface V1ApiProductUnitCoveringsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitCoverings
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitCoverings
     */
    readonly filterProductId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitCoverings
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitCoverings
     */
    readonly filterType?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitCoverings
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitCoverings
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductUnitCoverings
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductUnitCoverings
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductUnitCoverings
     */
    readonly contentType?: string
}

/**
 * Request parameters for productUnitIndex operation in V1Api.
 * @export
 * @interface V1ApiProductUnitIndexRequest
 */
export interface V1ApiProductUnitIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitIndex
     */
    readonly filterProductId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitIndex
     */
    readonly filterColourId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitIndex
     */
    readonly filterCoveringId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductUnitIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductUnitIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductUnitIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for productUnitShow operation in V1Api.
 * @export
 * @interface V1ApiProductUnitShowRequest
 */
export interface V1ApiProductUnitShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitShow
     */
    readonly productUnit: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductUnitShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductUnitShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for productUnitUpload operation in V1Api.
 * @export
 * @interface V1ApiProductUnitUploadRequest
 */
export interface V1ApiProductUnitUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitUpload
     */
    readonly productUnit: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitUpload
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitUpload
     */
    readonly filterProductId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitUpload
     */
    readonly filterColourId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitUpload
     */
    readonly filterCoveringId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductUnitUpload
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitUpload
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductUnitUpload
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductUnitUpload
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductUnitUpload
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductUnitUpload
     */
    readonly contentType?: string

    /**
     * 
     * @type {ImageRequestBody}
     * @memberof V1ApiProductUnitUpload
     */
    readonly imageRequestBody?: ImageRequestBody
}

/**
 * Request parameters for productVersion operation in V1Api.
 * @export
 * @interface V1ApiProductVersionRequest
 */
export interface V1ApiProductVersionRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiProductVersion
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductVersion
     */
    readonly filterProductBrandId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiProductVersion
     */
    readonly filterProductModelId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductVersion
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiProductVersion
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiProductVersion
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiProductVersion
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiProductVersion
     */
    readonly contentType?: string
}

/**
 * Request parameters for promoCategoryIndex operation in V1Api.
 * @export
 * @interface V1ApiPromoCategoryIndexRequest
 */
export interface V1ApiPromoCategoryIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPromoCategoryIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPromoCategoryIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiPromoCategoryIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiPromoCategoryIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiPromoCategoryIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPromoCategoryIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPromoCategoryIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for promoCategoryShow operation in V1Api.
 * @export
 * @interface V1ApiPromoCategoryShowRequest
 */
export interface V1ApiPromoCategoryShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPromoCategoryShow
     */
    readonly promoCategory: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPromoCategoryShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPromoCategoryShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for promoIndex operation in V1Api.
 * @export
 * @interface V1ApiPromoIndexRequest
 */
export interface V1ApiPromoIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPromoIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiPromoIndex
     */
    readonly filterPromoCategoryId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiPromoIndex
     */
    readonly filterStartAfter?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiPromoIndex
     */
    readonly filterEndBefore?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiPromoIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiPromoIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiPromoIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPromoIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPromoIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for promoShow operation in V1Api.
 * @export
 * @interface V1ApiPromoShowRequest
 */
export interface V1ApiPromoShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPromoShow
     */
    readonly promo: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPromoShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPromoShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for pushNotificationClear operation in V1Api.
 * @export
 * @interface V1ApiPushNotificationClearRequest
 */
export interface V1ApiPushNotificationClearRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPushNotificationClear
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPushNotificationClear
     */
    readonly contentType?: string
}

/**
 * Request parameters for pushNotificationIndex operation in V1Api.
 * @export
 * @interface V1ApiPushNotificationIndexRequest
 */
export interface V1ApiPushNotificationIndexRequest {
    /**
     * 
     * @type {'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'}
     * @memberof V1ApiPushNotificationIndex
     */
    readonly filterType?: 'ActivityReminder' | 'NewLeadAssigned' | 'DiscountApproval'

    /**
     * 
     * @type {number}
     * @memberof V1ApiPushNotificationIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiPushNotificationIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiPushNotificationIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPushNotificationIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPushNotificationIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for pushNotificationSubscribe operation in V1Api.
 * @export
 * @interface V1ApiPushNotificationSubscribeRequest
 */
export interface V1ApiPushNotificationSubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPushNotificationSubscribe
     */
    readonly code: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPushNotificationSubscribe
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPushNotificationSubscribe
     */
    readonly contentType?: string
}

/**
 * Request parameters for pushNotificationTest operation in V1Api.
 * @export
 * @interface V1ApiPushNotificationTestRequest
 */
export interface V1ApiPushNotificationTestRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPushNotificationTest
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPushNotificationTest
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject6}
     * @memberof V1ApiPushNotificationTest
     */
    readonly data?: InlineObject6
}

/**
 * Request parameters for pushNotificationUnsubscribe operation in V1Api.
 * @export
 * @interface V1ApiPushNotificationUnsubscribeRequest
 */
export interface V1ApiPushNotificationUnsubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiPushNotificationUnsubscribe
     */
    readonly code: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiPushNotificationUnsubscribe
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiPushNotificationUnsubscribe
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageCreate operation in V1Api.
 * @export
 * @interface V1ApiQaMessageCreateRequest
 */
export interface V1ApiQaMessageCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaMessageCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaMessageCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageDestroy operation in V1Api.
 * @export
 * @interface V1ApiQaMessageDestroyRequest
 */
export interface V1ApiQaMessageDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaMessageDestroy
     */
    readonly qaMessage: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaMessageDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaMessageDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageEdit operation in V1Api.
 * @export
 * @interface V1ApiQaMessageEditRequest
 */
export interface V1ApiQaMessageEditRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaMessageEdit
     */
    readonly qaMessage: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaMessageEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaMessageEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageIndex operation in V1Api.
 * @export
 * @interface V1ApiQaMessageIndexRequest
 */
export interface V1ApiQaMessageIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaMessageIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiQaMessageIndex
     */
    readonly filterContent?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiQaMessageIndex
     */
    readonly filterTopicId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiQaMessageIndex
     */
    readonly filterSenderId?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiQaMessageIndex
     */
    readonly filterIsUnread?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiQaMessageIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiQaMessageIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiQaMessageIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaMessageIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaMessageIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageShow operation in V1Api.
 * @export
 * @interface V1ApiQaMessageShowRequest
 */
export interface V1ApiQaMessageShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaMessageShow
     */
    readonly qaMessage: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaMessageShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaMessageShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaMessageStore operation in V1Api.
 * @export
 * @interface V1ApiQaMessageStoreRequest
 */
export interface V1ApiQaMessageStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaMessageStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaMessageStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject19}
     * @memberof V1ApiQaMessageStore
     */
    readonly data?: InlineObject19
}

/**
 * Request parameters for qaMessageUpdate operation in V1Api.
 * @export
 * @interface V1ApiQaMessageUpdateRequest
 */
export interface V1ApiQaMessageUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaMessageUpdate
     */
    readonly qaMessage: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaMessageUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaMessageUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject20}
     * @memberof V1ApiQaMessageUpdate
     */
    readonly data?: InlineObject20
}

/**
 * Request parameters for qaTopicCreate operation in V1Api.
 * @export
 * @interface V1ApiQaTopicCreateRequest
 */
export interface V1ApiQaTopicCreateRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaTopicCreate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaTopicCreate
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicDestroy operation in V1Api.
 * @export
 * @interface V1ApiQaTopicDestroyRequest
 */
export interface V1ApiQaTopicDestroyRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicDestroy
     */
    readonly qaTopic: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaTopicDestroy
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaTopicDestroy
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicEdit operation in V1Api.
 * @export
 * @interface V1ApiQaTopicEditRequest
 */
export interface V1ApiQaTopicEditRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicEdit
     */
    readonly qaTopic: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaTopicEdit
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaTopicEdit
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicGetQaMessages operation in V1Api.
 * @export
 * @interface V1ApiQaTopicGetQaMessagesRequest
 */
export interface V1ApiQaTopicGetQaMessagesRequest {
    /**
     * 
     * @type {number}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly topic: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly filterContent?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly filterTopicId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly filterSenderId?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly filterIsUnread?: boolean

    /**
     * 
     * @type {number}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaTopicGetQaMessages
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicIndex operation in V1Api.
 * @export
 * @interface V1ApiQaTopicIndexRequest
 */
export interface V1ApiQaTopicIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicIndex
     */
    readonly filterSubject?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiQaTopicIndex
     */
    readonly filterCreatorId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiQaTopicIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiQaTopicIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiQaTopicIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaTopicIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaTopicIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicShow operation in V1Api.
 * @export
 * @interface V1ApiQaTopicShowRequest
 */
export interface V1ApiQaTopicShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicShow
     */
    readonly qaTopic: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaTopicShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaTopicShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for qaTopicStore operation in V1Api.
 * @export
 * @interface V1ApiQaTopicStoreRequest
 */
export interface V1ApiQaTopicStoreRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaTopicStore
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaTopicStore
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject17}
     * @memberof V1ApiQaTopicStore
     */
    readonly data?: InlineObject17
}

/**
 * Request parameters for qaTopicUpdate operation in V1Api.
 * @export
 * @interface V1ApiQaTopicUpdateRequest
 */
export interface V1ApiQaTopicUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiQaTopicUpdate
     */
    readonly qaTopic: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiQaTopicUpdate
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiQaTopicUpdate
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject18}
     * @memberof V1ApiQaTopicUpdate
     */
    readonly data?: InlineObject18
}

/**
 * Request parameters for register operation in V1Api.
 * @export
 * @interface V1ApiRegisterRequest
 */
export interface V1ApiRegisterRequest {
    /**
     * 
     * @type {InlineObject33}
     * @memberof V1ApiRegister
     */
    readonly data?: InlineObject33
}

/**
 * Request parameters for reportIndex operation in V1Api.
 * @export
 * @interface V1ApiReportIndexRequest
 */
export interface V1ApiReportIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiReportIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiReportIndex
     */
    readonly filterPeriodBefore?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiReportIndex
     */
    readonly filterPeriodAfter?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiReportIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiReportIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiReportIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiReportIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiReportIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for reportShow operation in V1Api.
 * @export
 * @interface V1ApiReportShowRequest
 */
export interface V1ApiReportShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiReportShow
     */
    readonly report: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiReportShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiReportShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for showleadSms operation in V1Api.
 * @export
 * @interface V1ApiShowleadSmsRequest
 */
export interface V1ApiShowleadSmsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiShowleadSms
     */
    readonly id: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiShowleadSms
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiShowleadSms
     */
    readonly contentType?: string
}

/**
 * Request parameters for smsChannelIndex operation in V1Api.
 * @export
 * @interface V1ApiSmsChannelIndexRequest
 */
export interface V1ApiSmsChannelIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiSmsChannelIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiSmsChannelIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiSmsChannelIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiSmsChannelIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiSmsChannelIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiSmsChannelIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiSmsChannelIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for smsChannelShow operation in V1Api.
 * @export
 * @interface V1ApiSmsChannelShowRequest
 */
export interface V1ApiSmsChannelShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiSmsChannelShow
     */
    readonly smsChannel: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiSmsChannelShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiSmsChannelShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for smsProductBrand operation in V1Api.
 * @export
 * @interface V1ApiSmsProductBrandRequest
 */
export interface V1ApiSmsProductBrandRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiSmsProductBrand
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiSmsProductBrand
     */
    readonly filterName?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiSmsProductBrand
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiSmsProductBrand
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiSmsProductBrand
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiSmsProductBrand
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiSmsProductBrand
     */
    readonly contentType?: string
}

/**
 * Request parameters for stockIndex operation in V1Api.
 * @export
 * @interface V1ApiStockIndexRequest
 */
export interface V1ApiStockIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiStockIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiStockIndex
     */
    readonly filterChannelId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiStockIndex
     */
    readonly filterProductUnitId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiStockIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiStockIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiStockIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiStockIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiStockIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for stockIndexExtended operation in V1Api.
 * @export
 * @interface V1ApiStockIndexExtendedRequest
 */
export interface V1ApiStockIndexExtendedRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiStockIndexExtended
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiStockIndexExtended
     */
    readonly filterChannelId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiStockIndexExtended
     */
    readonly filterProductUnitId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiStockIndexExtended
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiStockIndexExtended
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiStockIndexExtended
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiStockIndexExtended
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiStockIndexExtended
     */
    readonly contentType?: string
}

/**
 * Request parameters for stockShow operation in V1Api.
 * @export
 * @interface V1ApiStockShowRequest
 */
export interface V1ApiStockShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiStockShow
     */
    readonly stock: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiStockShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiStockShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for subLeadCategories operation in V1Api.
 * @export
 * @interface V1ApiSubLeadCategoriesRequest
 */
export interface V1ApiSubLeadCategoriesRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiSubLeadCategories
     */
    readonly leadCategory: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiSubLeadCategories
     */
    readonly filterId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiSubLeadCategories
     */
    readonly filterName?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiSubLeadCategories
     */
    readonly filterDescription?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiSubLeadCategories
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiSubLeadCategories
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiSubLeadCategories
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiSubLeadCategories
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiSubLeadCategories
     */
    readonly contentType?: string
}

/**
 * Request parameters for targetIndex operation in V1Api.
 * @export
 * @interface V1ApiTargetIndexRequest
 */
export interface V1ApiTargetIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiTargetIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiTargetIndex
     */
    readonly filterReportId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiTargetIndex
     */
    readonly filterIsDashboard?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiTargetIndex
     */
    readonly filterStartAfter?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiTargetIndex
     */
    readonly filterEndBefore?: string

    /**
     * 
     * @type {'COMPANY' | 'CHANNEL' | 'USER'}
     * @memberof V1ApiTargetIndex
     */
    readonly filterReportableType?: 'COMPANY' | 'CHANNEL' | 'USER'

    /**
     * 
     * @type {string}
     * @memberof V1ApiTargetIndex
     */
    readonly filterReportableIds?: string

    /**
     * 
     * @type {'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'}
     * @memberof V1ApiTargetIndex
     */
    readonly filterType?: 'DEALS_INVOICE_PRICE' | 'DEALS_PAYMENT_PRICE' | 'DEALS_BRAND_PRICE' | 'DEALS_MODEL_PRICE' | 'DEALS_ORDER_COUNT' | 'DEALS_BRAND_COUNT' | 'DEALS_MODEL_COUNT' | 'ACTIVITY_COUNT' | 'ACTIVITY_COUNT_CLOSED' | 'ORDER_SETTLEMENT_COUNT'

    /**
     * 
     * @type {number}
     * @memberof V1ApiTargetIndex
     */
    readonly filterSupervisorTypeLevel?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiTargetIndex
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiTargetIndex
     */
    readonly filterDescendantOf?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiTargetIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiTargetIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiTargetIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiTargetIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiTargetIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for userChangePassword operation in V1Api.
 * @export
 * @interface V1ApiUserChangePasswordRequest
 */
export interface V1ApiUserChangePasswordRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiUserChangePassword
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiUserChangePassword
     */
    readonly contentType?: string

    /**
     * 
     * @type {InlineObject}
     * @memberof V1ApiUserChangePassword
     */
    readonly data?: InlineObject
}

/**
 * Request parameters for userIndex operation in V1Api.
 * @export
 * @interface V1ApiUserIndexRequest
 */
export interface V1ApiUserIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiUserIndex
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserIndex
     */
    readonly filterChannelId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiUserIndex
     */
    readonly filterSupervisorId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiUserIndex
     */
    readonly filterSupervisorTypeId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserIndex
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiUserIndex
     */
    readonly filterName?: string

    /**
     * 
     * @type {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'}
     * @memberof V1ApiUserIndex
     */
    readonly filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserIndex
     */
    readonly filterDescendantOf?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserIndex
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserIndex
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiUserIndex
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiUserIndex
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiUserIndex
     */
    readonly contentType?: string
}

/**
 * Request parameters for userListForReport operation in V1Api.
 * @export
 * @interface V1ApiUserListForReportRequest
 */
export interface V1ApiUserListForReportRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiUserListForReport
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserListForReport
     */
    readonly filterChannelId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiUserListForReport
     */
    readonly filterSupervisorId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiUserListForReport
     */
    readonly filterSupervisorTypeId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserListForReport
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiUserListForReport
     */
    readonly filterName?: string

    /**
     * 
     * @type {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'}
     * @memberof V1ApiUserListForReport
     */
    readonly filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserListForReport
     */
    readonly filterDescendantOf?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserListForReport
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserListForReport
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiUserListForReport
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiUserListForReport
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiUserListForReport
     */
    readonly contentType?: string
}

/**
 * Request parameters for userMe operation in V1Api.
 * @export
 * @interface V1ApiUserMeRequest
 */
export interface V1ApiUserMeRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiUserMe
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiUserMe
     */
    readonly contentType?: string
}

/**
 * Request parameters for userSetDefaultChannel operation in V1Api.
 * @export
 * @interface V1ApiUserSetDefaultChannelRequest
 */
export interface V1ApiUserSetDefaultChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiUserSetDefaultChannel
     */
    readonly channel: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiUserSetDefaultChannel
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiUserSetDefaultChannel
     */
    readonly contentType?: string
}

/**
 * Request parameters for userShow operation in V1Api.
 * @export
 * @interface V1ApiUserShowRequest
 */
export interface V1ApiUserShowRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiUserShow
     */
    readonly user: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiUserShow
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiUserShow
     */
    readonly contentType?: string
}

/**
 * Request parameters for userSupervised operation in V1Api.
 * @export
 * @interface V1ApiUserSupervisedRequest
 */
export interface V1ApiUserSupervisedRequest {
    /**
     * 
     * @type {string}
     * @memberof V1ApiUserSupervised
     */
    readonly filterId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserSupervised
     */
    readonly filterChannelId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiUserSupervised
     */
    readonly filterSupervisorId?: string

    /**
     * 
     * @type {string}
     * @memberof V1ApiUserSupervised
     */
    readonly filterSupervisorTypeId?: string

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserSupervised
     */
    readonly filterCompanyId?: number

    /**
     * 
     * @type {string}
     * @memberof V1ApiUserSupervised
     */
    readonly filterName?: string

    /**
     * 
     * @type {'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'}
     * @memberof V1ApiUserSupervised
     */
    readonly filterType?: 'DEFAULT' | 'SALES' | 'SUPERVISOR' | 'DIRECTOR' | 'DigitalMarketing' | 'SALES_SMS' | 'SUPERVISOR_SMS'

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserSupervised
     */
    readonly filterDescendantOf?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserSupervised
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof V1ApiUserSupervised
     */
    readonly perPage?: number

    /**
     * Takes in field name to sort. Append \&quot;-\&quot; (e.g., -id to sort id in descending order)
     * @type {string}
     * @memberof V1ApiUserSupervised
     */
    readonly sort?: string

    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiUserSupervised
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiUserSupervised
     */
    readonly contentType?: string
}

/**
 * Request parameters for userSupervisor operation in V1Api.
 * @export
 * @interface V1ApiUserSupervisorRequest
 */
export interface V1ApiUserSupervisorRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiUserSupervisor
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiUserSupervisor
     */
    readonly contentType?: string
}

/**
 * Request parameters for userSupervisorTypes operation in V1Api.
 * @export
 * @interface V1ApiUserSupervisorTypesRequest
 */
export interface V1ApiUserSupervisorTypesRequest {
    /**
     * API call should request for json response
     * @type {string}
     * @memberof V1ApiUserSupervisorTypes
     */
    readonly accept?: string

    /**
     * API call should be json data
     * @type {string}
     * @memberof V1ApiUserSupervisorTypes
     */
    readonly contentType?: string
}

/**
 * V1Api - object-oriented interface
 * @export
 * @class V1Api
 * @extends {BaseAPI}
 */
export class V1Api extends BaseAPI {
    /**
     * Show the validation rules for creating activityComment
     * @summary Get create ActivityComment rule
     * @param {V1ApiActivityCommentCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityCommentCreate(requestParameters: V1ApiActivityCommentCreateRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).activityCommentCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a activityComment by its id
     * @summary Delete ActivityComment
     * @param {V1ApiActivityCommentDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityCommentDestroy(requestParameters: V1ApiActivityCommentDestroyRequest, options?: any) {
        return V1ApiFp(this.configuration).activityCommentDestroy(requestParameters.activityComment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing activityComment
     * @summary Show edit activityComment rules
     * @param {V1ApiActivityCommentEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityCommentEdit(requestParameters: V1ApiActivityCommentEditRequest, options?: any) {
        return V1ApiFp(this.configuration).activityCommentEdit(requestParameters.activityComment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all activity comments posted by this user
     * @summary Show user\'s activity comment.
     * @param {V1ApiActivityCommentIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityCommentIndex(requestParameters: V1ApiActivityCommentIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).activityCommentIndex(requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterActivityId, requestParameters.filterActivityCommentId, requestParameters.filterContent, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns activityComment by id
     * @summary Get activityComment
     * @param {V1ApiActivityCommentShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityCommentShow(requestParameters: V1ApiActivityCommentShowRequest, options?: any) {
        return V1ApiFp(this.configuration).activityCommentShow(requestParameters.activityComment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new activityComment
     * @summary Create new ActivityComment
     * @param {V1ApiActivityCommentStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityCommentStore(requestParameters: V1ApiActivityCommentStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).activityCommentStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given activityComment
     * @summary Update a activityComment
     * @param {V1ApiActivityCommentUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityCommentUpdate(requestParameters: V1ApiActivityCommentUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).activityCommentUpdate(requestParameters.activityComment, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating activity
     * @summary Show create product activity
     * @param {V1ApiActivityCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityCreate(requestParameters: V1ApiActivityCreateRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).activityCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a activity by its id
     * @summary Delete Activity
     * @param {V1ApiActivityDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityDestroy(requestParameters: V1ApiActivityDestroyRequest, options?: any) {
        return V1ApiFp(this.configuration).activityDestroy(requestParameters.activity, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing activity
     * @summary Show edit activity rules
     * @param {V1ApiActivityEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityEdit(requestParameters: V1ApiActivityEditRequest, options?: any) {
        return V1ApiFp(this.configuration).activityEdit(requestParameters.activity, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all activity comments for a given activity.
     * @summary Show all activity comments of an activity.
     * @param {V1ApiActivityGetCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityGetComments(requestParameters: V1ApiActivityGetCommentsRequest, options?: any) {
        return V1ApiFp(this.configuration).activityGetComments(requestParameters.activity, requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterActivityId, requestParameters.filterActivityCommentId, requestParameters.filterContent, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sales will get all activities directly created by him. Supervisor will get all activities created by its supervised sales. Director will get all activities scoped to its active channel setting.
     * @summary Show all activity posted by user
     * @param {V1ApiActivityIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityIndex(requestParameters: V1ApiActivityIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).activityIndex(requestParameters.filterId, requestParameters.filterOrderId, requestParameters.filterUserId, requestParameters.filterCustomerId, requestParameters.filterChannelId, requestParameters.filterCompanyId, requestParameters.filterFollowUpMethod, requestParameters.filterStatus, requestParameters.filterFeedback, requestParameters.filterTargetId, requestParameters.filterFollowUpDatetimeBefore, requestParameters.filterFollowUpDatetimeAfter, requestParameters.filterHasPayment, requestParameters.filterHasAnyBrands, requestParameters.filterCreatedBefore, requestParameters.filterCreatedAfter, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
     * @summary Show all leads by user leads where related with activity_brand_values value where active(order_id = null)
     * @param {V1ApiActivityReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityReport(requestParameters: V1ApiActivityReportRequest, options?: any) {
        return V1ApiFp(this.configuration).activityReport(requestParameters.userId, requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns activity by id
     * @summary Get activity
     * @param {V1ApiActivityShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityShow(requestParameters: V1ApiActivityShowRequest, options?: any) {
        return V1ApiFp(this.configuration).activityShow(requestParameters.activity, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new activity
     * @summary Create new Activity
     * @param {V1ApiActivityStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityStore(requestParameters: V1ApiActivityStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).activityStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given activity
     * @summary Update a activity
     * @param {V1ApiActivityUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public activityUpdate(requestParameters: V1ApiActivityUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).activityUpdate(requestParameters.activity, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating address
     * @summary Show create product address
     * @param {V1ApiAddressCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public addressCreate(requestParameters: V1ApiAddressCreateRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).addressCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a address by its id
     * @summary Delete Address
     * @param {V1ApiAddressDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public addressDestroy(requestParameters: V1ApiAddressDestroyRequest, options?: any) {
        return V1ApiFp(this.configuration).addressDestroy(requestParameters.address, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing address
     * @summary Show edit address rules
     * @param {V1ApiAddressEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public addressEdit(requestParameters: V1ApiAddressEditRequest, options?: any) {
        return V1ApiFp(this.configuration).addressEdit(requestParameters.address, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all address
     * @summary Show all address.
     * @param {V1ApiAddressIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public addressIndex(requestParameters: V1ApiAddressIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).addressIndex(requestParameters.filterId, requestParameters.filterCustomerId, requestParameters.filterAddressLine1, requestParameters.filterAddressLine2, requestParameters.filterCity, requestParameters.filterCountry, requestParameters.filterProvince, requestParameters.filterPhone, requestParameters.filterType, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns address by id
     * @summary Get address
     * @param {V1ApiAddressShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public addressShow(requestParameters: V1ApiAddressShowRequest, options?: any) {
        return V1ApiFp(this.configuration).addressShow(requestParameters.address, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating address
     * @summary Create new Address
     * @param {V1ApiAddressStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public addressStore(requestParameters: V1ApiAddressStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).addressStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given address
     * @summary Update a address
     * @param {V1ApiAddressUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public addressUpdate(requestParameters: V1ApiAddressUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).addressUpdate(requestParameters.address, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user token
     * @summary Get Token
     * @param {V1ApiAuthTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public authToken(requestParameters: V1ApiAuthTokenRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).authToken(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a cart demand by its id
     * @summary Delete cart demand
     * @param {V1ApiCartDemandDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public cartDemandDestroy(requestParameters: V1ApiCartDemandDestroyRequest, options?: any) {
        return V1ApiFp(this.configuration).cartDemandDestroy(requestParameters.cartDemand, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show cart demand of logged in user
     * @summary Show user cart demand.
     * @param {V1ApiCartDemandIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public cartDemandIndex(requestParameters: V1ApiCartDemandIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).cartDemandIndex(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync user cart demand content
     * @summary Sync cart demand
     * @param {V1ApiCartDemandSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public cartDemandSync(requestParameters: V1ApiCartDemandSyncRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).cartDemandSync(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload order detail product unit image
     * @summary Upload order detail product unit image
     * @param {V1ApiCartDemandUploadImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public cartDemandUploadImage(requestParameters: V1ApiCartDemandUploadImageRequest, options?: any) {
        return V1ApiFp(this.configuration).cartDemandUploadImage(requestParameters.cartDemand, requestParameters.filterId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, requestParameters.imageRequestBody1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show cart of logged in user
     * @summary Show user cart.
     * @param {V1ApiCartIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public cartIndex(requestParameters: V1ApiCartIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).cartIndex(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync user cart content
     * @summary Sync cart
     * @param {V1ApiCartSyncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public cartSync(requestParameters: V1ApiCartSyncRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).cartSync(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the default channel of authenticated user
     * @summary Get default channel
     * @param {V1ApiChannelDefaultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public channelDefault(requestParameters: V1ApiChannelDefaultRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).channelDefault(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all channels available for this user
     * @summary Show all channels.
     * @param {V1ApiChannelIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public channelIndex(requestParameters: V1ApiChannelIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).channelIndex(requestParameters.filterId, requestParameters.filterCompanyId, requestParameters.filterName, requestParameters.filterSupervisorId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns channel by id
     * @summary Get channel
     * @param {V1ApiChannelShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public channelShow(requestParameters: V1ApiChannelShowRequest, options?: any) {
        return V1ApiFp(this.configuration).channelShow(requestParameters.channel, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show companies
     * @summary Get all company account
     * @param {V1ApiCompanyAccountIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public companyAccountIndex(requestParameters: V1ApiCompanyAccountIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).companyAccountIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show companies
     * @summary Get all Companies
     * @param {V1ApiCompanyIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public companyIndex(requestParameters: V1ApiCompanyIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).companyIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns company by id
     * @summary Get Company
     * @param {V1ApiCompanyShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public companyShow(requestParameters: V1ApiCompanyShowRequest, options?: any) {
        return V1ApiFp(this.configuration).companyShow(requestParameters.company, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating customer
     * @summary Show create customer rule
     * @param {V1ApiCustomerCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerCreate(requestParameters: V1ApiCustomerCreateRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).customerCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating customer with address
     * @summary Show create customer with address rule
     * @param {V1ApiCustomerCreateWithAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerCreateWithAddress(requestParameters: V1ApiCustomerCreateWithAddressRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).customerCreateWithAddress(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a customer by its id
     * @summary Delete Customer
     * @param {V1ApiCustomerDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerDelete(requestParameters: V1ApiCustomerDeleteRequest, options?: any) {
        return V1ApiFp(this.configuration).customerDelete(requestParameters.customer, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new CustomerDeposit
     * @summary Create new CustomerDeposit
     * @param {V1ApiCustomerDepositStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerDepositStore(requestParameters: V1ApiCustomerDepositStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).customerDepositStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing customer
     * @summary Show edit customer rules
     * @param {V1ApiCustomerEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerEdit(requestParameters: V1ApiCustomerEditRequest, options?: any) {
        return V1ApiFp(this.configuration).customerEdit(requestParameters.customer, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all activities of a given customer
     * @summary Show all activities of a customer.
     * @param {V1ApiCustomerGetActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerGetActivities(requestParameters: V1ApiCustomerGetActivitiesRequest, options?: any) {
        return V1ApiFp(this.configuration).customerGetActivities(requestParameters.customer, requestParameters.filterId, requestParameters.filterOrderId, requestParameters.filterUserId, requestParameters.filterCustomerId, requestParameters.filterChannelId, requestParameters.filterCompanyId, requestParameters.filterFollowUpMethod, requestParameters.filterStatus, requestParameters.filterFeedback, requestParameters.filterTargetId, requestParameters.filterFollowUpDatetimeBefore, requestParameters.filterFollowUpDatetimeAfter, requestParameters.filterHasPayment, requestParameters.filterHasAnyBrands, requestParameters.filterCreatedBefore, requestParameters.filterCreatedAfter, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all leads of a given customer
     * @summary Show all leads of a customer.
     * @param {V1ApiCustomerGetLeadsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerGetLeads(requestParameters: V1ApiCustomerGetLeadsRequest, options?: any) {
        return V1ApiFp(this.configuration).customerGetLeads(requestParameters.customer, requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all Customer stored globally in the application.
     * @summary Show all customer.
     * @param {V1ApiCustomerIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerIndex(requestParameters: V1ApiCustomerIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).customerIndex(requestParameters.filterId, requestParameters.filterFirstName, requestParameters.filterLastName, requestParameters.filterEmail, requestParameters.filterPhone, requestParameters.filterSearch, requestParameters.filterHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns customer by id
     * @summary Get Customer
     * @param {V1ApiCustomerShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerShow(requestParameters: V1ApiCustomerShowRequest, options?: any) {
        return V1ApiFp(this.configuration).customerShow(requestParameters.customer, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating customer
     * @summary Create new Customer
     * @param {V1ApiCustomerStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerStore(requestParameters: V1ApiCustomerStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).customerStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new customer with address. This will assign the address as the customer\'s default address id as well
     * @summary Create new customer with address
     * @param {V1ApiCustomerStoreWithAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerStoreWithAddress(requestParameters: V1ApiCustomerStoreWithAddressRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).customerStoreWithAddress(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given customer
     * @summary Update a customer
     * @param {V1ApiCustomerUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public customerUpdate(requestParameters: V1ApiCustomerUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).customerUpdate(requestParameters.customer, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns order deals by lead id
     * @summary Get order deals
     * @param {V1ApiDealsleadSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public dealsleadSms(requestParameters: V1ApiDealsleadSmsRequest, options?: any) {
        return V1ApiFp(this.configuration).dealsleadSms(requestParameters.id, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get discount that match the given discount code.
     * @summary Get discount by code
     * @param {V1ApiDiscountGetByCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public discountGetByCode(requestParameters: V1ApiDiscountGetByCodeRequest, options?: any) {
        return V1ApiFp(this.configuration).discountGetByCode(requestParameters.code, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all public discounts.
     * @summary Get discounts
     * @param {V1ApiDiscountIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public discountIndex(requestParameters: V1ApiDiscountIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).discountIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.filterActivationCode, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all InteriorDesigns available for this user
     * @summary Show all InteriorDesigns.
     * @param {V1ApiInteriorDesignIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public interiorDesignIndex(requestParameters: V1ApiInteriorDesignIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).interiorDesignIndex(requestParameters.filterId, requestParameters.filterReligionId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns InteriorDesign by id
     * @summary Get InteriorDesign
     * @param {V1ApiInteriorDesignShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public interiorDesignShow(requestParameters: V1ApiInteriorDesignShowRequest, options?: any) {
        return V1ApiFp(this.configuration).interiorDesignShow(requestParameters.interiorDesign, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign an unhandled lead
     * @summary Assign an unhandled lead
     * @param {V1ApiLeadAssignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadAssign(requestParameters: V1ApiLeadAssignRequest, options?: any) {
        return V1ApiFp(this.configuration).leadAssign(requestParameters.lead, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all lead categories.
     * @summary Show all lead categories.
     * @param {V1ApiLeadCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadCategories(requestParameters: V1ApiLeadCategoriesRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).leadCategories(requestParameters.filterId, requestParameters.filterName, requestParameters.filterDescription, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating lead
     * @summary Show create product lead
     * @param {V1ApiLeadCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadCreate(requestParameters: V1ApiLeadCreateRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).leadCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a lead by its id
     * @summary Delete Lead
     * @param {V1ApiLeadDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadDestroy(requestParameters: V1ApiLeadDestroyRequest, options?: any) {
        return V1ApiFp(this.configuration).leadDestroy(requestParameters.lead, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing lead
     * @summary Show edit lead rules
     * @param {V1ApiLeadEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadEdit(requestParameters: V1ApiLeadEditRequest, options?: any) {
        return V1ApiFp(this.configuration).leadEdit(requestParameters.lead, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
     * @summary Show all user\'s lead.
     * @param {V1ApiLeadIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadIndex(requestParameters: V1ApiLeadIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).leadIndex(requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns lead by id
     * @summary Get lead
     * @param {V1ApiLeadShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadShow(requestParameters: V1ApiLeadShowRequest, options?: any) {
        return V1ApiFp(this.configuration).leadShow(requestParameters.lead, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The leads displayed depends on the type of the authenticated user: 1. Sales will see all leads that is directly under him 2. Supervisor will see all of his supervised sales\' leads 3. Director will see all leads in his active/default channel Will not return unhandled leads.
     * @summary Show all sms user\'s lead.
     * @param {V1ApiLeadSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadSms(requestParameters: V1ApiLeadSmsRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).leadSms(requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Lead. Currently only sales are allowed to perform this action. This is because lead must be related to a sales. If we want to allow supervisor to add a new lead, they must pick which sales to assign this sales to (which is not supported yet).
     * @summary Create new Lead
     * @param {V1ApiLeadStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadStore(requestParameters: V1ApiLeadStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).leadStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Lead SMS. Currently only sales are allowed to perform this action. This is because lead must be related to a sales.
     * @summary Create new Lead SMS
     * @param {V1ApiLeadStoreSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadStoreSms(requestParameters: V1ApiLeadStoreSmsRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).leadStoreSms(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint only returns unhandled leads that the authenticated user is able to assign to. (i.e., sales will not be able to see any unhandled leads)
     * @summary Show all unhandled leads.
     * @param {V1ApiLeadUnhandledIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadUnhandledIndex(requestParameters: V1ApiLeadUnhandledIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).leadUnhandledIndex(requestParameters.filterId, requestParameters.filterUserId, requestParameters.filterType, requestParameters.filterStatus, requestParameters.filterLabel, requestParameters.filterLeadCategoryId, requestParameters.filterSubLeadCategoryId, requestParameters.filterCustomerName, requestParameters.filterCustomerSearch, requestParameters.filterChannelName, requestParameters.filterSmsChannelName, requestParameters.filterIsNewCustomer, requestParameters.filterHasActivity, requestParameters.filterCustomerHasActivity, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given lead
     * @summary Update a lead
     * @param {V1ApiLeadUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadUpdate(requestParameters: V1ApiLeadUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).leadUpdate(requestParameters.lead, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given lead SMS
     * @summary Update a lead SMS
     * @param {V1ApiLeadUpdateSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public leadUpdateSms(requestParameters: V1ApiLeadUpdateSmsRequest, options?: any) {
        return V1ApiFp(this.configuration).leadUpdateSms(requestParameters.id, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Approve order
     * @summary Approve order
     * @param {V1ApiOrderApproveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderApprove(requestParameters: V1ApiOrderApproveRequest, options?: any) {
        return V1ApiFp(this.configuration).orderApprove(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will cancel an order.
     * @summary Cancel an order
     * @param {V1ApiOrderCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderCancel(requestParameters: V1ApiOrderCancelRequest, options?: any) {
        return V1ApiFp(this.configuration).orderCancel(requestParameters.order, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will clone and cancel a given order. Newly cloned order will be returned as response.
     * @summary Clone an order
     * @param {V1ApiOrderCloneRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderClone(requestParameters: V1ApiOrderCloneRequest, options?: any) {
        return V1ApiFp(this.configuration).orderClone(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload order detail product unit image
     * @summary Upload order detail product unit image
     * @param {V1ApiOrderDetailRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderDetail(requestParameters: V1ApiOrderDetailRequest, options?: any) {
        return V1ApiFp(this.configuration).orderDetail(requestParameters.orderDetail, requestParameters.filterId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, requestParameters.imageRequestBody2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns orderDetail by id
     * @summary Get orderDetail
     * @param {V1ApiOrderDetailShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderDetailShow(requestParameters: V1ApiOrderDetailShowRequest, options?: any) {
        return V1ApiFp(this.configuration).orderDetailShow(requestParameters.orderDetail, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all order
     * @summary Show all order.
     * @param {V1ApiOrderIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderIndex(requestParameters: V1ApiOrderIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).orderIndex(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterSearch, requestParameters.filterInvoiceNumber, requestParameters.filterApprovalStatus, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint only return orders that can be approved by the authenticated user.
     * @summary Show all orders waiting for approval
     * @param {V1ApiOrderIndexWaitingApprovalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderIndexWaitingApproval(requestParameters: V1ApiOrderIndexWaitingApprovalRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).orderIndexWaitingApproval(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterSearch, requestParameters.filterInvoiceNumber, requestParameters.filterApprovalStatus, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint return approval discount orders that related with the authenticated user.
     * @summary Show all orders approval
     * @param {V1ApiOrderListApprovalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderListApproval(requestParameters: V1ApiOrderListApprovalRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).orderListApproval(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterSearch, requestParameters.filterInvoiceNumber, requestParameters.filterApprovalStatus, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a dummy order for preview purposes. Use this endpoint to check how the order will look like with the discount applied.
     * @summary Order preview
     * @param {V1ApiOrderPreviewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderPreview(requestParameters: V1ApiOrderPreviewRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).orderPreview(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a dummy order for preview update purposes. Use this endpoint to check how the order will look like with the discount applied.
     * @summary Order preview update
     * @param {V1ApiOrderPreviewUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderPreviewUpdate(requestParameters: V1ApiOrderPreviewUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).orderPreviewUpdate(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request Approve order
     * @summary Request Approve order
     * @param {V1ApiOrderRequestApproveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderRequestApprove(requestParameters: V1ApiOrderRequestApproveRequest, options?: any) {
        return V1ApiFp(this.configuration).orderRequestApprove(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns order by id
     * @summary Get order
     * @param {V1ApiOrderShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderShow(requestParameters: V1ApiOrderShowRequest, options?: any) {
        return V1ApiFp(this.configuration).orderShow(requestParameters.order, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new order
     * @summary Create new Order
     * @param {V1ApiOrderStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderStore(requestParameters: V1ApiOrderStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).orderStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an order
     * @summary Update an Order
     * @param {V1ApiOrderUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public orderUpdate(requestParameters: V1ApiOrderUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).orderUpdate(requestParameters.order, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all payment category
     * @summary Show all payment category.
     * @param {V1ApiPaymentCategoryIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public paymentCategoryIndex(requestParameters: V1ApiPaymentCategoryIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).paymentCategoryIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating payment
     * @summary Get create payment rule
     * @param {V1ApiPaymentCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public paymentCreate(requestParameters: V1ApiPaymentCreateRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).paymentCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing payment
     * @summary Show edit payment rules
     * @param {V1ApiPaymentEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public paymentEdit(requestParameters: V1ApiPaymentEditRequest, options?: any) {
        return V1ApiFp(this.configuration).paymentEdit(requestParameters.payment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all payment
     * @summary Show all payment.
     * @param {V1ApiPaymentIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public paymentIndex(requestParameters: V1ApiPaymentIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).paymentIndex(requestParameters.filterId, requestParameters.filterAmount, requestParameters.filterReference, requestParameters.filterStatus, requestParameters.filterPaymentTypeId, requestParameters.filterAddedById, requestParameters.filterApprovedById, requestParameters.filterOrderId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload proof of payment
     * @summary Upload proof of payment
     * @param {V1ApiPaymentProofUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public paymentProofUpload(requestParameters: V1ApiPaymentProofUploadRequest, options?: any) {
        return V1ApiFp(this.configuration).paymentProofUpload(requestParameters.payment, requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, requestParameters.imageRequestBody3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns payment by id
     * @summary Get payment
     * @param {V1ApiPaymentShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public paymentShow(requestParameters: V1ApiPaymentShowRequest, options?: any) {
        return V1ApiFp(this.configuration).paymentShow(requestParameters.payment, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new payment
     * @summary Create new Payment
     * @param {V1ApiPaymentStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public paymentStore(requestParameters: V1ApiPaymentStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).paymentStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all payment types
     * @summary Show all payment types.
     * @param {V1ApiPaymentTypeIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public paymentTypeIndex(requestParameters: V1ApiPaymentTypeIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).paymentTypeIndex(requestParameters.filterId, requestParameters.filterPaymentCategoryId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given payment
     * @summary Update a payment
     * @param {V1ApiPaymentUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public paymentUpdate(requestParameters: V1ApiPaymentUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).paymentUpdate(requestParameters.payment, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product brands available for the active company
     * @summary Show all brands.
     * @param {V1ApiProductBrandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productBrand(requestParameters: V1ApiProductBrandRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productBrand(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product version available.
     * @summary Show all product version.
     * @param {V1ApiProductCategoryCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productCategoryCodes(requestParameters: V1ApiProductCategoryCodesRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productCategoryCodes(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterProductModelId, requestParameters.filterProductVersionId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product category
     * @summary Show all product category.
     * @param {V1ApiProductCategoryIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productCategoryIndex(requestParameters: V1ApiProductCategoryIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productCategoryIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.filterDescription, requestParameters.filterType, requestParameters.filterParentId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns product category by id
     * @summary Get product category
     * @param {V1ApiProductCategoryShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productCategoryShow(requestParameters: V1ApiProductCategoryShowRequest, options?: any) {
        return V1ApiFp(this.configuration).productCategoryShow(requestParameters.productCategory, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product
     * @summary Show all product.
     * @param {V1ApiProductIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productIndex(requestParameters: V1ApiProductIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productIndex(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterProductModelId, requestParameters.filterProductVersionId, requestParameters.filterProductCategoryCodeId, requestParameters.filterName, requestParameters.filterTags, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product model available.
     * @summary Show all product model.
     * @param {V1ApiProductModelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productModel(requestParameters: V1ApiProductModelRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productModel(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get product model for a given id.
     * @summary Get product model by id.
     * @param {V1ApiProductModelByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productModelById(requestParameters: V1ApiProductModelByIdRequest, options?: any) {
        return V1ApiFp(this.configuration).productModelById(requestParameters.model, requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns product by id
     * @summary Get product
     * @param {V1ApiProductShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productShow(requestParameters: V1ApiProductShowRequest, options?: any) {
        return V1ApiFp(this.configuration).productShow(requestParameters.product, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product tag
     * @summary Show all product tag.
     * @param {V1ApiProductTagIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productTagIndex(requestParameters: V1ApiProductTagIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productTagIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.filterSlug, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns product tag by id
     * @summary Get product tag
     * @param {V1ApiProductTagShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productTagShow(requestParameters: V1ApiProductTagShowRequest, options?: any) {
        return V1ApiFp(this.configuration).productTagShow(requestParameters.productTag, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product unit colours
     * @summary Show all product unit colours.
     * @param {V1ApiProductUnitColoursRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productUnitColours(requestParameters: V1ApiProductUnitColoursRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productUnitColours(requestParameters.filterId, requestParameters.filterName, requestParameters.filterDescription, requestParameters.filterProductId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product unit coverings
     * @summary Show all product unit coverings.
     * @param {V1ApiProductUnitCoveringsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productUnitCoverings(requestParameters: V1ApiProductUnitCoveringsRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productUnitCoverings(requestParameters.filterId, requestParameters.filterProductId, requestParameters.filterName, requestParameters.filterType, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product unit
     * @summary Show all product unit.
     * @param {V1ApiProductUnitIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productUnitIndex(requestParameters: V1ApiProductUnitIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productUnitIndex(requestParameters.filterId, requestParameters.filterProductId, requestParameters.filterColourId, requestParameters.filterCoveringId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns product unit by id
     * @summary Get product unit
     * @param {V1ApiProductUnitShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productUnitShow(requestParameters: V1ApiProductUnitShowRequest, options?: any) {
        return V1ApiFp(this.configuration).productUnitShow(requestParameters.productUnit, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload product unit image
     * @summary Upload product unit image
     * @param {V1ApiProductUnitUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productUnitUpload(requestParameters: V1ApiProductUnitUploadRequest, options?: any) {
        return V1ApiFp(this.configuration).productUnitUpload(requestParameters.productUnit, requestParameters.filterId, requestParameters.filterProductId, requestParameters.filterColourId, requestParameters.filterCoveringId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, requestParameters.imageRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product version available.
     * @summary Show all product version.
     * @param {V1ApiProductVersionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public productVersion(requestParameters: V1ApiProductVersionRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).productVersion(requestParameters.filterId, requestParameters.filterProductBrandId, requestParameters.filterProductModelId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all promo categories.
     * @summary Show all promo categories.
     * @param {V1ApiPromoCategoryIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public promoCategoryIndex(requestParameters: V1ApiPromoCategoryIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).promoCategoryIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns promo category by id
     * @summary Get promo category
     * @param {V1ApiPromoCategoryShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public promoCategoryShow(requestParameters: V1ApiPromoCategoryShowRequest, options?: any) {
        return V1ApiFp(this.configuration).promoCategoryShow(requestParameters.promoCategory, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all promo
     * @summary Show all promo.
     * @param {V1ApiPromoIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public promoIndex(requestParameters: V1ApiPromoIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).promoIndex(requestParameters.filterId, requestParameters.filterPromoCategoryId, requestParameters.filterStartAfter, requestParameters.filterEndBefore, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns promo by id
     * @summary Get promo
     * @param {V1ApiPromoShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public promoShow(requestParameters: V1ApiPromoShowRequest, options?: any) {
        return V1ApiFp(this.configuration).promoShow(requestParameters.promo, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set all current user notification as read
     * @summary Clear all notifications
     * @param {V1ApiPushNotificationClearRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public pushNotificationClear(requestParameters: V1ApiPushNotificationClearRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).pushNotificationClear(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all notifications
     * @summary Show all notifications
     * @param {V1ApiPushNotificationIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public pushNotificationIndex(requestParameters: V1ApiPushNotificationIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).pushNotificationIndex(requestParameters.filterType, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscribe device code to push notification
     * @summary Subscribe device code to push notification
     * @param {V1ApiPushNotificationSubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public pushNotificationSubscribe(requestParameters: V1ApiPushNotificationSubscribeRequest, options?: any) {
        return V1ApiFp(this.configuration).pushNotificationSubscribe(requestParameters.code, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a test notification
     * @summary Send a test notification
     * @param {V1ApiPushNotificationTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public pushNotificationTest(requestParameters: V1ApiPushNotificationTestRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).pushNotificationTest(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsubscribe device code from push notification
     * @summary Unsubscribe device code from push notification
     * @param {V1ApiPushNotificationUnsubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public pushNotificationUnsubscribe(requestParameters: V1ApiPushNotificationUnsubscribeRequest, options?: any) {
        return V1ApiFp(this.configuration).pushNotificationUnsubscribe(requestParameters.code, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating qa message
     * @summary Get create qa message rule
     * @param {V1ApiQaMessageCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaMessageCreate(requestParameters: V1ApiQaMessageCreateRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).qaMessageCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a qa message by its id
     * @summary Delete Qa message
     * @param {V1ApiQaMessageDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaMessageDestroy(requestParameters: V1ApiQaMessageDestroyRequest, options?: any) {
        return V1ApiFp(this.configuration).qaMessageDestroy(requestParameters.qaMessage, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing qa message
     * @summary Show edit qa message rules
     * @param {V1ApiQaMessageEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaMessageEdit(requestParameters: V1ApiQaMessageEditRequest, options?: any) {
        return V1ApiFp(this.configuration).qaMessageEdit(requestParameters.qaMessage, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all qa message
     * @summary Show all qa message.
     * @param {V1ApiQaMessageIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaMessageIndex(requestParameters: V1ApiQaMessageIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).qaMessageIndex(requestParameters.filterId, requestParameters.filterContent, requestParameters.filterTopicId, requestParameters.filterSenderId, requestParameters.filterIsUnread, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns qa message by id
     * @summary Get qa message
     * @param {V1ApiQaMessageShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaMessageShow(requestParameters: V1ApiQaMessageShowRequest, options?: any) {
        return V1ApiFp(this.configuration).qaMessageShow(requestParameters.qaMessage, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new qa message
     * @summary Create new Qa message
     * @param {V1ApiQaMessageStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaMessageStore(requestParameters: V1ApiQaMessageStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).qaMessageStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given qa message
     * @summary Update a qa message
     * @param {V1ApiQaMessageUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaMessageUpdate(requestParameters: V1ApiQaMessageUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).qaMessageUpdate(requestParameters.qaMessage, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for creating qa topic
     * @summary Get create qa topic rule
     * @param {V1ApiQaTopicCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaTopicCreate(requestParameters: V1ApiQaTopicCreateRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).qaTopicCreate(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a qa topic by its id
     * @summary Delete Qa topic
     * @param {V1ApiQaTopicDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaTopicDestroy(requestParameters: V1ApiQaTopicDestroyRequest, options?: any) {
        return V1ApiFp(this.configuration).qaTopicDestroy(requestParameters.qaTopic, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the validation rules for editing qa topic
     * @summary Show edit qa topic rules
     * @param {V1ApiQaTopicEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaTopicEdit(requestParameters: V1ApiQaTopicEditRequest, options?: any) {
        return V1ApiFp(this.configuration).qaTopicEdit(requestParameters.qaTopic, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all Qa Messages of a Qa Topic, this include Qa messages posted by users other than the authenticated user.
     * @summary Get all Qa Messages of a Qa Topic
     * @param {V1ApiQaTopicGetQaMessagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaTopicGetQaMessages(requestParameters: V1ApiQaTopicGetQaMessagesRequest, options?: any) {
        return V1ApiFp(this.configuration).qaTopicGetQaMessages(requestParameters.topic, requestParameters.filterId, requestParameters.filterContent, requestParameters.filterTopicId, requestParameters.filterSenderId, requestParameters.filterIsUnread, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all qa topic
     * @summary Show all qa topic.
     * @param {V1ApiQaTopicIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaTopicIndex(requestParameters: V1ApiQaTopicIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).qaTopicIndex(requestParameters.filterId, requestParameters.filterSubject, requestParameters.filterCreatorId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns qa topic by id
     * @summary Get qa topic
     * @param {V1ApiQaTopicShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaTopicShow(requestParameters: V1ApiQaTopicShowRequest, options?: any) {
        return V1ApiFp(this.configuration).qaTopicShow(requestParameters.qaTopic, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new qa topic
     * @summary Create new Qa topic
     * @param {V1ApiQaTopicStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaTopicStore(requestParameters: V1ApiQaTopicStoreRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).qaTopicStore(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a given qa topic
     * @summary Update a qa topic
     * @param {V1ApiQaTopicUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public qaTopicUpdate(requestParameters: V1ApiQaTopicUpdateRequest, options?: any) {
        return V1ApiFp(this.configuration).qaTopicUpdate(requestParameters.qaTopic, requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register sales SMS
     * @summary Register sales SMS
     * @param {V1ApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public register(requestParameters: V1ApiRegisterRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).register(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all report
     * @summary Show all report.
     * @param {V1ApiReportIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public reportIndex(requestParameters: V1ApiReportIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).reportIndex(requestParameters.filterId, requestParameters.filterPeriodBefore, requestParameters.filterPeriodAfter, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns report by id
     * @summary Get report
     * @param {V1ApiReportShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public reportShow(requestParameters: V1ApiReportShowRequest, options?: any) {
        return V1ApiFp(this.configuration).reportShow(requestParameters.report, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns lead sms by id
     * @summary Get lead sms
     * @param {V1ApiShowleadSmsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public showleadSms(requestParameters: V1ApiShowleadSmsRequest, options?: any) {
        return V1ApiFp(this.configuration).showleadSms(requestParameters.id, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all SMS channels available for this user
     * @summary Show all SMS channels.
     * @param {V1ApiSmsChannelIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public smsChannelIndex(requestParameters: V1ApiSmsChannelIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).smsChannelIndex(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns SMS channel by id
     * @summary Get SMS channel
     * @param {V1ApiSmsChannelShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public smsChannelShow(requestParameters: V1ApiSmsChannelShowRequest, options?: any) {
        return V1ApiFp(this.configuration).smsChannelShow(requestParameters.smsChannel, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all product brands available for the active company
     * @summary Show all brands.
     * @param {V1ApiSmsProductBrandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public smsProductBrand(requestParameters: V1ApiSmsProductBrandRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).smsProductBrand(requestParameters.filterId, requestParameters.filterName, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all stock
     * @summary Show all stock.
     * @param {V1ApiStockIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public stockIndex(requestParameters: V1ApiStockIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).stockIndex(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterProductUnitId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all stock with additional loaded properties.
     * @summary Show all stock (with extended data).
     * @param {V1ApiStockIndexExtendedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public stockIndexExtended(requestParameters: V1ApiStockIndexExtendedRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).stockIndexExtended(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterProductUnitId, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns stock by id
     * @summary Get stock
     * @param {V1ApiStockShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public stockShow(requestParameters: V1ApiStockShowRequest, options?: any) {
        return V1ApiFp(this.configuration).stockShow(requestParameters.stock, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sub lead categories.
     * @summary Get sub lead categories.
     * @param {V1ApiSubLeadCategoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public subLeadCategories(requestParameters: V1ApiSubLeadCategoriesRequest, options?: any) {
        return V1ApiFp(this.configuration).subLeadCategories(requestParameters.leadCategory, requestParameters.filterId, requestParameters.filterName, requestParameters.filterDescription, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all target
     * @summary Show all target.
     * @param {V1ApiTargetIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public targetIndex(requestParameters: V1ApiTargetIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).targetIndex(requestParameters.filterId, requestParameters.filterReportId, requestParameters.filterIsDashboard, requestParameters.filterStartAfter, requestParameters.filterEndBefore, requestParameters.filterReportableType, requestParameters.filterReportableIds, requestParameters.filterType, requestParameters.filterSupervisorTypeLevel, requestParameters.filterCompanyId, requestParameters.filterDescendantOf, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change password of currently logged in user
     * @summary Change password
     * @param {V1ApiUserChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public userChangePassword(requestParameters: V1ApiUserChangePasswordRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).userChangePassword(requestParameters.accept, requestParameters.contentType, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all users registered in the system. This is currently unfiltered, but in the future we may filter to limit user visibility.
     * @summary Show all users.
     * @param {V1ApiUserIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public userIndex(requestParameters: V1ApiUserIndexRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).userIndex(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterSupervisorId, requestParameters.filterSupervisorTypeId, requestParameters.filterCompanyId, requestParameters.filterName, requestParameters.filterType, requestParameters.filterDescendantOf, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Front end should filter by company id
     * @summary Show list of available users to look into the report.
     * @param {V1ApiUserListForReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public userListForReport(requestParameters: V1ApiUserListForReportRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).userListForReport(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterSupervisorId, requestParameters.filterSupervisorTypeId, requestParameters.filterCompanyId, requestParameters.filterName, requestParameters.filterType, requestParameters.filterDescendantOf, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user resource of the currently logged in user
     * @summary Get logged in user detail
     * @param {V1ApiUserMeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public userMe(requestParameters: V1ApiUserMeRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).userMe(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the default channel for this user. Default channel must be set before user can access tenanted resources.
     * @summary Set default channel
     * @param {V1ApiUserSetDefaultChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public userSetDefaultChannel(requestParameters: V1ApiUserSetDefaultChannelRequest, options?: any) {
        return V1ApiFp(this.configuration).userSetDefaultChannel(requestParameters.channel, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Currently allow access to all users on the system
     * @summary Get user detail
     * @param {V1ApiUserShowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public userShow(requestParameters: V1ApiUserShowRequest, options?: any) {
        return V1ApiFp(this.configuration).userShow(requestParameters.user, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all users that is supervised by this user (all child and grandchild nodes). Does not include data of currently logged in user and data of supervisor.
     * @summary Show all supervised users.
     * @param {V1ApiUserSupervisedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public userSupervised(requestParameters: V1ApiUserSupervisedRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).userSupervised(requestParameters.filterId, requestParameters.filterChannelId, requestParameters.filterSupervisorId, requestParameters.filterSupervisorTypeId, requestParameters.filterCompanyId, requestParameters.filterName, requestParameters.filterType, requestParameters.filterDescendantOf, requestParameters.page, requestParameters.perPage, requestParameters.sort, requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the detail of logged in user\'s supervisor (direct parent)
     * @summary Get detail of supervisor
     * @param {V1ApiUserSupervisorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public userSupervisor(requestParameters: V1ApiUserSupervisorRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).userSupervisor(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list supervisor types
     * @summary Get list supervisor types
     * @param {V1ApiUserSupervisorTypesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1Api
     */
    public userSupervisorTypes(requestParameters: V1ApiUserSupervisorTypesRequest = {}, options?: any) {
        return V1ApiFp(this.configuration).userSupervisorTypes(requestParameters.accept, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


